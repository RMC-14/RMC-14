using Content.Client._RMC14.UserInterface;
using Content.Shared._RMC14.Marines.Squads;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Utility;

namespace Content.Client._RMC14.Overwatch;

[GenerateTypedNameReferences]
public sealed partial class SquadObjectivesWindow : DefaultWindow
{
    private readonly Dictionary<SquadObjectiveType, (TextEdit Input, Button UpdateButton, Button CancelButton, string OriginalText)> _objectiveControls = new();

    public SquadObjectivesWindow()
    {
        RobustXamlLoader.Load(this);

        // Dynamically generate UI for each objective type in the enum
        foreach (SquadObjectiveType objectiveType in Enum.GetValues<SquadObjectiveType>())
        {
            CreateObjectivePanel(objectiveType);
        }
    }

    private void CreateObjectivePanel(SquadObjectiveType objectiveType)
    {
        var panel = new PanelContainer
        {
            HorizontalExpand = true,
            Margin = new Robust.Shared.Maths.Thickness(0, 0, 0, 8)
        };

        var panelOverride = new Robust.Client.Graphics.StyleBoxFlat
        {
            BorderColor = new Robust.Shared.Maths.Color(58, 58, 58),
            BorderThickness = new Robust.Shared.Maths.Thickness(1),
            BackgroundColor = new Robust.Shared.Maths.Color(37, 37, 37)
        };
        panel.PanelOverride = panelOverride;

        var container = new BoxContainer
        {
            Orientation = BoxContainer.LayoutOrientation.Vertical,
            Margin = new Robust.Shared.Maths.Thickness(4)
        };

        // Objective type label
        var typeLabel = new RichTextLabel
        {
            Text = GetObjectiveTypeName(objectiveType),
            StyleClasses = { "ColumnHeaderText" },
            Margin = new Robust.Shared.Maths.Thickness(2)
        };
        container.AddChild(typeLabel);
        container.AddChild(new BlueHorizontalSeparator());

        // Large input field for objective text
        var input = new TextEdit
        {
            HorizontalExpand = true,
            MinHeight = 80,
            Margin = new Robust.Shared.Maths.Thickness(2, 4, 2, 4),
            Placeholder = new Robust.Shared.Utility.Rope.Leaf(Loc.GetString("rmc-overwatch-console-objective-placeholder"))
        };
        container.AddChild(input);

        // Buttons container
        var buttonsContainer = new BoxContainer
        {
            Orientation = BoxContainer.LayoutOrientation.Horizontal,
            HorizontalExpand = true,
            Margin = new Robust.Shared.Maths.Thickness(2, 0, 2, 0)
        };

        // Update button
        var updateButton = new Button
        {
            Text = Loc.GetString("rmc-overwatch-console-objective-update"),
            StyleClasses = { "OpenBoth" },
            HorizontalExpand = true,
            Disabled = true
        };
        buttonsContainer.AddChild(updateButton);

        // Cancel button
        var cancelButton = new Button
        {
            Text = Loc.GetString("rmc-overwatch-console-objective-cancel"),
            StyleClasses = { "OpenBoth" },
            HorizontalExpand = true,
            Disabled = true,
            Margin = new Robust.Shared.Maths.Thickness(4, 0, 0, 0)
        };
        buttonsContainer.AddChild(cancelButton);

        container.AddChild(buttonsContainer);
        panel.AddChild(container);
        ObjectivesContainer.AddChild(panel);

        // Store controls for later access (originalText will be set when SetObjective is called)
        _objectiveControls[objectiveType] = (input, updateButton, cancelButton, string.Empty);

        // Track changes to enable/disable buttons
        input.OnTextChanged += args =>
        {
            if (!_objectiveControls.TryGetValue(objectiveType, out var controls))
                return;

            var text = Rope.Collapse(args.TextRope);
            var hasText = !string.IsNullOrWhiteSpace(text);
            var hasOriginalObjective = !string.IsNullOrWhiteSpace(controls.OriginalText);
            var textChanged = text != controls.OriginalText;
            // Update button is disabled if field is empty, or if there's an original objective and text hasn't changed
            updateButton.Disabled = string.IsNullOrWhiteSpace(text) || (hasOriginalObjective && !textChanged);
            cancelButton.Disabled = !hasOriginalObjective;
        };
    }

    private string GetObjectiveTypeName(SquadObjectiveType objectiveType)
    {
        return objectiveType switch
        {
            SquadObjectiveType.Primary => Loc.GetString("rmc-overwatch-console-objective-primary"),
            SquadObjectiveType.Secondary => Loc.GetString("rmc-overwatch-console-objective-secondary"),
            _ => objectiveType.ToString()
        };
    }

    public void SetObjective(SquadObjectiveType objectiveType, string text)
    {
        if (!_objectiveControls.TryGetValue(objectiveType, out var controls))
            return;

        controls.Input.TextRope = new Rope.Leaf(text);
        // Update the stored original text
        _objectiveControls[objectiveType] = (controls.Input, controls.UpdateButton, controls.CancelButton, text);

        // Update button states
        var hasOriginalObjective = !string.IsNullOrWhiteSpace(text);
        // After setting objective, text matches original, so Update button should be disabled
        controls.UpdateButton.Disabled = string.IsNullOrWhiteSpace(text) || hasOriginalObjective;
        controls.CancelButton.Disabled = !hasOriginalObjective;
    }

    public string GetObjective(SquadObjectiveType objectiveType)
    {
        if (!_objectiveControls.TryGetValue(objectiveType, out var controls))
            return string.Empty;

        return Rope.Collapse(controls.Input.TextRope);
    }

    public void SetUpdateButtonAction(SquadObjectiveType objectiveType, Action action)
    {
        if (!_objectiveControls.TryGetValue(objectiveType, out var controls))
            return;

        controls.UpdateButton.OnPressed += _ => action();
    }

    public void SetCancelButtonAction(SquadObjectiveType objectiveType, Action action)
    {
        if (!_objectiveControls.TryGetValue(objectiveType, out var controls))
            return;

        controls.CancelButton.OnPressed += _ => action();
    }

    public void UpdateButtonsState(SquadObjectiveType objectiveType, string currentObjective)
    {
        if (!_objectiveControls.TryGetValue(objectiveType, out var controls))
            return;

        var text = Rope.Collapse(controls.Input.TextRope);
        var hasOriginalObjective = !string.IsNullOrWhiteSpace(currentObjective);
        var textChanged = text != currentObjective;
        // Update button is disabled if field is empty, or if there's an original objective and text hasn't changed
        controls.UpdateButton.Disabled = string.IsNullOrWhiteSpace(text) || (hasOriginalObjective && !textChanged);
        controls.CancelButton.Disabled = !hasOriginalObjective;

        // Update stored original text
        _objectiveControls[objectiveType] = (controls.Input, controls.UpdateButton, controls.CancelButton, currentObjective);
    }

    public void UpdateObjectiveIfUnchanged(SquadObjectiveType objectiveType, string newObjective)
    {
        if (!_objectiveControls.TryGetValue(objectiveType, out var controls))
            return;

        var currentText = Rope.Collapse(controls.Input.TextRope);

        // Only update if the current text matches the original (user hasn't edited it)
        if (currentText == controls.OriginalText)
        {
            controls.Input.TextRope = new Rope.Leaf(newObjective);
            // Update the stored original text to the new value
            _objectiveControls[objectiveType] = (controls.Input, controls.UpdateButton, controls.CancelButton, newObjective);

            // Update button states
            var hasOriginalObjective = !string.IsNullOrWhiteSpace(newObjective);
            controls.UpdateButton.Disabled = string.IsNullOrWhiteSpace(newObjective) || hasOriginalObjective;
            controls.CancelButton.Disabled = !hasOriginalObjective;
        }
        else
        {
            // User is editing, but update the original text reference for button state calculation
            // This way if they revert to original, it will match the new original
            _objectiveControls[objectiveType] = (controls.Input, controls.UpdateButton, controls.CancelButton, newObjective);

            // Recalculate button states based on current text vs new original
            var hasOriginalObjective = !string.IsNullOrWhiteSpace(newObjective);
            var textChanged = currentText != newObjective;
            controls.UpdateButton.Disabled = string.IsNullOrWhiteSpace(currentText) || (hasOriginalObjective && !textChanged);
            controls.CancelButton.Disabled = !hasOriginalObjective;
        }
    }
}

