using System.Collections.Generic;
using System.Numerics;
using System.Linq;
using Content.Shared._RMC14.Vehicle;
using Content.Shared._RMC14.Vehicle.Supply;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Content.Client.UserInterface.Controls;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using Robust.Client.Utility;
using Robust.Shared.GameObjects;
using Robust.Shared.IoC;
using Robust.Shared.Log;
using Robust.Shared.Maths;
using Robust.Shared.Timing;
using Robust.Shared.Utility;
using Robust.Client.GameObjects;
using Robust.Shared.Graphics.RSI;

namespace Content.Client._RMC14.Vehicle.Supply;

[GenerateTypedNameReferences]
public sealed partial class RMCVehicleSupplyWindow : FancyWindow
{
    private readonly IEntityManager _entManager = IoCManager.Resolve<IEntityManager>();
    private bool _previewDirty;
    private readonly List<RMCVehicleHardpointLayerState> _previewLayers = new();
    private bool _previewOverlaysDirty;
    private readonly List<RMCVehicleSupplyPreviewOverlay> _previewOverlays = new();
    private readonly List<PreviewOverlay> _previewOverlayViews = new();
    private bool _activityActive;
    private float _activityTimer;
    private int _activityIndex;
    private Color _activityActiveColor = Color.FromHex("#6BC7FF");
    private static readonly Color ActivityIdleColor = Color.FromHex("#1E3450");
    private static readonly Color ActivityPrepColor = Color.FromHex("#D6C45A");
    private const float PixelsPerMeter = 32f;
    private const float DebugLogInterval = 0.5f;
    private const float DebugOffsetEpsilon = 0.001f;
    private float _debugTimer;
    private Direction? _lastDebugDir;
    private readonly Dictionary<EntityUid, Vector2> _lastOverlayOffsets = new();

    private sealed class PreviewOverlay
    {
        public EntityUid Entity;
        public SpriteComponent Sprite = default!;
        public SpriteView View = default!;
        public RMCVehicleSupplyPreviewOverlay Data = default!;
        public int DirectionCount;
    }

    public RMCVehicleSupplyWindow()
    {
        RobustXamlLoader.Load(this);
    }

    protected override void FrameUpdate(FrameEventArgs args)
    {
        base.FrameUpdate(args);

        TryApplyPreviewLayers();
        TryApplyPreviewOverlays();
        if (_previewOverlayViews.Count > 0)
        {
            var dir = VehiclePreview.OverrideDirection ?? Direction.South;
            UpdatePreviewOverlayOffsets(dir);
        }
        _debugTimer += args.DeltaSeconds;
        UpdateLiftActivity(args.DeltaSeconds);
    }

    public void SetPreview(RMCVehicleSupplyPreviewState? preview)
    {
        if (preview == null || string.IsNullOrWhiteSpace(preview.VehicleId))
        {
            PreviewTitle.Text = "Vehicle Preview";
            VehiclePreview.SetPrototype(null);
            _previewLayers.Clear();
            _previewDirty = false;
            _previewOverlays.Clear();
            _previewOverlaysDirty = false;
            ClearPreviewOverlays();
            VehiclePreview.InvalidateMeasure();
            VehiclePreviewContainer?.InvalidateMeasure();
            return;
        }

        PreviewTitle.Text = preview.VehicleId;
        VehiclePreview.SetPrototype(preview.VehicleId);
        VehiclePreview.OverrideDirection = Direction.South;

        _previewLayers.Clear();
        _previewLayers.AddRange(preview.Layers);
        _previewDirty = true;

        _previewOverlays.Clear();
        _previewOverlays.AddRange(preview.Overlays);
        _previewOverlaysDirty = true;

        TryApplyPreviewLayers();
        TryApplyPreviewOverlays();
        VehiclePreview.InvalidateMeasure();
        VehiclePreviewContainer?.InvalidateMeasure();
    }

    private void TryApplyPreviewLayers()
    {
        if (!_previewDirty)
            return;

        if (VehiclePreview.Entity is not { } entity)
            return;

        var sprite = entity.Comp1;
        foreach (var entry in _previewLayers)
        {
            if (!sprite.LayerMapTryGet(entry.Layer, out var layer))
                continue;

            if (string.IsNullOrWhiteSpace(entry.State))
            {
                sprite.LayerSetVisible(layer, false);
                continue;
            }

            sprite.LayerSetState(layer, entry.State);
            sprite.LayerSetVisible(layer, true);
        }

        _previewDirty = false;
    }

    private void TryApplyPreviewOverlays()
    {
        if (!_previewOverlaysDirty)
            return;

        ClearPreviewOverlays();

        if (VehiclePreviewContainer == null)
            return;

        if (VehiclePreview.Entity is not { } entity)
            return;

        var dir = VehiclePreview.OverrideDirection ?? Direction.South;

        var ordered = _previewOverlays
            .OrderBy(o => o.Order)
            .ToList();

        foreach (var overlay in ordered)
        {
            if (string.IsNullOrWhiteSpace(overlay.Rsi) || string.IsNullOrWhiteSpace(overlay.State))
                continue;

            var overlayEnt = _entManager.Spawn(null);
            var sprite = _entManager.AddComponent<SpriteComponent>(overlayEnt);
            var spec = new SpriteSpecifier.Rsi(new ResPath(overlay.Rsi), overlay.State);
            var spriteSystem = _entManager.System<SpriteSystem>();
            var layer = spriteSystem.AddLayer((overlayEnt, sprite), spec);
            if (layer >= 0)
                spriteSystem.LayerSetVisible((overlayEnt, sprite), layer, true);
            var dirCount = spriteSystem.LayerGetDirectionCount((overlayEnt, sprite), 0);

            var view = new SpriteView
            {
                MinSize = VehiclePreview.MinSize,
                Stretch = VehiclePreview.Stretch,
                VerticalAlignment = VehiclePreview.VerticalAlignment,
                HorizontalAlignment = VehiclePreview.HorizontalAlignment,
                Margin = VehiclePreview.Margin,
                OverrideDirection = dir,
                SpriteOffset = true
            };
            view.SetEntity(overlayEnt);
            VehiclePreviewContainer.AddChild(view);
            _previewOverlayViews.Add(new PreviewOverlay
            {
                Entity = overlayEnt,
                Sprite = sprite,
                View = view,
                Data = overlay,
                DirectionCount = dirCount
            });
        }

        UpdatePreviewOverlayOffsets(dir);
        _previewOverlaysDirty = false;
    }

    private void UpdatePreviewOverlayOffsets(Direction dir)
    {
        if (_previewOverlayViews.Count == 0)
            return;

        var spriteSystem = _entManager.System<SpriteSystem>();
        var canLog = _debugTimer >= DebugLogInterval;
        var logged = 0;

        if (canLog && (!_lastDebugDir.HasValue || _lastDebugDir.Value != dir))
        {
            if (VehiclePreview.Entity is { } baseEntity)
            {
                var baseSprite = baseEntity.Comp1;
                var layerOffset = Vector2.Zero;
                var layerState = string.Empty;
                var layerDirs = 0;
                if (baseSprite.AllLayers.FirstOrDefault() is SpriteComponent.Layer layer)
                {
                    layerOffset = layer.Offset;
                    layerState = layer.State.ToString();
                    layerDirs = spriteSystem.LayerGetDirectionCount((baseEntity.Owner, baseSprite), 0);
                }

                Logger.Log(LogLevel.Info,
                    $"[rmc-hardpoint-preview] lift base dir={dir} vehicleOffset={baseSprite.Offset} " +
                    $"layer0Offset={layerOffset} layer0State='{layerState}' layer0Dirs={layerDirs} " +
                    $"spriteOffset={VehiclePreview.SpriteOffset}");
            }
        }

        foreach (var overlay in _previewOverlayViews)
        {
            var effectiveDir = GetEffectiveDirection(dir, overlay.DirectionCount);
            overlay.View.OverrideDirection = effectiveDir;
            var offsetPixels = GetOffsetPixels(overlay.Data, effectiveDir);
            var offsetMeters = offsetPixels / PixelsPerMeter;
            spriteSystem.SetOffset((overlay.Entity, overlay.Sprite), offsetMeters);

            if (!canLog)
                continue;

            var shouldLog = !_lastDebugDir.HasValue || _lastDebugDir.Value != dir;
            if (!shouldLog && _lastOverlayOffsets.TryGetValue(overlay.Entity, out var last))
                shouldLog = (offsetMeters - last).LengthSquared() > DebugOffsetEpsilon * DebugOffsetEpsilon;
            else if (!shouldLog)
                shouldLog = true;

            if (!shouldLog)
                continue;

            Logger.Log(LogLevel.Info,
                $"[rmc-hardpoint-preview] lift offset dir={dir} effectiveDir={effectiveDir} dirs={overlay.DirectionCount} " +
                $"overlay='{overlay.Data.State}' rsi='{overlay.Data.Rsi}' " +
                $"offsetPixels={offsetPixels} offsetMeters={offsetMeters}");

            _lastOverlayOffsets[overlay.Entity] = offsetMeters;
            logged++;

            if (logged >= 3)
                break;
        }

        if (logged > 0)
        {
            _debugTimer = 0f;
            _lastDebugDir = dir;
        }
    }

    private static Vector2 GetOffsetPixels(RMCVehicleSupplyPreviewOverlay overlay, Direction dir)
    {
        if (!overlay.UseDirectional)
            return overlay.BaseOffset;

        var angle = dir.ToAngle();
        var normalized = angle.Theta % MathHelper.TwoPi;
        if (normalized < 0f)
            normalized += MathHelper.TwoPi;

        var segment = MathHelper.PiOver2;
        var index = (int) Math.Floor(normalized / segment) & 3;
        var t = (float) ((normalized - index * segment) / segment);

        var current = overlay.BaseOffset + GetDirectionalOffset(overlay, index);
        var next = overlay.BaseOffset + GetDirectionalOffset(overlay, (index + 1) & 3);
        return Vector2.Lerp(current, next, t);
    }

    private static Direction GetEffectiveDirection(Direction dir, int directionCount)
    {
        if (directionCount <= 1)
            return Direction.South;

        if (directionCount <= 4)
            return dir.Convert(RsiDirectionType.Dir4).Convert();

        return dir;
    }

    private static Vector2 GetDirectionalOffset(RMCVehicleSupplyPreviewOverlay overlay, int index)
    {
        return index switch
        {
            0 => overlay.South,
            1 => overlay.East,
            2 => overlay.North,
            3 => overlay.West,
            _ => Vector2.Zero
        };
    }

    private void ClearPreviewOverlays()
    {
        foreach (var overlay in _previewOverlayViews)
        {
            if (!overlay.View.Disposed)
            {
                overlay.View.Orphan();
                overlay.View.Dispose();
            }

            if (!_entManager.Deleted(overlay.Entity))
                _entManager.DeleteEntity(overlay.Entity);
        }

        _previewOverlayViews.Clear();
        _lastOverlayOffsets.Clear();
        _lastDebugDir = null;
    }

    public void SetLiftActivity(RMCVehicleSupplyLiftMode? mode, bool busy)
    {
        if (busy && mode == RMCVehicleSupplyLiftMode.Preparing)
        {
            _activityActive = true;
            _activityActiveColor = ActivityPrepColor;
        }
        else if (mode == RMCVehicleSupplyLiftMode.Raising)
        {
            _activityActive = true;
            _activityActiveColor = Color.FromHex("#6BC7FF");
        }
        else if (mode == RMCVehicleSupplyLiftMode.Lowering)
        {
            _activityActive = true;
            _activityActiveColor = Color.FromHex("#E1786A");
        }
        else
        {
            _activityActive = false;
        }

        if (!_activityActive)
        {
            SetDotColor(LiftDot1, ActivityIdleColor);
            SetDotColor(LiftDot2, ActivityIdleColor);
            SetDotColor(LiftDot3, ActivityIdleColor);
            _activityTimer = 0f;
            _activityIndex = 0;
        }
    }

    private void UpdateLiftActivity(float frameTime)
    {
        if (!_activityActive)
            return;

        _activityTimer += frameTime;
        if (_activityTimer < 0.2f)
            return;

        _activityTimer = 0f;
        _activityIndex = (_activityIndex + 1) % 3;

        SetDotColor(LiftDot1, _activityIndex == 0 ? _activityActiveColor : ActivityIdleColor);
        SetDotColor(LiftDot2, _activityIndex == 1 ? _activityActiveColor : ActivityIdleColor);
        SetDotColor(LiftDot3, _activityIndex == 2 ? _activityActiveColor : ActivityIdleColor);
    }

    private static void SetDotColor(PanelContainer dot, Color color)
    {
        dot.PanelOverride = new StyleBoxFlat
        {
            BackgroundColor = color,
            BorderColor = Color.FromHex("#2D5E8E"),
            BorderThickness = new Thickness(1)
        };
    }

    protected override void Dispose(bool disposing)
    {
        base.Dispose(disposing);
        ClearPreviewOverlays();
    }

}
