using Content.Client.UserInterface.Controls;
using Content.Shared._RMC14.Kitchen;
using Content.Shared.Chemistry.Reagent;
using Content.Shared.Kitchen;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes;

namespace Content.Client._RMC14.UserInterface.FoodProcessorUI
{
    [GenerateTypedNameReferences]
    public sealed partial class ProcessorMenu : FancyWindow
    {
        [Dependency] private readonly IEntityManager _entityManager = default!;
        [Dependency] private readonly IPrototypeManager _prototypeManager = default!;

        private readonly Dictionary<int, EntityUid> _chamberVisualContents = new();

        public event Action? OnProcess;
        public event Action? OnEjectAll;
        public event Action<EntityUid>? OnEjectChamber;

        public ProcessorMenu()
        {
            RobustXamlLoader.Load(this);
            IoCManager.InjectDependencies(this);
            ProcessButton.OnPressed += _ => OnProcess?.Invoke();
            ChamberContentBox.EjectButton.OnPressed += _ => OnEjectAll?.Invoke();
            ChamberContentBox.BoxContents.OnItemSelected += OnChamberBoxContentsItemSelected;
        }

        private void OnChamberBoxContentsItemSelected(ItemList.ItemListSelectedEventArgs args)
        {
            OnEjectChamber?.Invoke(_chamberVisualContents[args.ItemIndex]);
        }

        public void UpdateState(ProcessorInterfaceState state)
        {
            ChamberContentBox.EjectButton.Disabled = state.ChamberContents.Length <= 0;
            ProcessButton.Disabled = !state.CanProcess || !state.Powered;

            // TODO move this to a component state and ensure the net ids.
            RefreshContentsDisplay(state.ReagentQuantities, _entityManager.GetEntityArray(state.ChamberContents), state.IsOn);
        }

        public void HandleMessage(BoundUserInterfaceMessage message)
        {
            switch (message)
            {
                case ProcessorWorkStartedMessage workStarted:
                    ProcessButton.Disabled = true;
                    ProcessButton.Modulate = workStarted.ProcessorProgram == ProcessorProgram.Process ? Color.Green : Color.White;
                    ChamberContentBox.EjectButton.Disabled = true;
                    break;
                case ProcessorWorkCompleteMessage:
                    ProcessButton.Disabled = false;
                    ProcessButton.Modulate = Color.White;
                    ChamberContentBox.EjectButton.Disabled = false;
                    break;
            }
        }

        private void RefreshContentsDisplay(IList<ReagentQuantity>? reagents, IReadOnlyList<EntityUid> containedSolids, bool isBeakerAttached)
        {
            //Refresh chamber contents
            _chamberVisualContents.Clear();

            ChamberContentBox.BoxContents.Clear();
            foreach (var entity in containedSolids)
            {
                if (!_entityManager.EntityExists(entity))
                {
                    return;
                }

                var texture = _entityManager.GetComponent<SpriteComponent>(entity).Icon?.Default;

                var solidItem = ChamberContentBox.BoxContents.AddItem(_entityManager.GetComponent<MetaDataComponent>(entity).EntityName, texture);
                var solidIndex = ChamberContentBox.BoxContents.IndexOf(solidItem);
                _chamberVisualContents.Add(solidIndex, entity);
            }

        }
    }
}
