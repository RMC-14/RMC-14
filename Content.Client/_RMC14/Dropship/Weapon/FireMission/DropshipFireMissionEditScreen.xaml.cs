using System.Linq;
using System.Numerics;
using Robust.Client.AutoGenerated;
using Content.Client.Message;
using Content.Shared._RMC14.Dropship.Weapon;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;

namespace Content.Client._RMC14.Dropship.Weapon.FireMission;

[GenerateTypedNameReferences]
public sealed partial class DropshipFireMissionEditScreen : PanelContainer
{
    public event Action<int, int, int?>? FireMissionOffsetSelected;

    private const int FontSize = 10;

    private readonly Dictionary<int, List<DropshipFireMissionOffsetButton>> _buttonsByRow = new();
    private readonly HashSet<int> _activeOffsetRows = new();
    private List<int?> _offsetColumns = new();
    private FireMissionData _fireMission;
    private WeaponDisplayInfo? _weapon;

    public DropshipFireMissionEditScreen()
    {
        RobustXamlLoader.Load(this);
    }

    /// <summary>
    ///     Set the data for the UI
    /// </summary>
    /// <param name="fireMission">The data related to the selected fire mission</param>
    /// <param name="weapon">The weapon info of the selected weapon</param>
    /// <param name="minTiming">The lowest timing at which you can start shooting</param>
    /// <param name="maxDuration">The max duration of the fire missions</param>
    /// <param name="allowedOffsets">The offsets allowed for the weapon</param>
    public void SetData(FireMissionData fireMission, WeaponDisplayInfo weapon, int minTiming, int maxDuration, List<int?> allowedOffsets)
    {
        _fireMission = fireMission;
        _weapon = weapon;
        _offsetColumns = allowedOffsets;

        FireMissionTitle.SetMarkupPermissive($"[color=#00FF36]{fireMission.Name}[/color]");
        WeaponName.SetMarkupPermissive($"[color=#00FF36]{weapon.Name}[/color]");
        WeaponAmmoCount.SetMarkupPermissive($"[color=#00FF36]{weapon.Ammo} / {weapon.MaxAmmo}[/color]");
        WeaponFireDelay.SetMarkupPermissive($"[color=#00FF36]{weapon.FireDelay}[/color]");

        var selectable = new List<int?>();
        foreach (var o in _offsetColumns)
        {
            if (o != null)
                selectable.Add(o);
        }

        WeaponGimbals.SetMarkupPermissive($"[color=#00FF36]{selectable[0]} / {selectable[^1]}[/color]");

        FireMissionRows.RemoveAllChildren();
        _buttonsByRow.Clear();

        BuildHeader();
        BuildRows(minTiming, maxDuration);
        ApplyExistingOffsets();
    }

    private void BuildHeader()
    {
        var header = new BoxContainer
        {
            Orientation = BoxContainer.LayoutOrientation.Horizontal,
            SeparationOverride = 2,
            HorizontalExpand = true,
        };

        var infoLabel = new RichTextLabel
        {
            Text = "[color=#00FF36]Offset[/color]",
            MinSize = new Vector2(100, 18),
            HorizontalAlignment = HAlignment.Right,
            VerticalAlignment = VAlignment.Center,
        };
        header.AddChild(infoLabel);

        var buttonsHeader = new BoxContainer
        {
            Orientation = BoxContainer.LayoutOrientation.Horizontal,
            SeparationOverride = 2,
            HorizontalExpand = true
        };

        foreach (var col in _offsetColumns)
        {
            var label = new RichTextLabel
            {
                Text = col == null ? "[color=#00FF36]Unset[/color]" : $"[color=#00FF36]{col}[/color]",
                MinSize = new Vector2(28, 18),
                HorizontalAlignment = HAlignment.Center,
                VerticalAlignment = VAlignment.Center,
            };
            buttonsHeader.AddChild(label);
        }

        header.AddChild(buttonsHeader);
        FireMissionRows.AddChild(header);
    }

    private void BuildRows(int minTiming, int maxTiming)
    {
        for (var row = minTiming; row <= maxTiming; row++)
        {
            var currentRow = row;

            var rowContainer = new BoxContainer
            {
                Orientation = BoxContainer.LayoutOrientation.Horizontal,
                SeparationOverride = 2,
                HorizontalExpand = true
            };

            var infoLabel = new RichTextLabel
            {
                Text = $"[color=#00FF36]{row}[/color]",
                MinSize = new Vector2(100, 18),
                HorizontalAlignment = HAlignment.Right,
                VerticalAlignment = VAlignment.Center,
            };
            rowContainer.AddChild(infoLabel);

            var buttonsContainer = new BoxContainer
            {
                Orientation = BoxContainer.LayoutOrientation.Horizontal,
                SeparationOverride = 2,
                HorizontalExpand = true,
            };

            var buttons = new List<DropshipFireMissionOffsetButton>();

            foreach (var col in _offsetColumns)
            {
                var button = new DropshipFireMissionOffsetButton
                {
                    Offset = col,
                    HorizontalExpand = true,
                    VerticalExpand = true,
                };

                var label = col == null ? "-" : col.ToString();
                button.RichLabel.SetMarkupPermissive($"[font size={FontSize}][color=#00FF36]{label}[/color][/font]");
                button.SetOnPressed(_ => OnOffsetPressed(currentRow, col, button));

                buttonsContainer.AddChild(button);
                buttons.Add(button);
            }

            _buttonsByRow[row] = buttons;
            rowContainer.AddChild(buttonsContainer);
            FireMissionRows.AddChild(rowContainer);
        }
    }

    private void ApplyExistingOffsets()
    {
        _activeOffsetRows.Clear();
        if (_weapon == null)
            return;

        foreach (var offset in _weapon.Offsets)
        {
            if (!_buttonsByRow.TryGetValue(offset.Row, out var buttons))
                continue;

            foreach (var btn in buttons)
            {
                if (Nullable.Equals(btn.Offset, offset.Offset))
                {
                    btn.MuteSounds = true;
                    btn.SetClickPressed(true);
                    btn.MuteSounds = false;
                }
            }

            if (offset.Offset == null)
                EnableRowsAround(offset.Row);
            else
            {
                DisableRowsAround(offset.Row);
            }
        }
    }

    private void OnOffsetPressed(int row, int? offset, DropshipFireMissionOffsetButton pressed)
    {
        foreach (var btn in _buttonsByRow[row])
        {
            btn.SetClickPressed(btn == pressed);
        }

        if (offset == null)
            EnableRowsAround(row);
        else
            DisableRowsAround(row);

        FireMissionOffsetSelected?.Invoke(_fireMission.Id, row, offset);
    }

    private void DisableRowsAround(int row)
    {
        if (_weapon == null)
            return;

        var delay = _weapon.FireDelay;

        // Disable rows after
        for (var i = 1; i <= delay; i++)
        {
            var target = row + i;
            if (_buttonsByRow.ContainsKey(target) && !IsRowBlocked(target))
                SetRowBusy(target, true);
        }

        // Disable rows before
        for (var i = 1; i <= delay; i++)
        {
            var target = row - i;
            if (_buttonsByRow.ContainsKey(target) && !IsRowBlocked(target))
                SetRowBusy(target, true);
        }

        _activeOffsetRows.Add(row);
    }

    private void EnableRowsAround(int row)
    {
        if (_weapon == null)
            return;

        _activeOffsetRows.Remove(row);

        var delay = _weapon.FireDelay;

        // Re-enable rows after
        for (var i = 1; i <= delay; i++)
        {
            var target = row + i;
            if (_buttonsByRow.ContainsKey(target) && !IsRowBlocked(target))
                SetRowBusy(target, false);
        }

        // Re-enable rows before
        for (var i = 1; i <= delay; i++)
        {
            var target = row - i;
            if (_buttonsByRow.ContainsKey(target) && !IsRowBlocked(target))
                SetRowBusy(target, false);
        }
    }

    private void SetRowBusy(int row, bool busy)
    {
        if (!_buttonsByRow.TryGetValue(row, out var buttons))
            return;

        var rowContainer = buttons[0].Parent as BoxContainer;
        if (rowContainer == null)
            return;

        if (busy)
        {
            // Hide all buttons
            foreach (var btn in buttons)
            {
                btn.Visible = false;
                btn.Disabled = true;
            }

            // Add busy label
            var busyLabel = new RichTextLabel
            {
                Name = "BusyLabel",
                Text = "[color=#FF0000]Weapon busy[/color]",
                HorizontalExpand = true,
                HorizontalAlignment = HAlignment.Center,
            };

            rowContainer.AddChild(busyLabel);
        }
        else
        {
            // Remove busy label
            foreach (var child in rowContainer.Children.ToArray())
            {
                if (child is RichTextLabel label && label.Name == "BusyLabel")
                    rowContainer.RemoveChild(label);
            }

            // Show buttons again
            foreach (var btn in buttons)
            {
                btn.Visible = true;
                btn.Disabled = false;
            }
        }
    }

    /// <summary>
    ///     Checks if the row is blocked by another row having an offset set.
    /// </summary>
    /// <param name="targetRow">The row to check</param>
    /// <returns>True if another row is preventing it from being enabled</returns>
    private bool IsRowBlocked(int targetRow)
    {
        if (_weapon == null)
            return false;

        foreach (var activeRow in _activeOffsetRows)
        {
            var distance = Math.Abs(activeRow - targetRow);
            if (distance <= _weapon.FireDelay && activeRow != targetRow)
                return true;
        }

        return false;
    }
}
