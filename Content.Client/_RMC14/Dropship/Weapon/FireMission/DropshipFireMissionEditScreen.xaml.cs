using System.Linq;
using System.Numerics;
using Robust.Client.AutoGenerated;
using Content.Client.Message;
using Content.Shared._RMC14.Dropship.Weapon;
using Robust.Client.Graphics;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;

namespace Content.Client._RMC14.Dropship.Weapon.FireMission;

[GenerateTypedNameReferences]
public sealed partial class DropshipFireMissionEditScreen : PanelContainer
{
    public event Action<int, int, int?>? FireMissionOffsetSelected;

    private readonly Dictionary<int, List<DropshipFireMissionOffsetButton>> _buttonsByRow = new();
    private readonly HashSet<int> _activeOffsetRows = new();
    private List<int?> _offsetColumns = new();
    private FireMissionData _fireMission;
    private WeaponDisplayInfo? _weapon;
    private int _offsetCount;

    public DropshipFireMissionEditScreen()
    {
        RobustXamlLoader.Load(this);
    }

    /// <summary>
    ///     Fill the UI with information about the firemission.
    /// </summary>
    /// <param name="fireMission">The data related to the selected fire mission</param>
    /// <param name="weapon">The weapon info of the selected weapon</param>
    /// <param name="minTiming">The lowest timing at which you can start shooting</param>
    /// <param name="maxDuration">The max duration of the fire missions</param>
    /// <param name="allowedOffsets">The offsets allowed for the weapon</param>
    public void SetData(FireMissionData fireMission, WeaponDisplayInfo weapon, int minTiming, int maxDuration, List<int?> allowedOffsets)
    {
        _fireMission = fireMission;
        _weapon = weapon;
        _offsetColumns = allowedOffsets;

        FireMissionTitle.SetMarkupPermissive($"Firemission: {fireMission.Name}");
        WeaponName.SetMarkupPermissive($"{weapon.Name}");
        WeaponFireDelay.SetMarkupPermissive($"{weapon.FireDelay}");

        var selectable = new List<int?>();
        foreach (var offset in _offsetColumns)
        {
            if (offset != null)
                selectable.Add(offset);
        }

        WeaponGimbals.SetMarkupPermissive($"{selectable[0]} to {selectable[^1]}");

        FireMissionRows.RemoveAllChildren();
        _buttonsByRow.Clear();

        BuildHeader();
        BuildRows(minTiming, maxDuration);
        ApplyExistingOffsets();

        var totalConsumption = weapon.AmmoConsumption * _offsetCount;
        WeaponAmmoCount.SetMarkupPermissive($"{weapon.Ammo} / {weapon.MaxAmmo} using {totalConsumption} per run");
    }

    private void BuildHeader()
    {
        var header = new BoxContainer
        {
            Orientation = BoxContainer.LayoutOrientation.Horizontal,
            SeparationOverride = 2,
            HorizontalExpand = true,
        };

        var infoWrapper = new PanelContainer
        {
            MinSize = new Vector2(90, 18),
        };

        var infoLabel = new RichTextLabel
        {
            Text = "Offset",
            HorizontalAlignment = HAlignment.Right,
            VerticalAlignment = VAlignment.Center,
            ModulateSelfOverride= Color.FromHex("#00FF36"),
        };

        infoWrapper.AddChild(infoLabel);
        header.AddChild(infoWrapper);

        header.AddChild(new PanelContainer
        {
            MinSize = new Vector2(15, 0),
            VerticalExpand = true,
        });

        var buttonsHeader = new BoxContainer
        {
            Orientation = BoxContainer.LayoutOrientation.Horizontal,
            SeparationOverride = 2,
            HorizontalExpand = true
        };

        foreach (var col in _offsetColumns)
        {
            var wrapper = new PanelContainer
            {
                HorizontalExpand = true,
                VerticalExpand = true,
            };

            var label = new Label
            {
                Text = col == null ? "Unset" : $"{col}",
                MinSize = new Vector2(35, 20),
                HorizontalAlignment = HAlignment.Center,
                VerticalAlignment = VAlignment.Center,
                ModulateSelfOverride= Color.FromHex("#00FF36"),
                Align = Label.AlignMode.Center,
            };

            wrapper.AddChild(label);
            buttonsHeader.AddChild(wrapper);
        }

        header.AddChild(buttonsHeader);
        FireMissionRows.AddChild(header);
    }

    private void BuildRows(int minTiming, int maxTiming)
    {
        var firstRow = true;

        for (var row = minTiming; row <= maxTiming; row++)
        {
            var currentRow = row;

            if (firstRow)
            {
                var separator = new PanelContainer
                {
                    MinSize = new Vector2(0, 10),
                    HorizontalExpand = true,
                    ModulateSelfOverride = Color.FromHex("#00FF36"),
                };
                FireMissionRows.AddChild(separator);
                firstRow = false;
            }

            var rowContainer = new BoxContainer
            {
                Orientation = BoxContainer.LayoutOrientation.Horizontal,
                SeparationOverride = 2,
                HorizontalExpand = true
            };

            var infoWrapper = new PanelContainer
            {
                MinSize = new Vector2(90, 0),
            };

            var infoLabel = new RichTextLabel
            {
                Text = $"{row}",
                HorizontalAlignment = HAlignment.Right,
                VerticalAlignment = VAlignment.Center,
                ModulateSelfOverride= Color.FromHex("#00FF36"),
            };
            infoWrapper.AddChild(infoLabel);
            rowContainer.AddChild(infoWrapper);

            rowContainer.AddChild(new PanelContainer
            {
                MinSize = new Vector2(15, 0),
                VerticalExpand = true,
            });

            var buttonsContainer = new BoxContainer
            {
                Orientation = BoxContainer.LayoutOrientation.Horizontal,
                SeparationOverride = 2,
                HorizontalExpand = true,
            };

            var buttons = new List<DropshipFireMissionOffsetButton>();

            foreach (var col in _offsetColumns)
            {
                var button = new DropshipFireMissionOffsetButton
                {
                    Offset = col,
                    TextAlign = Label.AlignMode.Center,
                };

                button.Text = col == null ? "-" : col.ToString();
                button.Label.ModulateSelfOverride = Color.FromHex("#00FF36");
                button.Label.Align = Label.AlignMode.Center;
                button.Label.VAlign = Label.VAlignMode.Center;

                button.SetOnPressed(_ => OnOffsetPressed(currentRow, col, button));

                buttonsContainer.AddChild(button);
                buttons.Add(button);
            }

            _buttonsByRow[row] = buttons;
            rowContainer.AddChild(buttonsContainer);
            FireMissionRows.AddChild(rowContainer);
        }
    }

    private void ApplyExistingOffsets()
    {
        _activeOffsetRows.Clear();
        _offsetCount = 0;

        if (_weapon == null || _weapon.AmmoConsumption == 0)
            return;

        foreach (var offset in _weapon.Offsets)
        {
            if (!_buttonsByRow.TryGetValue(offset.Step, out var buttons))
                continue;

            foreach (var btn in buttons)
            {
                if (Nullable.Equals(btn.Offset, offset.Offset))
                {
                    btn.MuteSounds = true;
                    btn.SetClickPressed(true);
                    btn.MuteSounds = false;
                }
            }

            if (offset.Offset == null)
                EnableRowsAround(offset.Step);
            else
            {
                DisableRowsAround(offset.Step);
                _offsetCount++;
            }
        }
    }

    private void OnOffsetPressed(int row, int? offset, DropshipFireMissionOffsetButton pressed)
    {
        if (_weapon == null || _weapon.AmmoConsumption == 0)
            return;

        foreach (var btn in _buttonsByRow[row])
        {
            btn.SetClickPressed(btn == pressed);
        }

        if (offset == null)
            EnableRowsAround(row);
        else
            DisableRowsAround(row);

        FireMissionOffsetSelected?.Invoke(_fireMission.Id, row, offset);
    }

    private void DisableRowsAround(int row)
    {
        if (_weapon == null)
            return;

        var delay = _weapon.FireDelay;

        // Disable rows after
        for (var i = 1; i <= delay; i++)
        {
            var target = row + i;
            if (_buttonsByRow.ContainsKey(target) && !IsRowBlocked(target))
                SetRowBusy(target, true);
        }

        // Disable rows before
        for (var i = 1; i <= delay; i++)
        {
            var target = row - i;
            if (_buttonsByRow.ContainsKey(target) && !IsRowBlocked(target))
                SetRowBusy(target, true);
        }

        _activeOffsetRows.Add(row);
    }

    private void EnableRowsAround(int row)
    {
        if (_weapon == null)
            return;

        _activeOffsetRows.Remove(row);

        var delay = _weapon.FireDelay;

        // Re-enable rows after
        for (var i = 1; i <= delay; i++)
        {
            var target = row + i;
            if (_buttonsByRow.ContainsKey(target) && !IsRowBlocked(target))
                SetRowBusy(target, false);
        }

        // Re-enable rows before
        for (var i = 1; i <= delay; i++)
        {
            var target = row - i;
            if (_buttonsByRow.ContainsKey(target) && !IsRowBlocked(target))
                SetRowBusy(target, false);
        }
    }

    private void SetRowBusy(int row, bool busy)
    {
        if (!_buttonsByRow.TryGetValue(row, out var buttons))
            return;

        var rowContainer = buttons[0].Parent as BoxContainer;
        if (rowContainer == null)
            return;

        // Show busy label and hide the buttons in the row.
        if (busy)
        {
            foreach (var btn in buttons)
            {
                btn.Visible = false;
                btn.Disabled = true;
            }

            var panel = new PanelContainer
            {
                PanelOverride = new StyleBoxFlat
                {
                    BackgroundColor = Color.Transparent,
                    BorderColor = Color.FromHex("#00FF36"),
                    BorderThickness = new Thickness(1),
                },

                Name = "BusyRow",
                HorizontalExpand = true,
                MinSize = new Vector2(0, 20),
                MaxSize =  new Vector2(float.PositiveInfinity, 24),
            };

            var busyLabel = new RichTextLabel
            {
                Name = "BusyLabel",
                Text = "Weapon busy",
                HorizontalAlignment = HAlignment.Center,
                VerticalAlignment = VAlignment.Center,
                HorizontalExpand = true,
                VerticalExpand = true,
                ModulateSelfOverride= Color.FromHex("#00FF36"),
            };

            panel.Children.Add(busyLabel);

            rowContainer.AddChild(panel);
        }
        // Remove busy label and make the buttons visible again.
        else
        {
            foreach (var child in rowContainer.Children.ToArray())
            {
                if (child.Name == "BusyRow")
                    rowContainer.RemoveChild(child);
            }

            foreach (var btn in buttons)
            {
                btn.Visible = true;
                btn.Disabled = false;
            }
        }
    }

    /// <summary>
    ///     Checks if the row is blocked by another row having an offset set.
    /// </summary>
    /// <param name="targetRow">The row to check</param>
    /// <returns>True if another row is preventing it from being enabled</returns>
    private bool IsRowBlocked(int targetRow)
    {
        if (_weapon == null)
            return false;

        foreach (var activeRow in _activeOffsetRows)
        {
            var distance = Math.Abs(activeRow - targetRow);
            if (distance <= _weapon.FireDelay && activeRow != targetRow)
                return true;
        }

        return false;
    }
}
