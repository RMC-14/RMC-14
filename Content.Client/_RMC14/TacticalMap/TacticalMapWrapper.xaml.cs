using System.Collections.Generic;
using System.Numerics;
using Content.Shared._RMC14.Areas;
using Content.Shared._RMC14.TacticalMap;
using Content.Shared._RMC14.Xenonids.Eye;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.Player;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.GameObjects;
using Robust.Shared.IoC;
using Robust.Shared.Localization;
using Robust.Shared.Map.Components;
using Robust.Shared.Maths;
using Robust.Shared.Prototypes;
using Robust.Shared.Timing;
using Robust.Shared.Input;
using Robust.Shared.Network;
using Robust.Shared.IoC.Exceptions;

namespace Content.Client._RMC14.TacticalMap;

public enum DrawingMode
{
    None,
    StraightLine,
    LabelEdit
}

[GenerateTypedNameReferences]
public sealed partial class TacticalMapWrapper : Control
{
    private static readonly Color DefaultButtonTextColor = TacticalMapInnerButton.DefaultTextColor;

    [Dependency] private readonly IPlayerManager _player = default!;
    [Dependency] private readonly IEntityManager _entityManager = default!;
    [Dependency] private readonly IPrototypeManager _prototypes = default!;

    public TimeSpan LastUpdateAt;
    public TimeSpan NextUpdateAt;

    public Action<Vector2i>? OnQueenEyeMove;
    public event Action<NetEntity>? MapSelected;
    public event Action<ProtoId<TacticalMapLayerPrototype>?>? LayerSelected;

    private const float FollowUpdateInterval = 0.5f;

    private readonly List<(string Name, Color Color)> _colors = new()
    {
        (Loc.GetString("ui-tactical-map-color-black"), Color.Black),
        (Loc.GetString("ui-tactical-map-color-red"), Color.FromHex("#F40002")),
        (Loc.GetString("ui-tactical-map-color-orange"), Color.FromHex("#F39504")),
        (Loc.GetString("ui-tactical-map-color-blue"), Color.FromHex("#015CF5")),
        (Loc.GetString("ui-tactical-map-color-purple"), Color.FromHex("#BF00F1")),
        (Loc.GetString("ui-tactical-map-color-green"), Color.FromHex("#00BB48")),
        (Loc.GetString("ui-tactical-map-color-brown"), Color.FromHex("#5A3121")),
    };

    private bool _followingPlayer;
    private Vector2i? _lastPlayerPosition;
    private float _followUpdateTimer;

    private EntityUid? _cachedPlayerEntity;
    private int? _cachedPlayerNetId;
    private TacticalMapUserComponent? _cachedUserComponent;

    private bool _settingsVisible = false;
    private DrawingMode _currentDrawingMode = DrawingMode.None;

    private TacticalMapControl.LabelMode _currentLabelState = TacticalMapControl.LabelMode.Area;
    private TacticalMapControl.LabelMode _lastActiveState = TacticalMapControl.LabelMode.Area;

    private TacticalMapSettingsManager? _settingsManager;
    private bool _settingsLoaded = false;
    private string? _currentMapId;
    private bool _mapIdSet = false;
    private bool _suppressMapSelection;
    private bool _suppressLayerSelection;

    private float _currentBlipSizeMultiplier = 1.0f;
    private float _currentLineThickness = 2.0f;
    private int _currentSelectedColorIndex = 0;
    private float _currentZoomFactor = 1.0f;
    private Vector2 _currentPanOffset = Vector2.Zero;

    public TacticalMapWrapper()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
        InvalidatePlayerCache();

        InitializeSettingsManager();
        SetupControls();
        SetupQueenEyeMode();
        SetupLabelEditMode();
    }

    protected override void FrameUpdate(FrameEventArgs args)
    {
        base.FrameUpdate(args);

        bool inQueenEyeMode = IsInQueenEyeMode();
        Map.QueenEyeMode = inQueenEyeMode;
        Canvas.QueenEyeMode = inQueenEyeMode;

        UpdatePlayerFollowing(args.DeltaSeconds);
        UpdateCooldownBar();
    }

    public TacticalMapSettings GetCurrentSettings()
    {
        return new TacticalMapSettings
        {
            ZoomFactor = _currentZoomFactor,
            PanOffset = _currentPanOffset,
            BlipSizeMultiplier = _currentBlipSizeMultiplier,
            LineThickness = _currentLineThickness,
            SelectedColorIndex = _currentSelectedColorIndex,
            SettingsVisible = _settingsVisible,
            LabelMode = _currentLabelState,
            WindowSize = Vector2.Zero,
            WindowPosition = Vector2.Zero
        };
    }

    public void SetMapId(string? mapId)
    {
        if (_currentMapId == mapId && _mapIdSet)
            return;

        _currentMapId = mapId;
        _mapIdSet = true;
        _settingsLoaded = false;

        Map.SetCurrentMap(null);
        Map.SetCurrentMapName(mapId);
        Canvas.SetCurrentMap(null);
        Canvas.SetCurrentMapName(mapId);

        LoadSettings();
    }

    public void LoadMapSpecificSettings(TacticalMapSettings settings, string? mapId)
    {
        SetMapId(mapId);
        Map.SetCurrentMapName(mapId);
        Canvas.SetCurrentMapName(mapId);
        ApplySettings(settings);
    }

    private void InitializeSettingsManager()
    {
        try
        {
            _settingsManager = IoCManager.Resolve<TacticalMapSettingsManager>();
        }
        catch (UnregisteredTypeException)
        {
            try
            {
                _settingsManager = new TacticalMapSettingsManager();
                IoCManager.RegisterInstance<TacticalMapSettingsManager>(_settingsManager);
                Logger.Warning("not registered in IoC, creating fallback instance");
            }
            catch (Exception ex)
            {
                Logger.Error($"failed to create fallback settings manager: {ex}");
                _settingsManager = null;
            }
        }
        catch (Exception ex)
        {
            Logger.Error($"failed to initialize settings manager: {ex}");
            _settingsManager = null;
        }
    }

    private void LoadSettings()
    {
        if (_settingsLoaded || _settingsManager == null)
            return;

        try
        {
            var settings = _settingsManager.LoadSettings(_currentMapId);
            ApplySettings(settings);
            _settingsLoaded = true;
        }
        catch (Exception ex)
        {
            Logger.Error($"TacticalMapWrapper: Failed to load settings: {ex}");
            _settingsLoaded = true;
        }
    }

    private void ApplySettings(TacticalMapSettings settings)
    {
        try
        {
            _currentBlipSizeMultiplier = settings.BlipSizeMultiplier;
            BlipSizeSlider.Value = settings.BlipSizeMultiplier;
            Map.BlipSizeMultiplier = settings.BlipSizeMultiplier;
            Canvas.BlipSizeMultiplier = settings.BlipSizeMultiplier;
            BlipSizeLabel.Text = Loc.GetString("ui-tactical-map-blip-size-label", ("size", settings.BlipSizeMultiplier.ToString("F1")));

            _currentLineThickness = settings.LineThickness;
            LineThicknessSlider.Value = settings.LineThickness;
            Map.LineThickness = settings.LineThickness;
            Canvas.LineThickness = settings.LineThickness;
            LineThicknessLabel.Text = Loc.GetString("ui-tactical-map-line-width-label", ("width", settings.LineThickness.ToString("F1")));

            if (settings.SelectedColorIndex >= 0 && settings.SelectedColorIndex < _colors.Count)
            {
                _currentSelectedColorIndex = settings.SelectedColorIndex;
                ColorsButton.SelectId(settings.SelectedColorIndex);
                Canvas.Color = _colors[settings.SelectedColorIndex].Color;
            }

            _settingsVisible = settings.SettingsVisible;
            UpdateSettingsVisibility();

            SetLabelState(settings.LabelMode, saveToConfig: false);

            _currentZoomFactor = settings.ZoomFactor;
            _currentPanOffset = settings.PanOffset;
            Map.LoadViewSettings(settings.ZoomFactor, settings.PanOffset, null);
            Canvas.LoadViewSettings(settings.ZoomFactor, settings.PanOffset, null);
        }
        catch (Exception ex)
        {
            Logger.Error($"failed to apply settings: {ex}");
        }
    }

    public void SetupUpdateButton(System.Action<TacticalMapUpdateCanvasMsg> sendMessage)
    {
        UpdateCanvasButton.Button.OnPressed += _ => {
            Dictionary<Vector2i, string> canvasLabels = new(Canvas.TacticalLabels);
            sendMessage(new TacticalMapUpdateCanvasMsg(Canvas.Lines, canvasLabels));
        };
    }

    public void UpdateTexture(Entity<AreaGridComponent> grid)
    {
        Map.UpdateTexture(grid);
        Canvas.UpdateTexture(grid);

        SetMapId(_currentMapId);

        Map.SetCurrentMapName(_currentMapId);
        Canvas.SetCurrentMapName(_currentMapId);

        Map.ApplyViewSettings();
        Canvas.ApplyViewSettings();
    }

    public void UpdateMapList(IReadOnlyList<TacticalMapMapInfo> maps, NetEntity activeMap)
    {
        _suppressMapSelection = true;
        MapSelectButton.Clear();

        var selectedId = -1;
        for (var i = 0; i < maps.Count; i++)
        {
            var map = maps[i];
            MapSelectButton.AddItem(map.DisplayName, i);
            MapSelectButton.SetItemMetadata(i, map.Map);
            if (map.Map == activeMap)
                selectedId = i;
        }

        MapSelectionRow.Visible = maps.Count > 0;
        MapSelectButton.Disabled = maps.Count <= 1;

        if (maps.Count > 0)
            MapSelectButton.SelectId(selectedId >= 0 ? selectedId : 0);

        _suppressMapSelection = false;
    }

    public void UpdateLayerList(IReadOnlyList<ProtoId<TacticalMapLayerPrototype>> layers, ProtoId<TacticalMapLayerPrototype>? activeLayer)
    {
        _suppressLayerSelection = true;
        LayerSelectButton.Clear();

        if (layers.Count <= 1)
        {
            LayerSelectionRow.Visible = false;
            _suppressLayerSelection = false;
            return;
        }

        LayerSelectionRow.Visible = true;

        var selectedId = 0;
        var id = 0;

        LayerSelectButton.AddItem(Loc.GetString("ui-tactical-map-layer-all"), id);
        id++;

        foreach (var layer in layers)
        {
            LayerSelectButton.AddItem(GetLayerName(layer), id);
            LayerSelectButton.SetItemMetadata(id, layer);
            if (activeLayer == layer)
                selectedId = id;
            id++;
        }

        LayerSelectButton.SelectId(selectedId);
        _suppressLayerSelection = false;
    }

    public void UpdateBlips(TacticalMapBlip[]? blips)
    {
        Map.UpdateBlips(blips);
        Canvas.UpdateBlips(blips);
        InvalidatePlayerCache();
    }

    public void UpdateBlips(TacticalMapBlip[]? blips, int[]? entityIds)
    {
        Map.UpdateBlips(blips, entityIds);
        Canvas.UpdateBlips(blips, entityIds);
        InvalidatePlayerCache();
    }

    public void UpdateTacticalLabels(Dictionary<Vector2i, string> labels)
    {
        Map.UpdateTacticalLabels(labels);
        Canvas.UpdateTacticalLabels(labels);
    }

    public void UpdateLabels(Dictionary<Vector2i, string> labels)
    {
        UpdateTacticalLabels(labels);
    }

    public void SetLineLimit(int limit)
    {
        Canvas.LineLimit = limit;
    }

    public void SetCanvasAccess(bool canDraw)
    {
        CanvasToolsContainer.Visible = canDraw;
        Canvas.Visible = canDraw;
        Map.Visible = !canDraw;
        Canvas.Drawing = canDraw;
        Map.Drawing = false;
    }

    public void OnUserInteraction()
    {
        if (_followingPlayer)
        {
            _followingPlayer = false;
            UpdateFollowButtonText();
            InvalidatePlayerCache();
        }
    }

    private void SetupControls()
    {
        ClearCanvasButton.Button.OnPressed += _ => {
            Canvas.Lines.Clear();
            Canvas.LineThicknesses.Clear();
        };
        UndoButton.Button.OnPressed += _ => OnUndoPressed();
        Canvas.Color = Color.Black;
        Canvas.Drawing = false;
        Canvas.IsCanvas = true;
        Map.IsCanvas = false;

        SetupMapSelector();
        SetupLayerSelector();
        SetupColorButton();
        SetupAreaLabels();
        SetupBlipSize();
        SetupSettingsToggle();
        SetupStraightLineMode();
        SetupLineThickness();

        FollowPlayerButton.Button.OnPressed += _ => ToggleFollowPlayer();
        ResetViewButton.Button.OnPressed += _ => ResetView();

        Map.OnUserInteraction += OnUserInteraction;
        Canvas.OnUserInteraction += OnUserInteraction;

        Map.SetViewUpdateCallback((zoom, pan) => {
            _currentZoomFactor = zoom;
            _currentPanOffset = pan;
        });

        Canvas.SetViewUpdateCallback((zoom, pan) => {
            _currentZoomFactor = zoom;
            _currentPanOffset = pan;
        });
    }

    private void SetupQueenEyeMode()
    {
        Map.OnQueenEyeMove += position => OnQueenEyeMove?.Invoke(position);
        Canvas.OnQueenEyeMove += position => OnQueenEyeMove?.Invoke(position);
    }

    private void SetupLabelEditMode()
    {
        Map.OnCreateLabel += (position, text) => {
            Map.TacticalLabels[position] = text;
        };

        Canvas.OnCreateLabel += (position, text) => {
            Canvas.TacticalLabels[position] = text;
            Map.TacticalLabels[position] = text;
        };

        Map.OnEditLabel += (position, text) => {
            Map.TacticalLabels[position] = text;
        };

        Canvas.OnEditLabel += (position, text) => {
            Canvas.TacticalLabels[position] = text;
            Map.TacticalLabels[position] = text;
        };

        Map.OnDeleteLabel += position => {
            Map.TacticalLabels.Remove(position);
        };

        Canvas.OnDeleteLabel += position => {
            Canvas.TacticalLabels.Remove(position);
            Map.TacticalLabels.Remove(position);
        };

        Map.OnMoveLabel += (oldPos, newPos) => {
            if (Map.TacticalLabels.TryGetValue(oldPos, out var text))
            {
                Map.TacticalLabels.Remove(oldPos);
                Map.TacticalLabels[newPos] = text;
            }
        };

        Canvas.OnMoveLabel += (oldPos, newPos) => {
            if (Canvas.TacticalLabels.TryGetValue(oldPos, out var text))
            {
                Canvas.TacticalLabels.Remove(oldPos);
                Canvas.TacticalLabels[newPos] = text;
                Map.TacticalLabels.Remove(oldPos);
                Map.TacticalLabels[newPos] = text;
            }
        };

        LabelEditButton.Button.OnPressed += _ => ToggleDrawingMode(DrawingMode.LabelEdit);
        UpdateDrawingModeAppearance();
    }

    private void SetupMapSelector()
    {
        MapSelectButton.OnItemSelected += args =>
        {
            if (_suppressMapSelection)
                return;

            if (MapSelectButton.GetItemMetadata(args.Id) is NetEntity map)
                MapSelected?.Invoke(map);
        };
    }

    private void SetupLayerSelector()
    {
        LayerSelectButton.OnItemSelected += args =>
        {
            if (_suppressLayerSelection)
                return;

            ProtoId<TacticalMapLayerPrototype>? selected = null;
            if (LayerSelectButton.GetItemMetadata(args.Id) is ProtoId<TacticalMapLayerPrototype> layer)
                selected = layer;

            LayerSelected?.Invoke(selected);
        };
    }

    private string GetLayerName(ProtoId<TacticalMapLayerPrototype> layer)
    {
        if (_prototypes.TryIndex(layer, out var prototype))
            return Loc.GetString(prototype.Name);

        return layer.Id;
    }

    private void SetupColorButton()
    {
        for (int i = 0; i < _colors.Count; i++)
        {
            (string name, Color color) = _colors[i];
            ColorsButton.AddItem(name, i);
            ColorsButton.SetItemMetadata(i, color);
        }

        ColorsButton.OnItemSelected += args =>
        {
            if (args.Button.GetItemMetadata(args.Id) is Color color)
            {
                Canvas.Color = color;
                ColorsButton.SelectId(args.Id);
                _currentSelectedColorIndex = args.Id;
            }
        };

        ColorsButton.SelectId(0);
    }

    private void SetupAreaLabels()
    {
        LabelsButton.Button.OnPressed += _ => ToggleCurrentLabels();

        LabelsButton.Button.OnKeyBindDown += args =>
        {
            if (args.Function == EngineKeyFunctions.UIRightClick)
            {
                CycleLabelTypes();
                args.Handle();
            }
        };

        SetLabelState(TacticalMapControl.LabelMode.Area);
    }

    private void SetupBlipSize()
    {
        float initialBlipSize = 1.0f;
        BlipSizeSlider.Value = initialBlipSize;
        BlipSizeLabel.Text = Loc.GetString("ui-tactical-map-blip-size-label", ("size", initialBlipSize.ToString("F1")));

        Map.BlipSizeMultiplier = initialBlipSize;
        Canvas.BlipSizeMultiplier = initialBlipSize;

        BlipSizeSlider.OnValueChanged += args =>
        {
            float value = (float)args.Value;
            BlipSizeLabel.Text = Loc.GetString("ui-tactical-map-blip-size-label", ("size", value.ToString("F1")));
            Map.BlipSizeMultiplier = value;
            Canvas.BlipSizeMultiplier = value;
            _currentBlipSizeMultiplier = value;
        };
    }

    private void SetupLineThickness()
    {
        float initialThickness = 2.0f;
        LineThicknessSlider.Value = initialThickness;
        LineThicknessLabel.Text = Loc.GetString("ui-tactical-map-line-width-label", ("width", initialThickness.ToString("F1")));

        Map.LineThickness = initialThickness;
        Canvas.LineThickness = initialThickness;

        LineThicknessSlider.OnValueChanged += args =>
        {
            float value = (float)args.Value;
            LineThicknessLabel.Text = Loc.GetString("ui-tactical-map-line-width-label", ("width", value.ToString("F1")));
            Map.LineThickness = value;
            Canvas.LineThickness = value;
            _currentLineThickness = value;
        };
    }

    private void SetupSettingsToggle()
    {
        SettingsToggleButton.Button.OnPressed += _ => ToggleSettingsVisibility();
        UpdateSettingsVisibility();
    }

    private void SetupStraightLineMode()
    {
        StraightLineButton.Button.OnPressed += _ => ToggleDrawingMode(DrawingMode.StraightLine);
        UpdateDrawingModeAppearance();
    }

    private void ToggleDrawingMode(DrawingMode mode)
    {
        _currentDrawingMode = (_currentDrawingMode == mode) ? DrawingMode.None : mode;

        if (_currentDrawingMode == DrawingMode.LabelEdit)
        {
            SetLabelState(TacticalMapControl.LabelMode.Tactical);
        }

        ApplyDrawingMode();
        UpdateDrawingModeAppearance();
    }

    private void ApplyDrawingMode()
    {
        Canvas.StraightLineMode = false;
        Canvas.LabelEditMode = false;
        Map.LabelEditMode = false;

        switch (_currentDrawingMode)
        {
            case DrawingMode.StraightLine:
                Canvas.StraightLineMode = true;
                break;
            case DrawingMode.LabelEdit:
                Canvas.LabelEditMode = true;
                Map.LabelEditMode = true;
                break;
            case DrawingMode.None:
                break;
        }
    }

    private void UpdateDrawingModeAppearance()
    {
        UpdateStraightLineButtonAppearance();
        UpdateLabelEditButtonAppearance();
    }

    private void UpdateStraightLineButtonAppearance()
    {
        if (StraightLineButton != null)
        {
            var color = _currentDrawingMode == DrawingMode.StraightLine ? Color.Green : DefaultButtonTextColor;
            SetButtonTextColor(StraightLineButton, color);
        }
    }

    private void UpdateLabelEditButtonAppearance()
    {
        if (LabelEditButton != null)
        {
            var color = _currentDrawingMode == DrawingMode.LabelEdit ? Color.Green : DefaultButtonTextColor;
            SetButtonTextColor(LabelEditButton, color);
        }
    }

    private void OnUndoPressed()
    {
        if (Canvas.Lines.Count > 0)
        {
            Canvas.Lines.RemoveAt(Canvas.Lines.Count - 1);
            if (Canvas.LineThicknesses.Count > 0)
                Canvas.LineThicknesses.RemoveAt(Canvas.LineThicknesses.Count - 1);
        }
    }

    private void ToggleCurrentLabels()
    {
        if (_currentLabelState == TacticalMapControl.LabelMode.None)
        {
            SetLabelState(_lastActiveState);
        }
        else
        {
            SetLabelState(TacticalMapControl.LabelMode.None);
        }
    }

    private void CycleLabelTypes()
    {
        switch (_currentLabelState)
        {
            case TacticalMapControl.LabelMode.None:
                SetLabelState(TacticalMapControl.LabelMode.Tactical);
                break;
            case TacticalMapControl.LabelMode.Tactical:
                SetLabelState(TacticalMapControl.LabelMode.Area);
                break;
            case TacticalMapControl.LabelMode.Area:
                SetLabelState(TacticalMapControl.LabelMode.Tactical);
                break;
        }
    }

    private void ToggleSettingsVisibility()
    {
        _settingsVisible = !_settingsVisible;
        UpdateSettingsVisibility();
    }

    private void ToggleFollowPlayer()
    {
        _followingPlayer = !_followingPlayer;
        UpdateFollowButtonText();

        if (_followingPlayer)
            CenterOnPlayer();
    }

    private void ResetView()
    {
        Map.ResetZoomAndPan();
        Canvas.ResetZoomAndPan();
        _currentZoomFactor = 1.0f;
        _currentPanOffset = Vector2.Zero;

        if (_followingPlayer)
        {
            _followingPlayer = false;
            UpdateFollowButtonText();
            InvalidatePlayerCache();
        }
    }

    private void CenterOnPlayer()
    {
        if (TryFindPlayerBlip(out Vector2i playerIndices))
        {
            Map.CenterOnPosition(playerIndices);

            if (Canvas.Visible)
                Canvas.CenterOnPosition(playerIndices);

            _lastPlayerPosition = playerIndices;
        }
    }

    private void SetLabelState(TacticalMapControl.LabelMode newState, bool saveToConfig = false)
    {
        _currentLabelState = newState;

        if (newState != TacticalMapControl.LabelMode.None)
        {
            _lastActiveState = newState;
        }

        Map.CurrentLabelMode = newState;
        Canvas.CurrentLabelMode = newState;

        UpdateLabelsButtonAppearance();
    }

    private void UpdateLabelsButtonAppearance()
    {
        Color color;
        string text;

        switch (_currentLabelState)
        {
            case TacticalMapControl.LabelMode.Area:
                text = Loc.GetString("ui-tactical-map-labels-mode-area");
                color = Color.Orange;
                break;
            case TacticalMapControl.LabelMode.Tactical:
                text = Loc.GetString("ui-tactical-map-labels-mode-tactical");
                color = Color.Green;
                break;
            case TacticalMapControl.LabelMode.None:
                text = Loc.GetString("ui-tactical-map-labels-mode-none");
                color = Color.Red;
                break;
            default:
                text = Loc.GetString("ui-tactical-map-labels-mode-none");
                color = DefaultButtonTextColor;
                break;
        }

        if (LabelsButton != null)
            SetButtonText(LabelsButton, text, color);

    }

    private void UpdateSettingsVisibility()
    {
        SettingsContainer.Visible = _settingsVisible;
        var text = _settingsVisible ?
            Loc.GetString("ui-tactical-map-settings-toggle-expanded") :
            Loc.GetString("ui-tactical-map-settings-toggle-collapsed");
        SetButtonText(SettingsToggleButton, text, DefaultButtonTextColor);
    }

    private void UpdateFollowButtonText()
    {
        string text = _followingPlayer ?
            Loc.GetString("ui-tactical-map-follow-player-active") :
            Loc.GetString("ui-tactical-map-follow-player-inactive");
        Color color = _followingPlayer ? Color.Red : DefaultButtonTextColor;

        if (FollowPlayerButton != null)
            SetButtonText(FollowPlayerButton, text, color);

    }

    private static void SetButtonTextColor(TacticalMapButton button, Color color)
    {
        button.Button.TextColor = color;
        if (button.Text != null)
            button.Text = button.Text;
    }

    private static void SetButtonText(TacticalMapButton button, string text, Color color)
    {
        button.Button.TextColor = color;
        button.Text = text;
    }

    private void UpdatePlayerFollowing(float deltaSeconds)
    {
        if (!_followingPlayer)
            return;

        _followUpdateTimer += deltaSeconds;

        if (_followUpdateTimer < FollowUpdateInterval)
            return;

        _followUpdateTimer = 0f;

        if (TryFindPlayerBlip(out Vector2i currentPlayerPosition) &&
            _lastPlayerPosition != currentPlayerPosition)
        {
            Map.CenterOnPosition(currentPlayerPosition);

            if (Canvas.Visible)
                Canvas.CenterOnPosition(currentPlayerPosition);

            _lastPlayerPosition = currentPlayerPosition;
        }
    }

    private void UpdateCooldownBar()
    {
        IGameTiming time = IoCManager.Resolve<IGameTiming>();
        TimeSpan cooldown = NextUpdateAt - time.CurTime;

        if (cooldown < TimeSpan.Zero)
        {
            UpdateCanvasButton.Disabled = false;
            CooldownBar.Visible = false;
            return;
        }

        UpdateCanvasButton.Disabled = true;
        CooldownBar.Visible = true;
        CooldownBar.MinValue = (float)LastUpdateAt.TotalSeconds;
        CooldownBar.MaxValue = (float)NextUpdateAt.TotalSeconds;
        CooldownBar.Value = (float)(LastUpdateAt.TotalSeconds + NextUpdateAt.TotalSeconds - time.CurTime.TotalSeconds);
        CooldownLabel.Text = Loc.GetString("ui-tactical-map-cooldown-seconds", ("seconds", (int)cooldown.TotalSeconds));
    }

    private bool IsInQueenEyeMode()
    {
        IEntityManager entMan = IoCManager.Resolve<IEntityManager>();
        EntityUid? player = _player.LocalEntity;

        if (player == null)
            return false;

        if (!entMan.TryGetComponent<QueenEyeActionComponent>(player.Value, out QueenEyeActionComponent? queenEyeComp))
            return false;

        return queenEyeComp.Eye != null;
    }

    private void InvalidatePlayerCache()
    {
        _cachedPlayerEntity = null;
        _cachedPlayerNetId = null;
        _cachedUserComponent = null;
    }

    private bool TryGetCachedPlayerData(out int playerNetId, out TacticalMapUserComponent userComponent)
    {
        playerNetId = default;
        userComponent = default!;

        EntityUid? currentPlayer = _player.LocalEntity;
        if (currentPlayer == null)
        {
            InvalidatePlayerCache();
            return false;
        }

        if (_cachedPlayerEntity != currentPlayer)
        {
            IEntityManager entMan = IoCManager.Resolve<IEntityManager>();
            if (!entMan.TryGetComponent<TacticalMapUserComponent>(currentPlayer.Value, out TacticalMapUserComponent? newUserComp))
            {
                InvalidatePlayerCache();
                return false;
            }

            _cachedPlayerEntity = currentPlayer;
            _cachedPlayerNetId = (int)entMan.GetNetEntity(currentPlayer.Value);
            _cachedUserComponent = newUserComp;
        }

        if (_cachedPlayerNetId == null || _cachedUserComponent == null)
            return false;

        playerNetId = _cachedPlayerNetId.Value;
        userComponent = _cachedUserComponent;
        return true;
    }

    private bool TryFindPlayerBlip(out Vector2i playerIndices)
    {
        playerIndices = default;

        if (!TryGetCachedPlayerData(out int playerNetId, out TacticalMapUserComponent userComp))
            return false;

        foreach ((int id, TacticalMapBlip blip) in userComp.Blips)
        {
            if (id == playerNetId)
            {
                playerIndices = blip.Indices;
                return true;
            }
        }

        return false;
    }
}
