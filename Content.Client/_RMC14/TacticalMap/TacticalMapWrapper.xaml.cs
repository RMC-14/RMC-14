using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using Content.Shared._RMC14.Areas;
using Content.Shared._RMC14.CCVar;
using Content.Shared._RMC14.TacticalMap;
using Content.Shared._RMC14.Xenonids.Eye;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.Player;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Configuration;
using Robust.Shared.GameObjects;
using Robust.Shared.IoC;
using Robust.Shared.Localization;
using Robust.Shared.Map.Components;
using Robust.Shared.Maths;
using Robust.Shared.Timing;
using Robust.Shared.Input;

namespace Content.Client._RMC14.TacticalMap;

public enum DrawingMode
{
    None,
    StraightLine,
    LabelEdit
}

[GenerateTypedNameReferences]
public sealed partial class TacticalMapWrapper : Control
{
    [Dependency] private readonly IConfigurationManager _config = default!;
    [Dependency] private readonly IPlayerManager _player = default!;

    public TimeSpan LastUpdateAt;
    public TimeSpan NextUpdateAt;

    public Action<Vector2i>? OnQueenEyeMove;

    private const float FollowUpdateInterval = 0.5f;

    private readonly List<(string Name, Color Color)> _colors = new()
    {
        (Loc.GetString("ui-tactical-map-color-black"), Color.Black),
        (Loc.GetString("ui-tactical-map-color-red"), Color.FromHex("#F40002")),
        (Loc.GetString("ui-tactical-map-color-orange"), Color.FromHex("#F39504")),
        (Loc.GetString("ui-tactical-map-color-blue"), Color.FromHex("#015CF5")),
        (Loc.GetString("ui-tactical-map-color-purple"), Color.FromHex("#BF00F1")),
        (Loc.GetString("ui-tactical-map-color-green"), Color.FromHex("#00BB48")),
        (Loc.GetString("ui-tactical-map-color-brown"), Color.FromHex("#5A3121")),
    };

    private bool _followingPlayer;
    private Vector2i? _lastPlayerPosition;
    private float _followUpdateTimer;

    private EntityUid? _cachedPlayerEntity;
    private int? _cachedPlayerNetId;
    private TacticalMapUserComponent? _cachedUserComponent;

    private bool _settingsVisible = false;
    private DrawingMode _currentDrawingMode = DrawingMode.None;

    private TacticalMapControl.LabelMode _currentLabelState = TacticalMapControl.LabelMode.Tactical;
    private TacticalMapControl.LabelMode _lastActiveState = TacticalMapControl.LabelMode.Tactical;

    public TacticalMapWrapper()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
        InvalidatePlayerCache();
        SetupControls();
        SetupQueenEyeMode();
        SetupLabelEditMode();
    }

    protected override void FrameUpdate(FrameEventArgs args)
    {
        base.FrameUpdate(args);

        bool inQueenEyeMode = IsInQueenEyeMode();
        Map.QueenEyeMode = inQueenEyeMode;
        Canvas.QueenEyeMode = inQueenEyeMode;

        UpdatePlayerFollowing(args.DeltaSeconds);
        UpdateCooldownBar();
    }

    public void SetupUpdateButton(System.Action<TacticalMapUpdateCanvasMsg> sendMessage)
    {
        UpdateCanvasButton.OnPressed += _ => {
            Dictionary<Vector2i, string> canvasLabels = new(Canvas.TacticalLabels);
            sendMessage(new TacticalMapUpdateCanvasMsg(Canvas.Lines, canvasLabels));
        };
    }

    public void UpdateTexture(Entity<AreaGridComponent> grid)
    {
        Map.UpdateTexture(grid);
        Canvas.UpdateTexture(grid);
    }

    public void UpdateBlips(TacticalMapBlip[]? blips)
    {
        Map.UpdateBlips(blips);
        Canvas.UpdateBlips(blips);
        InvalidatePlayerCache();
    }

    public void UpdateTacticalLabels(Dictionary<Vector2i, string> labels)
    {
        Map.UpdateTacticalLabels(labels);
        Canvas.UpdateTacticalLabels(labels);
    }

    public void UpdateLabels(Dictionary<Vector2i, string> labels)
    {
        UpdateTacticalLabels(labels);
    }

    public void SetLineLimit(int limit)
    {
        Canvas.LineLimit = limit;
    }

    public void OnUserInteraction()
    {
        if (_followingPlayer)
        {
            _followingPlayer = false;
            UpdateFollowButtonText();
            InvalidatePlayerCache();
        }
    }

    private void SetupControls()
    {
        ClearCanvasButton.OnPressed += _ => {
            Canvas.Lines.Clear();
            Canvas.LineThicknesses.Clear();
        };
        UndoButton.OnPressed += _ => OnUndoPressed();
        Canvas.Color = Color.Black;

        SetupColorButton();
        SetupAreaLabels();
        SetupBlipSize();
        SetupSettingsToggle();
        SetupStraightLineMode();
        SetupLineThickness();

        FollowPlayerButton.OnPressed += _ => ToggleFollowPlayer();
        ResetViewButton.OnPressed += _ => ResetView();
        FollowPlayerButtonCanvas.OnPressed += _ => ToggleFollowPlayer();
        ResetViewButtonCanvas.OnPressed += _ => ResetView();

        Map.OnUserInteraction += OnUserInteraction;
        Canvas.OnUserInteraction += OnUserInteraction;
    }

    private void SetupQueenEyeMode()
    {
        Map.OnQueenEyeMove += position => OnQueenEyeMove?.Invoke(position);
        Canvas.OnQueenEyeMove += position => OnQueenEyeMove?.Invoke(position);
    }

    private void SetupLabelEditMode()
    {
        Map.OnCreateLabel += (position, text) => {
            Map.TacticalLabels[position] = text;
        };

        Canvas.OnCreateLabel += (position, text) => {
            Canvas.TacticalLabels[position] = text;
            Map.TacticalLabels[position] = text;
        };

        Map.OnEditLabel += (position, text) => {
            Map.TacticalLabels[position] = text;
        };

        Canvas.OnEditLabel += (position, text) => {
            Canvas.TacticalLabels[position] = text;
            Map.TacticalLabels[position] = text;
        };

        Map.OnDeleteLabel += position => {
            Map.TacticalLabels.Remove(position);
        };

        Canvas.OnDeleteLabel += position => {
            Canvas.TacticalLabels.Remove(position);
            Map.TacticalLabels.Remove(position);
        };

        Map.OnMoveLabel += (oldPos, newPos) => {
            if (Map.TacticalLabels.TryGetValue(oldPos, out var text))
            {
                Map.TacticalLabels.Remove(oldPos);
                Map.TacticalLabels[newPos] = text;
            }
        };

        Canvas.OnMoveLabel += (oldPos, newPos) => {
            if (Canvas.TacticalLabels.TryGetValue(oldPos, out var text))
            {
                Canvas.TacticalLabels.Remove(oldPos);
                Canvas.TacticalLabels[newPos] = text;
                Map.TacticalLabels.Remove(oldPos);
                Map.TacticalLabels[newPos] = text;
            }
        };

        LabelEditButton.OnPressed += _ => ToggleDrawingMode(DrawingMode.LabelEdit);
        UpdateDrawingModeAppearance();
    }

    private void SetupColorButton()
    {
        for (int i = 0; i < _colors.Count; i++)
        {
            (string name, Color color) = _colors[i];
            ColorsButton.AddItem(name, i);
            ColorsButton.SetItemMetadata(i, color);
        }

        ColorsButton.OnItemSelected += args =>
        {
            if (args.Button.GetItemMetadata(args.Id) is Color color)
            {
                Canvas.Color = color;
                ColorsButton.SelectId(args.Id);
            }
        };

        ColorsButton.SelectId(0);
    }

    private void SetupAreaLabels()
    {
        LabelsButton.OnPressed += _ => ToggleCurrentLabels();
        LabelsButtonCanvas.OnPressed += _ => ToggleCurrentLabels();

        LabelsButton.OnKeyBindDown += args =>
        {
            if (args.Function == EngineKeyFunctions.UIRightClick)
            {
                CycleLabelTypes();
                args.Handle();
            }
        };

        LabelsButtonCanvas.OnKeyBindDown += args =>
        {
            if (args.Function == EngineKeyFunctions.UIRightClick)
            {
                CycleLabelTypes();
                args.Handle();
            }
        };

        SetLabelState(TacticalMapControl.LabelMode.Tactical);
    }

    private void SetupBlipSize()
    {
        float initialBlipSize = 1.0f;
        BlipSizeSlider.Value = initialBlipSize;
        BlipSizeLabel.Text = Loc.GetString("ui-tactical-map-blip-size-label", ("size", initialBlipSize.ToString("F1")));

        Map.BlipSizeMultiplier = initialBlipSize;
        Canvas.BlipSizeMultiplier = initialBlipSize;

        BlipSizeSlider.OnValueChanged += args =>
        {
            float value = (float)args.Value;
            BlipSizeLabel.Text = Loc.GetString("ui-tactical-map-blip-size-label", ("size", value.ToString("F1")));
            Map.BlipSizeMultiplier = value;
            Canvas.BlipSizeMultiplier = value;
        };
    }

    private void SetupLineThickness()
    {
        float initialThickness = 2.0f;
        LineThicknessSlider.Value = initialThickness;
        LineThicknessLabel.Text = Loc.GetString("ui-tactical-map-line-width-label", ("width", initialThickness.ToString("F1")));

        Map.LineThickness = initialThickness;
        Canvas.LineThickness = initialThickness;

        LineThicknessSlider.OnValueChanged += args =>
        {
            float value = (float)args.Value;
            LineThicknessLabel.Text = Loc.GetString("ui-tactical-map-line-width-label", ("width", value.ToString("F1")));
            Map.LineThickness = value;
            Canvas.LineThickness = value;
        };
    }

    private void SetupSettingsToggle()
    {
        SettingsToggleButton.OnPressed += _ => ToggleSettingsVisibility();
        UpdateSettingsVisibility();
    }

    private void SetupStraightLineMode()
    {
        StraightLineButton.OnPressed += _ => ToggleDrawingMode(DrawingMode.StraightLine);
        UpdateDrawingModeAppearance();
    }

    private void ToggleDrawingMode(DrawingMode mode)
    {
        _currentDrawingMode = (_currentDrawingMode == mode) ? DrawingMode.None : mode;

        if (_currentDrawingMode == DrawingMode.LabelEdit)
        {
            SetLabelState(TacticalMapControl.LabelMode.Tactical);
        }

        ApplyDrawingMode();
        UpdateDrawingModeAppearance();
    }

    private void ApplyDrawingMode()
    {
        Canvas.StraightLineMode = false;
        Canvas.LabelEditMode = false;
        Map.LabelEditMode = false;

        switch (_currentDrawingMode)
        {
            case DrawingMode.StraightLine:
                Canvas.StraightLineMode = true;
                break;
            case DrawingMode.LabelEdit:
                Canvas.LabelEditMode = true;
                Map.LabelEditMode = true;
                break;
            case DrawingMode.None:
                break;
        }
    }

    private void UpdateDrawingModeAppearance()
    {
        UpdateStraightLineButtonAppearance();
        UpdateLabelEditButtonAppearance();
    }

    private void UpdateStraightLineButtonAppearance()
    {
        if (StraightLineButton != null)
        {
            StraightLineButton.Modulate = (_currentDrawingMode == DrawingMode.StraightLine) ? Color.Green : Color.White;
        }
    }

    private void UpdateLabelEditButtonAppearance()
    {
        if (LabelEditButton != null)
        {
            LabelEditButton.Modulate = (_currentDrawingMode == DrawingMode.LabelEdit) ? Color.Green : Color.White;
        }
    }

    private void OnUndoPressed()
    {
        if (Canvas.Lines.Count > 0)
        {
            Canvas.Lines.RemoveAt(Canvas.Lines.Count - 1);
            if (Canvas.LineThicknesses.Count > 0)
                Canvas.LineThicknesses.RemoveAt(Canvas.LineThicknesses.Count - 1);
        }
    }

    private void ToggleCurrentLabels()
    {
        if (_currentLabelState == TacticalMapControl.LabelMode.None)
        {
            SetLabelState(TacticalMapControl.LabelMode.Tactical);
        }
        else
        {
            SetLabelState(TacticalMapControl.LabelMode.None);
        }
    }

    private void CycleLabelTypes()
    {
        switch (_currentLabelState)
        {
            case TacticalMapControl.LabelMode.None:
                SetLabelState(TacticalMapControl.LabelMode.Tactical);
                break;
            case TacticalMapControl.LabelMode.Tactical:
                SetLabelState(TacticalMapControl.LabelMode.Area);
                break;
            case TacticalMapControl.LabelMode.Area:
                SetLabelState(TacticalMapControl.LabelMode.Tactical);
                break;
        }
    }

    private void ToggleSettingsVisibility()
    {
        _settingsVisible = !_settingsVisible;
        UpdateSettingsVisibility();
    }

    private void ToggleFollowPlayer()
    {
        _followingPlayer = !_followingPlayer;
        UpdateFollowButtonText();

        if (_followingPlayer)
            CenterOnPlayer();
    }

    private void ResetView()
    {
        Map.ResetZoomAndPan();
        Canvas.ResetZoomAndPan();

        if (_followingPlayer)
        {
            _followingPlayer = false;
            UpdateFollowButtonText();
            InvalidatePlayerCache();
        }
    }

    private void CenterOnPlayer()
    {
        if (TryFindPlayerBlip(out Vector2i playerIndices))
        {
            Map.CenterOnPosition(playerIndices);

            if (Canvas.Visible)
                Canvas.CenterOnPosition(playerIndices);

            _lastPlayerPosition = playerIndices;
        }
    }

    private void SetLabelState(TacticalMapControl.LabelMode newState)
    {
        _currentLabelState = newState;

        if (newState != TacticalMapControl.LabelMode.None)
        {
            _lastActiveState = newState;
        }

        Map.CurrentLabelMode = newState;
        Canvas.CurrentLabelMode = newState;

        UpdateLabelsButtonAppearance();
    }

    private void UpdateLabelsButtonAppearance()
    {
        Color color;
        string text;

        switch (_currentLabelState)
        {
            case TacticalMapControl.LabelMode.Area:
                text = Loc.GetString("ui-tactical-map-labels-mode-area");
                color = Color.Orange;
                break;
            case TacticalMapControl.LabelMode.Tactical:
                text = Loc.GetString("ui-tactical-map-labels-mode-tactical");
                color = Color.Green;
                break;
            case TacticalMapControl.LabelMode.None:
                text = Loc.GetString("ui-tactical-map-labels-mode-none");
                color = Color.Red;
                break;
            default:
                text = Loc.GetString("ui-tactical-map-labels-mode-none");
                color = Color.White;
                break;
        }

        if (LabelsButton != null)
        {
            LabelsButton.Text = text;
            LabelsButton.Modulate = color;
        }

        if (LabelsButtonCanvas != null)
        {
            LabelsButtonCanvas.Text = text;
            LabelsButtonCanvas.Modulate = color;
        }
    }

    private void UpdateSettingsVisibility()
    {
        SettingsContainer.Visible = _settingsVisible;
        SettingsToggleButton.Text = _settingsVisible ?
            Loc.GetString("ui-tactical-map-settings-toggle-expanded") :
            Loc.GetString("ui-tactical-map-settings-toggle-collapsed");
    }

    private void UpdateFollowButtonText()
    {
        string text = _followingPlayer ?
            Loc.GetString("ui-tactical-map-follow-player-active") :
            Loc.GetString("ui-tactical-map-follow-player-inactive");
        Color color = _followingPlayer ? Color.Red : Color.White;

        if (FollowPlayerButton != null)
        {
            FollowPlayerButton.Text = text;
            FollowPlayerButton.Modulate = color;
        }

        if (FollowPlayerButtonCanvas != null)
        {
            FollowPlayerButtonCanvas.Text = text;
            FollowPlayerButtonCanvas.Modulate = color;
        }
    }

    private void UpdatePlayerFollowing(float deltaSeconds)
    {
        if (!_followingPlayer)
            return;

        _followUpdateTimer += deltaSeconds;

        if (_followUpdateTimer < FollowUpdateInterval)
            return;

        _followUpdateTimer = 0f;

        if (TryFindPlayerBlip(out Vector2i currentPlayerPosition) &&
            _lastPlayerPosition != currentPlayerPosition)
        {
            Map.CenterOnPosition(currentPlayerPosition);

            if (Canvas.Visible)
                Canvas.CenterOnPosition(currentPlayerPosition);

            _lastPlayerPosition = currentPlayerPosition;
        }
    }

    private void UpdateCooldownBar()
    {
        IGameTiming time = IoCManager.Resolve<IGameTiming>();
        TimeSpan cooldown = NextUpdateAt - time.CurTime;

        if (cooldown < TimeSpan.Zero)
        {
            UpdateCanvasButton.Disabled = false;
            CooldownBar.Visible = false;
            return;
        }

        UpdateCanvasButton.Disabled = true;
        CooldownBar.Visible = true;
        CooldownBar.MinValue = (float)LastUpdateAt.TotalSeconds;
        CooldownBar.MaxValue = (float)NextUpdateAt.TotalSeconds;
        CooldownBar.Value = (float)(LastUpdateAt.TotalSeconds + NextUpdateAt.TotalSeconds - time.CurTime.TotalSeconds);
        CooldownLabel.Text = Loc.GetString("ui-tactical-map-cooldown-seconds", ("seconds", (int)cooldown.TotalSeconds));
    }

    private bool IsInQueenEyeMode()
    {
        IEntityManager entMan = IoCManager.Resolve<IEntityManager>();
        EntityUid? player = _player.LocalEntity;

        if (player == null)
            return false;

        if (!entMan.TryGetComponent<QueenEyeActionComponent>(player.Value, out QueenEyeActionComponent? queenEyeComp))
            return false;

        return queenEyeComp.Eye != null;
    }

    private void InvalidatePlayerCache()
    {
        _cachedPlayerEntity = null;
        _cachedPlayerNetId = null;
        _cachedUserComponent = null;
    }

    private bool TryGetCachedPlayerData(out int playerNetId, out TacticalMapUserComponent userComponent)
    {
        playerNetId = default;
        userComponent = default!;

        EntityUid? currentPlayer = _player.LocalEntity;
        if (currentPlayer == null)
        {
            InvalidatePlayerCache();
            return false;
        }

        if (_cachedPlayerEntity != currentPlayer)
        {
            IEntityManager entMan = IoCManager.Resolve<IEntityManager>();
            if (!entMan.TryGetComponent<TacticalMapUserComponent>(currentPlayer.Value, out TacticalMapUserComponent? newUserComp))
            {
                InvalidatePlayerCache();
                return false;
            }

            _cachedPlayerEntity = currentPlayer;
            _cachedPlayerNetId = (int)entMan.GetNetEntity(currentPlayer.Value);
            _cachedUserComponent = newUserComp;
        }

        if (_cachedPlayerNetId == null || _cachedUserComponent == null)
            return false;

        playerNetId = _cachedPlayerNetId.Value;
        userComponent = _cachedUserComponent;
        return true;
    }

    private bool TryFindPlayerBlip(out Vector2i playerIndices)
    {
        playerIndices = default;

        if (!TryGetCachedPlayerData(out int playerNetId, out TacticalMapUserComponent userComp))
            return false;

        foreach ((int id, TacticalMapBlip blip) in userComp.XenoBlips)
        {
            if (id == playerNetId)
            {
                playerIndices = blip.Indices;
                return true;
            }
        }

        foreach ((int id, TacticalMapBlip blip) in userComp.MarineBlips)
        {
            if (id == playerNetId)
            {
                playerIndices = blip.Indices;
                return true;
            }
        }

        return false;
    }
}
