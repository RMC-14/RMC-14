using Content.Client._RMC14.UserInterface;
using Content.Shared._RMC14.Areas;
using Content.Shared._RMC14.CCVar;
using Content.Shared._RMC14.TacticalMap;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Configuration;
using Robust.Shared.Timing;

namespace Content.Client._RMC14.TacticalMap;

[GenerateTypedNameReferences]
public sealed partial class TacticalMapWindow : RMCPopOutWindow
{
    [Dependency] private readonly IConfigurationManager _config = default!;

    protected override Control Control => Wrapper;

    private readonly List<(string Name, Color Color)> _colors = new()
    {
        ("Black", Color.Black),
        ("Red", Color.FromHex("#F40002")),
        ("Orange", Color.FromHex("#F39504")),
        ("Blue", Color.FromHex("#015CF5")),
        ("Purple", Color.FromHex("#BF00F1")),
        ("Green", Color.FromHex("#00BB48")),
        ("Brown", Color.FromHex("#5A3121")),
    };

    public TimeSpan LastUpdateAt;
    public TimeSpan NextUpdateAt;

    public TacticalMapWindow()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
        ClearCanvasButton.OnPressed += _ => Canvas.Lines.Clear();
        UndoButton.OnPressed += _ =>
        {
            if (Canvas.Lines.Count == 0)
                return;

            Canvas.Lines.RemoveAt(Canvas.Lines.Count - 1);
        };
        Canvas.Color = Color.Black;

        for (var i = 0; i < _colors.Count; i++)
        {
            var (name, color) = _colors[i];
            ColorsButton.AddItem(name, i);
            ColorsButton.SetItemMetadata(i, color);
        }

        ColorsButton.OnItemSelected += args =>
        {
            if (args.Button.GetItemMetadata(args.Id) is not { } metaData)
                return;

            Canvas.Color = (Color) metaData;
            ColorsButton.SelectId(args.Id);
        };

        CooldownBar.ForegroundStyleBoxOverride = new StyleBoxFlat(Color.Red);
        AreaLabelsCheckbox.OnPressed += args =>
        {
            Map.DrawAreaLabels = args.Button.Pressed;
            _config.SetCVar(RMCCVars.RMCTacticalMapShowAreaLabels, args.Button.Pressed);
        };
        AreaLabelsCheckbox.Pressed = _config.GetCVar(RMCCVars.RMCTacticalMapShowAreaLabels);
        Map.DrawAreaLabels = AreaLabelsCheckbox.Pressed;
    }

    public void UpdateTexture(Entity<AreaGridComponent> grid)
    {
        Map.UpdateTexture(grid);
        Canvas.UpdateTexture(grid);
    }

    public void UpdateBlips(TacticalMapBlip[]? blips)
    {
        Map.UpdateBlips(blips);
        Canvas.UpdateBlips(blips);
    }

    public void SetLineLimit(int limit)
    {
        Canvas.LineLimit = limit;
    }

    protected override void FrameUpdate(FrameEventArgs args)
    {
        base.FrameUpdate(args);

        var time = IoCManager.Resolve<IGameTiming>().CurTime;
        var cooldown = NextUpdateAt - time;
        if (cooldown < TimeSpan.Zero)
        {
            UpdateCanvasButton.Disabled = false;
            CooldownBar.Visible = false;
            return;
        }

        UpdateCanvasButton.Disabled = true;
        CooldownBar.Visible = true;
        CooldownBar.MinValue = (float) LastUpdateAt.TotalSeconds;
        CooldownBar.MaxValue = (float) NextUpdateAt.TotalSeconds;
        CooldownBar.Value = (float) (LastUpdateAt.TotalSeconds + NextUpdateAt.TotalSeconds - time.TotalSeconds);
        CooldownLabel.Text = $"{(int) cooldown.TotalSeconds} seconds until the canvas changes can be updated";
    }
}
