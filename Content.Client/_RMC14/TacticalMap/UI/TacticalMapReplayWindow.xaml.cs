using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;
using Content.Client._RMC14.UserInterface;
using Content.Shared._RMC14.Areas;
using Content.Shared._RMC14.TacticalMap;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.GameObjects;
using Robust.Shared.Maths;
using Robust.Shared.Prototypes;
using Robust.Shared.Timing;
using Range = Robust.Client.UserInterface.Controls.Range;
using Content.Client._RMC14.TacticalMap.Controls;

namespace Content.Client._RMC14.TacticalMap.UI;

[GenerateTypedNameReferences]
public sealed partial class TacticalMapReplayWindow : RMCPopOutWindow
{
    protected override Control Control => Wrapper;

    [Dependency] private readonly IEntityManager _entityManager = default!;

    private readonly List<TacticalMapReplayMap> _maps = new();
    private readonly Dictionary<NetEntity, TacticalMapReplayMap> _mapLookup = new();

    private TacticalMapReplayMap? _currentMap;
    private string? _currentLayerId;
    private float _currentTime;
    private float _duration;
    private float _baseTime;
    private int _currentFrameIndex;
    private bool _playing;
    private bool _suppressSlider;
    private bool _showLines = true;
    private bool _showCustomLabels = true;
    private bool _showAreaLabels;
    private bool _showBlips = true;
    private bool _loopPlayback;
    private float _speedMultiplier = 1.0f;

    private static readonly Color ToggleOnColor = TacticalMapInnerButton.DefaultTextColor;
    private static readonly Color ToggleOffColor = Color.Red;

    private const int EstimatedLineBytes = 48;
    private const int EstimatedBlipBytes = 48;
    private const int EstimatedLabelBaseBytes = 24;

    private sealed class ReplayLayerState
    {
        public readonly List<TacticalMapLine> Lines = new();
        public readonly Dictionary<Vector2i, TacticalMapLabelData> Labels = new();
        public readonly Dictionary<int, TacticalMapBlip> Blips = new();
    }

    private readonly Dictionary<string, ReplayLayerState> _resolvedLayers = new();
    private readonly List<int> _keyframeIndices = new();
    private int _resolvedFrameIndex = -1;

    public TacticalMapReplayWindow()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        WindowHeader.Visible = false;
        WindowHeader.MinSize = Vector2.Zero;
        ContentsContainer.Margin = new Thickness(0);

        if (Children.FirstOrDefault(child => child.StyleClasses.Contains(StyleClassWindowPanel)) is { } panel)
            RemoveChild(panel);

        Wrapper.SetCanvasAccess(false);
        Wrapper.MapSelected += OnMapSelected;
        Wrapper.LayerSelected += OnLayerSelected;
        Wrapper.PopoutRequested += PopOut;
        Wrapper.CloseRequested += Close;
        Wrapper.LabelsButton.Visible = false;
        OnPopout += () => Wrapper.PopoutButton.Visible = false;
        OnFinalClose += () =>
        {
            if (!Disposed)
                Dispose();
        };

        PlayButton.Button.OnPressed += _ => TogglePlayback();
        TimelineSlider.OnValueChanged += OnSliderChanged;
        SpeedSlider.OnValueChanged += OnSpeedChanged;
        ShowLinesButton.Button.OnPressed += _ => ToggleLines();
        ShowCustomLabelsButton.Button.OnPressed += _ => ToggleCustomLabels();
        ShowAreaLabelsButton.Button.OnPressed += _ => ToggleAreaLabels();
        ShowBlipsButton.Button.OnPressed += _ => ToggleBlips();
        LoopButton.Button.OnPressed += _ => ToggleLoop();

        UpdateSpeedLabel();
        UpdateToggleButtons();
        ApplyReplayLabelMode();
        StatsLabel.Text = string.Empty;
    }

    public void SetReplayData(List<TacticalMapReplayMap> maps, string? preferredMapId)
    {
        _maps.Clear();
        _maps.AddRange(maps);
        UpdateMapList(preferredMapId);
    }

    protected override void FrameUpdate(FrameEventArgs args)
    {
        base.FrameUpdate(args);

        if (!_playing || _currentMap == null)
            return;

        var nextTime = _currentTime + args.DeltaSeconds * _speedMultiplier;
        if (nextTime >= _duration)
        {
            if (_loopPlayback && _duration > 0f)
            {
                nextTime = 0f;
                _currentFrameIndex = 0;
            }
            else
            {
                nextTime = _duration;
                _playing = false;
                PlayButton.Text = "Play";
            }
        }

        SetCurrentTime(nextTime, updateSlider: true);
    }

    private void UpdateMapList(string? preferredMapId)
    {
        _mapLookup.Clear();
        foreach (var map in _maps)
        {
            _mapLookup[map.Map] = map;
        }

        var mapInfos = new List<TacticalMapMapInfo>(_maps.Count);
        NetEntity selectedMap = NetEntity.Invalid;

        foreach (var map in _maps)
        {
            var displayName = string.IsNullOrWhiteSpace(map.DisplayName) ? map.MapId : map.DisplayName;
            mapInfos.Add(new TacticalMapMapInfo(map.Map, map.MapId, displayName));

            if (!string.IsNullOrWhiteSpace(preferredMapId) &&
                string.Equals(map.MapId, preferredMapId, StringComparison.OrdinalIgnoreCase))
            {
                selectedMap = map.Map;
            }
        }

        if (_maps.Count > 0 && selectedMap == NetEntity.Invalid)
            selectedMap = _maps[0].Map;

        Wrapper.UpdateMapList(mapInfos, selectedMap);

        if (_maps.Count > 0 && _mapLookup.TryGetValue(selectedMap, out var selected))
        {
            SetCurrentMap(selected);
        }
        else
        {
            ClearPlayback();
        }
    }

    private void OnMapSelected(NetEntity map)
    {
        if (_mapLookup.TryGetValue(map, out var replayMap))
            SetCurrentMap(replayMap);
    }

    private void SetCurrentMap(TacticalMapReplayMap map)
    {
        _currentMap = map;
        _currentFrameIndex = 0;
        _currentTime = 0f;
        _baseTime = map.Frames.Count > 0 ? map.Frames[0].Time : 0f;
        _duration = map.Frames.Count > 0 ? map.Frames[^1].Time - _baseTime : 0f;
        _duration = MathF.Max(0f, _duration);
        _currentLayerId = null;
        _resolvedLayers.Clear();
        _resolvedFrameIndex = -1;
        UpdateKeyframeIndexCache(map);

        _playing = false;
        PlayButton.Text = "Play";
        PlayButton.Disabled = _duration <= 0f;

        UpdateSlider(0f);
        UpdateTimeLabel();
        UpdateMapTexture(map);
        ApplyReplayLabelMode();
        UpdateLayerList(map);
        ApplyFrame(0);
        UpdateStats();
    }

    private void UpdateMapTexture(TacticalMapReplayMap map)
    {
        Wrapper.SetMapId(map.MapId);

        if (_entityManager.TryGetEntity(map.Map, out var mapEntity) &&
            _entityManager.TryGetComponent(mapEntity.Value, out AreaGridComponent? areaGrid))
        {
            Wrapper.UpdateTexture((mapEntity.Value, areaGrid));
            Wrapper.Map.SetCurrentMap(mapEntity.Value);
            Wrapper.Canvas.SetCurrentMap(mapEntity.Value);
        }
        else
        {
            Wrapper.Map.SetCurrentMap(null);
            Wrapper.Canvas.SetCurrentMap(null);
        }

        var name = string.IsNullOrWhiteSpace(map.DisplayName) ? map.MapId : map.DisplayName;
        Wrapper.Map.SetCurrentMapName(name);
        Wrapper.Canvas.SetCurrentMapName(name);
    }

    private void ClearPlayback()
    {
        _currentMap = null;
        _currentFrameIndex = 0;
        _currentTime = 0f;
        _baseTime = 0f;
        _duration = 0f;
        _playing = false;
        PlayButton.Text = "Play";
        PlayButton.Disabled = true;
        UpdateSlider(0f);
        UpdateTimeLabel();
        _currentLayerId = null;
        _resolvedLayers.Clear();
        _resolvedFrameIndex = -1;
        _keyframeIndices.Clear();

        Wrapper.SetMapId(null);
        Wrapper.Map.SetCurrentMap(null);
        Wrapper.Canvas.SetCurrentMap(null);
        Wrapper.Map.SetCurrentMapName(string.Empty);
        Wrapper.Canvas.SetCurrentMapName(string.Empty);
        Wrapper.Map.Lines.Clear();
        Wrapper.Canvas.Lines.Clear();
        Wrapper.Map.LineThicknesses.Clear();
        Wrapper.Canvas.LineThicknesses.Clear();
        Wrapper.UpdateTacticalLabels(new Dictionary<Vector2i, TacticalMapLabelData>());
        Wrapper.UpdateBlips(Array.Empty<TacticalMapBlip>());
        Wrapper.UpdateLayerList(new List<ProtoId<TacticalMapLayerPrototype>>(), null);
        StatsLabel.Text = string.Empty;
        ApplyReplayLabelMode();
        UpdateToggleButtons();
    }

    private void TogglePlayback()
    {
        if (_currentMap == null || _duration <= 0f)
            return;

        _playing = !_playing;
        PlayButton.Text = _playing ? "Pause" : "Play";
    }

    private void OnSliderChanged(Range range)
    {
        if (_suppressSlider)
            return;

        SetCurrentTime(range.Value, updateSlider: false);
    }

    private void SetCurrentTime(float time, bool updateSlider)
    {
        if (_currentMap == null)
            return;

        var clamped = Math.Clamp(time, 0f, _duration);
        _currentTime = clamped;

        if (updateSlider)
            UpdateSlider(clamped);

        UpdateTimeLabel();
        UpdateFrameForTime();
    }

    private void UpdateFrameForTime()
    {
        if (_currentMap == null || _currentMap.Value.Frames.Count == 0)
            return;

        var frames = _currentMap.Value.Frames;
        var targetTime = _baseTime + _currentTime;
        var index = FindFrameIndex(frames, targetTime);

        if (index == _currentFrameIndex)
            return;

        _currentFrameIndex = index;
        ApplyFrame(index);
    }

    private void ApplyFrame(int index)
    {
        if (_currentMap == null || _currentMap.Value.Frames.Count == 0)
            return;

        var frames = _currentMap.Value.Frames;
        index = Math.Clamp(index, 0, frames.Count - 1);
        EnsureResolvedState(index);

        Wrapper.Map.Lines.Clear();
        Wrapper.Canvas.Lines.Clear();
        Wrapper.Map.LineThicknesses.Clear();
        Wrapper.Canvas.LineThicknesses.Clear();

        var labels = new Dictionary<Vector2i, TacticalMapLabelData>();
        var blips = new List<TacticalMapBlip>();

        foreach (var (layerId, state) in _resolvedLayers)
        {
            if (_currentLayerId != null &&
                !string.Equals(layerId, _currentLayerId, StringComparison.OrdinalIgnoreCase))
            {
                continue;
            }

            if (_showLines && state.Lines.Count > 0)
            {
                Wrapper.Map.Lines.AddRange(state.Lines);
                Wrapper.Canvas.Lines.AddRange(state.Lines);
            }

            if (_showCustomLabels && state.Labels.Count > 0)
            {
                foreach (var (pos, label) in state.Labels)
                {
                    labels[pos] = label;
                }
            }

            if (_showBlips && state.Blips.Count > 0)
            {
                foreach (var (_, blip) in state.Blips.OrderBy(pair => pair.Key))
                    blips.Add(blip);
            }
        }

        Wrapper.UpdateTacticalLabels(labels);
        Wrapper.UpdateBlips(_showBlips ? blips.ToArray() : Array.Empty<TacticalMapBlip>());
    }

    private void EnsureResolvedState(int targetIndex)
    {
        if (_currentMap == null)
            return;

        if (_resolvedFrameIndex == targetIndex && _resolvedLayers.Count > 0)
            return;

        if (_resolvedFrameIndex >= 0 && targetIndex > _resolvedFrameIndex)
        {
            ApplyFrameRange(_resolvedFrameIndex + 1, targetIndex);
            _resolvedFrameIndex = targetIndex;
            return;
        }

        RebuildResolvedState(targetIndex);
    }

    private void RebuildResolvedState(int targetIndex)
    {
        if (_currentMap == null)
            return;

        var frames = _currentMap.Value.Frames;
        if (frames.Count == 0)
            return;

        targetIndex = Math.Clamp(targetIndex, 0, frames.Count - 1);
        var startIndex = FindKeyframeIndex(targetIndex);

        _resolvedLayers.Clear();
        for (var i = startIndex; i <= targetIndex; i++)
        {
            var frame = frames[i];
            if (frame.IsKeyframe)
                _resolvedLayers.Clear();

            ApplyFrameToState(_resolvedLayers, frame);
        }

        _resolvedFrameIndex = targetIndex;
    }

    private void ApplyFrameRange(int startIndex, int endIndex)
    {
        if (_currentMap == null)
            return;

        var frames = _currentMap.Value.Frames;
        startIndex = Math.Clamp(startIndex, 0, frames.Count - 1);
        endIndex = Math.Clamp(endIndex, 0, frames.Count - 1);

        for (var i = startIndex; i <= endIndex; i++)
        {
            var frame = frames[i];
            if (frame.IsKeyframe)
                _resolvedLayers.Clear();

            ApplyFrameToState(_resolvedLayers, frame);
        }
    }

    private static void ApplyFrameToState(
        Dictionary<string, ReplayLayerState> resolvedLayers,
        TacticalMapReplayFrame frame)
    {
        foreach (var delta in frame.Layers)
        {
            if (!resolvedLayers.TryGetValue(delta.LayerId, out var state))
            {
                state = new ReplayLayerState();
                resolvedLayers[delta.LayerId] = state;
            }

            ApplyLayerDelta(state, delta);
        }
    }

    private static void ApplyLayerDelta(ReplayLayerState state, TacticalMapReplayLayerDelta delta)
    {
        if (delta.LinesChanged)
        {
            if (delta.LinesIsFull)
            {
                state.Lines.Clear();
                state.Lines.AddRange(delta.Lines);
            }
            else
            {
                state.Lines.AddRange(delta.Lines);
            }
        }

        if (delta.LabelsChanged)
        {
            if (delta.LabelsIsFull)
            {
                state.Labels.Clear();
                foreach (var (pos, label) in delta.Labels)
                    state.Labels[pos] = label;
            }
            else
            {
                foreach (var (pos, label) in delta.Labels)
                    state.Labels[pos] = label;

                foreach (var pos in delta.RemovedLabels)
                    state.Labels.Remove(pos);
            }
        }

        if (delta.BlipsChanged)
        {
            if (delta.BlipsIsFull)
            {
                state.Blips.Clear();
                foreach (var (id, blip) in delta.Blips)
                    state.Blips[id] = blip;
            }
            else
            {
                foreach (var (id, blip) in delta.Blips)
                    state.Blips[id] = blip;

                foreach (var id in delta.RemovedBlips)
                    state.Blips.Remove(id);
            }
        }
    }

    private void UpdateSlider(float value)
    {
        _suppressSlider = true;
        TimelineSlider.MinValue = 0f;
        TimelineSlider.MaxValue = MathF.Max(0.01f, _duration);
        TimelineSlider.Value = value;
        _suppressSlider = false;
    }

    private void UpdateTimeLabel()
    {
        TimeLabel.Text = $"{FormatTime(_currentTime)} / {FormatTime(_duration)}";
    }

    private void UpdateLayerList(TacticalMapReplayMap map)
    {
        var layers = new List<ProtoId<TacticalMapLayerPrototype>>(map.LayerIds.Count);
        foreach (var layerId in map.LayerIds)
        {
            layers.Add(layerId);
        }

        Wrapper.UpdateLayerList(layers, null);
        _currentLayerId = null;
    }

    private void UpdateKeyframeIndexCache(TacticalMapReplayMap map)
    {
        _keyframeIndices.Clear();

        for (var i = 0; i < map.Frames.Count; i++)
        {
            if (map.Frames[i].IsKeyframe)
                _keyframeIndices.Add(i);
        }

        if (_keyframeIndices.Count == 0 && map.Frames.Count > 0)
            _keyframeIndices.Add(0);
    }

    private void OnLayerSelected(ProtoId<TacticalMapLayerPrototype>? layer)
    {
        _currentLayerId = layer?.Id;
        ApplyFrame(_currentFrameIndex);
    }

    private void OnSpeedChanged(Range range)
    {
        _speedMultiplier = Math.Clamp(range.Value, 0.25f, 20.0f);
        UpdateSpeedLabel();
    }

    private void UpdateSpeedLabel()
    {
        SpeedLabel.Text = $"Speed {_speedMultiplier:0.00}x";
    }

    private void ToggleLines()
    {
        _showLines = !_showLines;
        UpdateToggleButtons();
        ApplyFrame(_currentFrameIndex);
    }

    private void ToggleCustomLabels()
    {
        _showCustomLabels = !_showCustomLabels;
        ApplyReplayLabelMode();
        UpdateToggleButtons();
        ApplyFrame(_currentFrameIndex);
    }

    private void ToggleAreaLabels()
    {
        _showAreaLabels = !_showAreaLabels;
        ApplyReplayLabelMode();
        UpdateToggleButtons();
        ApplyFrame(_currentFrameIndex);
    }

    private void ToggleBlips()
    {
        _showBlips = !_showBlips;
        UpdateToggleButtons();
        ApplyFrame(_currentFrameIndex);
    }

    private void ToggleLoop()
    {
        _loopPlayback = !_loopPlayback;
        UpdateToggleButtons();
    }

    private void ApplyReplayLabelMode()
    {
        var mode = (_showAreaLabels, _showCustomLabels) switch
        {
            (true, true) => TacticalMapControl.LabelMode.All,
            (true, false) => TacticalMapControl.LabelMode.Area,
            (false, true) => TacticalMapControl.LabelMode.Tactical,
            _ => TacticalMapControl.LabelMode.None
        };

        Wrapper.Map.CurrentLabelMode = mode;
        Wrapper.Canvas.CurrentLabelMode = mode;
    }

    private void UpdateToggleButtons()
    {
        UpdateToggleButton(ShowLinesButton, "Lines", _showLines);
        UpdateToggleButton(ShowCustomLabelsButton, "Labels", _showCustomLabels);
        UpdateToggleButton(ShowAreaLabelsButton, "Area Labels", _showAreaLabels);
        UpdateToggleButton(ShowBlipsButton, "Blips", _showBlips);
        UpdateToggleButton(LoopButton, "Loop", _loopPlayback);
    }

    private static void UpdateToggleButton(TacticalMapButton button, string label, bool enabled)
    {
        var text = enabled ? label : $"{label} Off";
        var color = enabled ? ToggleOnColor : ToggleOffColor;
        button.Button.TextColor = color;
        button.Text = text;
    }

    private void UpdateStats()
    {
        if (_currentMap == null)
        {
            StatsLabel.Text = string.Empty;
            return;
        }

        var map = _currentMap.Value;
        int frameCount = map.Frames.Count;
        int totalLines = 0;
        int totalLabels = 0;
        int totalBlips = 0;
        int maxLines = 0;
        int maxLabels = 0;
        int maxBlips = 0;
        long estimatedBytes = 0;

        var resolved = new Dictionary<string, ReplayLayerState>();

        foreach (var frame in map.Frames)
        {
            if (frame.IsKeyframe)
                resolved.Clear();

            ApplyFrameToState(resolved, frame);

            int frameLines = 0;
            int frameLabels = 0;
            int frameBlips = 0;

            foreach (var layer in resolved.Values)
            {
                frameLines += layer.Lines.Count;
                frameLabels += layer.Labels.Count;
                frameBlips += layer.Blips.Count;
            }

            totalLines += frameLines;
            totalLabels += frameLabels;
            totalBlips += frameBlips;
            maxLines = Math.Max(maxLines, frameLines);
            maxLabels = Math.Max(maxLabels, frameLabels);
            maxBlips = Math.Max(maxBlips, frameBlips);

            foreach (var layer in frame.Layers)
            {
                if (layer.LinesChanged)
                    estimatedBytes += layer.Lines.Count * EstimatedLineBytes;

                if (layer.BlipsChanged)
                    estimatedBytes += layer.Blips.Count * EstimatedBlipBytes;

                if (layer.LabelsChanged)
                {
                    estimatedBytes += layer.Labels.Count * EstimatedLabelBaseBytes;
                    foreach (var label in layer.Labels.Values)
                    {
                        estimatedBytes += Encoding.UTF8.GetByteCount(label.Text);
                    }
                }
            }
        }

        float avgLines = frameCount > 0 ? totalLines / (float) frameCount : 0f;
        float avgLabels = frameCount > 0 ? totalLabels / (float) frameCount : 0f;
        float avgBlips = frameCount > 0 ? totalBlips / (float) frameCount : 0f;
        var durationText = FormatTime(_duration);
        var stats = new StringBuilder();
        stats.Append($"Frames: {frameCount}");
        stats.Append($" | Duration: {durationText}");
        stats.Append($" | Layers: {map.LayerIds.Count}");
        stats.Append($" | Lines avg: {avgLines:0.0} max: {maxLines}");
        stats.Append($" | Labels avg: {avgLabels:0.0} max: {maxLabels}");
        stats.Append($" | Blips avg: {avgBlips:0.0} max: {maxBlips}");
        stats.Append($" | Est: {FormatBytes(estimatedBytes)}");
        StatsLabel.Text = stats.ToString();
    }

    private static string FormatBytes(long bytes)
    {
        const double kb = 1024.0;
        const double mb = kb * 1024.0;

        if (bytes >= mb)
            return $"{bytes / mb:0.0} MB";
        if (bytes >= kb)
            return $"{bytes / kb:0.0} KB";
        return $"{bytes} B";
    }

    private static int FindFrameIndex(List<TacticalMapReplayFrame> frames, float targetTime)
    {
        var low = 0;
        var high = frames.Count - 1;

        while (low <= high)
        {
            var mid = (low + high) / 2;
            if (frames[mid].Time <= targetTime)
                low = mid + 1;
            else
                high = mid - 1;
        }

        return Math.Clamp(high, 0, frames.Count - 1);
    }

    private int FindKeyframeIndex(int targetIndex)
    {
        if (_keyframeIndices.Count == 0)
            return 0;

        var keyframeIndex = _keyframeIndices[0];
        foreach (var index in _keyframeIndices)
        {
            if (index > targetIndex)
                break;

            keyframeIndex = index;
        }

        return keyframeIndex;
    }

    private static string FormatTime(float seconds)
    {
        var time = TimeSpan.FromSeconds(MathF.Max(0f, seconds));
        return time.TotalHours >= 1
            ? $"{(int)time.TotalHours}:{time.Minutes:00}:{time.Seconds:00}"
            : $"{time.Minutes}:{time.Seconds:00}";
    }
}
