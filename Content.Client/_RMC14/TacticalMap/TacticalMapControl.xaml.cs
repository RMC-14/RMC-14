using System.Numerics;
using Content.Shared._RMC14.Areas;
using Content.Shared._RMC14.TacticalMap;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.Graphics;
using Robust.Client.ResourceManagement;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Input;
using Robust.Shared.Localization;
using Robust.Shared.Prototypes;
using Robust.Shared.Timing;
using Robust.Shared.Utility;
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.PixelFormats;
using Color = Robust.Shared.Maths.Color;

namespace Content.Client._RMC14.TacticalMap;

[GenerateTypedNameReferences]
public sealed partial class TacticalMapControl : TextureRect
{
    public enum LabelMode
    {
        All = 0,
        Tactical = 1,
        Area = 2,
        None = 3
    }

    private const float MapScale = 3f;
    private const float BaseBlipSize = 14f;
    private const float ClickTolerance = 8f;
    private const float BlipEdgeRatio = 0.7f;
    private const float CloseBlipThreshold = 2.2f;
    private const float CloseBlipSafety = 0.8f;
    private const int DashLength = 6;
    private const int GapLength = 3;
    private const int ArrowLength = 15;
    private const int ArrowWidth = 8;
    private const float MinDragDistance = 10f;
    private const float MinFreehandSegmentPixels = 6f;
    private const float MinEraserSegmentPixels = 3f;
    private const float SmoothSamplePixels = 4f;
    private const float LineJoinEpsilon = 0.05f;
    private const float LineSoftEdgePixels = 1.5f;
    private const float LineSoftEdgeAlpha = 0.4f;
    private const float EraserRadiusPixels = 6f;
    private const float LabelYOffset = 6f;
    private const float LabelStackOffset = 9f;
    private const float LabelMinFontSize = 7f;
    private const float LabelFontScale = 9f;
    private const float LabelPadding = 2f;
    private const float MinZoom = 0.3f;
    private const float MaxZoom = 5.0f;
    private const float ZoomSpeed = 1.2f;
    private const float LabelClickTolerance = 15f;

    private const float PingDuration = 2.0f;
    private const float PingMinScale = 1.0f;
    private const float PingMaxScale = 2.5f;
    private const float PingMinAlpha = 0.0f;
    private const float PingMaxAlpha = 0.65f;
    private const float PingRingThickness = 1.5f;

    private static readonly Color AreaLabelColor = Color.White;
    private static readonly Color DefaultTacticalLabelColor = Color.White;
    private static readonly Color AreaLabelBackground = Color.Black.WithAlpha(0.5f);
    private static readonly Color TacticalLabelBackground = Color.FromHex("#0D1A2F").WithAlpha(0.5f);
    private static readonly Color LabelDragBackground = Color.Black.WithAlpha(0.7f);
    private static readonly Color EraserPreviewColor = Color.White.WithAlpha(0.45f);


    [Dependency] private readonly IResourceCache _resourceCache = default!;
    [Dependency] private readonly IEntityManager _entityManager = default!;
    [Dependency] private readonly IPrototypeManager _prototypes = default!;

    private readonly Font _font;
    private readonly Label? _tunnelInfoLabel;
    private readonly Vector2[] _reusableLineVectors = new Vector2[6];

    public readonly List<TacticalMapLine> Lines = new();
    public readonly List<float> LineThicknesses = new();
    public readonly Dictionary<Vector2i, string> TacticalLabels = new();

    private TacticalMapBlip[]? _blips;
    private int[]? _blipEntityIds;
    private int? _localPlayerEntityId;
    private Dictionary<Vector2i, string> _areaLabels = new();
    private bool[]? _tileMask;
    private Texture? _backgroundTexture;
    private int _tileMaskWidth;
    private int _tileMaskHeight;

    private Vector2i _min;
    private Vector2i _delta;
    private float _zoomFactor = 1.0f;
    private Vector2 _panOffset = Vector2.Zero;

    private bool _dragging;
    private Vector2i? _lastDrag;
    private Vector2i? _dragStart;
    private Vector2i? _previewEnd;
    private bool _rightClickPanning;
    private Vector2? _lastPanPosition;
    private Vector2? _rightClickStartPosition;
    private bool _rightClickMoved;
    private Vector2? _lastErasePosition;

    private Vector2i? _draggingLabel;
    private Vector2i? _labelDragStart;
    private Vector2? _currentDragPosition;
    private Vector2? _lastMousePosition;
    private Vector2i? _lastHoverIndices;

    private TacticalMapSettingsManager? _settingsManager;
    private EntityUid? _currentMapEntity;
    private string? _currentMapName;
    private EntityUid? _currentAreaGridEntity;

    private Action<float, Vector2>? _viewUpdateCallback;

    public int LineLimit;
    public bool Drawing { get; set; }
    public bool IsCanvas { get; set; } = false;
    public LabelMode CurrentLabelMode { get; set; } = LabelMode.All;
    public bool StraightLineMode { get; set; } = false;
    public bool LabelEditMode { get; set; } = false;
    public bool EraserMode { get; set; } = false;
    public Color Color;
    public float BlipSizeMultiplier { get; set; } = 0.9f;
    public float LineThickness { get; set; } = 2.0f;
    public bool QueenEyeMode { get; set; }
    public Color TacticalLabelTextColor { get; set; } = DefaultTacticalLabelColor;

    public Action<Vector2i>? OnBlipClicked;
    public Action<Vector2i, string>? OnBlipRightClicked;
    public Action<TacticalMapControl, Vector2i, Vector2>? OnContextMenuRequested;
    public Action? OnUserInteraction;
    public Action<Vector2i>? OnQueenEyeMove;
    public Action<Vector2i, string>? OnCreateLabel;
    public Action<Vector2i, string>? OnEditLabel;
    public Action<Vector2i>? OnDeleteLabel;
    public Action<Vector2i, Vector2i>? OnMoveLabel;
    public Action<TacticalMapAreaInfo?>? OnHoverAreaInfo;

    public TacticalMapControl()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
        _font = new VectorFont(_resourceCache.GetResource<FontResource>("/Fonts/NotoSans/NotoSans-Bold.ttf"), 10);

        _tunnelInfoLabel = new Label
        {
            Visible = false,
            StyleClasses = { "LabelHeading" },
            FontColorOverride = Color.Black,
            Margin = new Thickness(8, 8),
            HorizontalAlignment = HAlignment.Center,
            VerticalAlignment = VAlignment.Center,
        };

        AddChild(_tunnelInfoLabel);
    }

    public float GetCurrentZoomFactor()
    {
        return _zoomFactor;
    }

    public Vector2 GetCurrentPanOffset()
    {
        return _panOffset;
    }

    public void SetViewUpdateCallback(Action<float, Vector2> callback)
    {
        _viewUpdateCallback = callback;
    }

    private void NotifyViewChanged()
    {
        _viewUpdateCallback?.Invoke(_zoomFactor, _panOffset);
    }

    public void LoadViewSettings(float zoomFactor, Vector2 panOffset, EntityUid? mapEntity)
    {
        _currentMapEntity = mapEntity;
        _zoomFactor = Math.Clamp(zoomFactor, MinZoom, MaxZoom);
        _panOffset = panOffset;

        ApplyViewSettings();
        NotifyViewChanged();
    }

    public void SetCurrentMap(EntityUid? mapEntity)
    {
        _currentMapEntity = mapEntity;
    }

    public void SetCurrentMapName(string? mapName)
    {
        _currentMapName = mapName;
    }

    public void ApplyViewSettings()
    {
        if (Texture == null)
            return;

        Vector2 availableSize = new(PixelWidth, PixelHeight);
        if (availableSize.X <= 0 || availableSize.Y <= 0)
            return;

        _zoomFactor = Math.Clamp(_zoomFactor, MinZoom, MaxZoom);

        float maxPan = Math.Max(availableSize.X, availableSize.Y) * _zoomFactor * 0.5f;
        _panOffset = Vector2.Clamp(_panOffset, new Vector2(-maxPan), new Vector2(maxPan));
    }

    public void UpdateTexture(Entity<AreaGridComponent> grid)
    {
        _currentAreaGridEntity = grid.Owner;

        if (grid.Comp.Colors.Count == 0)
        {
            _tileMask = null;
            _tileMaskWidth = 0;
            _tileMaskHeight = 0;
            _backgroundTexture = null;
            return;
        }

        var colors = grid.Comp.Colors;
        var hasValue = false;
        Vector2i fullMin = default;
        Vector2i fullMax = default;
        foreach (var (pos, _) in colors)
        {
            if (!hasValue)
            {
                fullMin = pos;
                fullMax = pos;
                hasValue = true;
            }
            else
            {
                fullMin = Vector2i.ComponentMin(fullMin, pos);
                fullMax = Vector2i.ComponentMax(fullMax, pos);
            }
        }

        if (!hasValue)
        {
            _tileMask = null;
            _tileMaskWidth = 0;
            _tileMaskHeight = 0;
            _backgroundTexture = null;
            return;
        }

        Vector2i boundsMin;
        Vector2i boundsMax;
        if (grid.Comp.HasTacMapBounds)
        {
            boundsMin = Vector2i.ComponentMax(fullMin, grid.Comp.TacMapBoundsMin);
            boundsMax = Vector2i.ComponentMin(fullMax, grid.Comp.TacMapBoundsMax);

            if (boundsMax.X < boundsMin.X || boundsMax.Y < boundsMin.Y)
            {
                boundsMin = fullMin;
                boundsMax = fullMax;
            }
        }
        else
        {
            boundsMin = fullMin;
            boundsMax = fullMax;
        }

        _min = boundsMin;
        _delta = boundsMax - boundsMin;

        if (_delta.X <= 0 || _delta.Y <= 0)
        {
            _tileMask = null;
            _tileMaskWidth = 0;
            _tileMaskHeight = 0;
            _backgroundTexture = null;
            return;
        }

        int width = _delta.X + 1;
        int height = _delta.Y + 1;
        _tileMaskWidth = width;
        _tileMaskHeight = height;
        _tileMask = new bool[width * height];

        Image<Rgba32> image = new(width, height);
        Image<Rgba32> background = new(width, height);
        foreach ((Vector2i position, Color color) in colors)
        {
            if (position.X < boundsMin.X || position.X > boundsMax.X ||
                position.Y < boundsMin.Y || position.Y > boundsMax.Y)
            {
                continue;
            }

            (int x, int y) = GetDrawPosition(position);
            _tileMask[y * width + x] = true;
            var backgroundColor = color.WithAlpha(1f);
            background[x, y] = new Rgba32(backgroundColor.R, backgroundColor.G, backgroundColor.B, backgroundColor.A);
            image[x, y] = new Rgba32(color.R, color.G, color.B, color.A);
        }

        _backgroundTexture = Texture.LoadFromImage(background);
        Texture = Texture.LoadFromImage(image);
        _areaLabels.Clear();
        foreach ((Vector2i position, string label) in grid.Comp.Labels)
        {
            if (position.X < boundsMin.X || position.X > boundsMax.X ||
                position.Y < boundsMin.Y || position.Y > boundsMax.Y)
            {
                continue;
            }

            _areaLabels[position] = label;
        }

        ApplyViewSettings();
    }

    public bool TryGetAreaInfo(Vector2i indices, out TacticalMapAreaInfo info)
    {
        info = default;
        if (_currentAreaGridEntity == null)
            return false;

        if (!_entityManager.TryGetComponent(_currentAreaGridEntity.Value, out AreaGridComponent? areaGrid))
            return false;

        string? areaId = null;
        string areaName = Loc.GetString("rmc-tacmap-alert-no-area");
        string? linkedLz = null;
        bool hasArea = false;
        bool cas = false;
        bool mortarFire = false;
        bool mortarPlacement = false;
        bool lasing = false;
        bool medevac = false;
        bool paradropping = false;
        bool orbitalBombard = false;
        bool supplyDrop = false;
        bool fulton = false;
        bool landingZone = false;
        string? areaLabel = null;

        if (areaGrid.Areas.TryGetValue(indices, out var areaProtoId))
        {
            hasArea = true;
            areaId = areaProtoId.Id;
            if (_prototypes.TryIndex(areaProtoId, out var areaProto))
                areaName = areaProto.Name;

            if (areaGrid.AreaEntities.TryGetValue(areaProtoId, out var areaEntity) &&
                _entityManager.TryGetComponent(areaEntity, out AreaComponent? areaComp))
            {
                cas = areaComp.CAS;
                mortarFire = areaComp.MortarFire;
                mortarPlacement = areaComp.MortarPlacement;
                lasing = areaComp.Lasing;
                medevac = areaComp.Medevac;
                paradropping = areaComp.Paradropping;
                orbitalBombard = areaComp.OB;
                supplyDrop = areaComp.SupplyDrop;
                fulton = areaComp.Fulton;
                landingZone = areaComp.LandingZone;
                linkedLz = areaComp.LinkedLz;
            }
        }

        areaLabel = _areaLabels.GetValueOrDefault(indices);
        var tacticalLabel = TacticalLabels.GetValueOrDefault(indices);

        info = new TacticalMapAreaInfo(
            indices,
            areaName,
            areaId,
            areaLabel,
            tacticalLabel,
            hasArea,
            cas,
            mortarFire,
            mortarPlacement,
            lasing,
            medevac,
            paradropping,
            orbitalBombard,
            supplyDrop,
            fulton,
            landingZone,
            linkedLz);

        return true;
    }

    public void UpdateBlips(TacticalMapBlip[]? blips)
    {
        _blips = blips;
        _blipEntityIds = null;
    }

    public void UpdateBlips(TacticalMapBlip[]? blips, int[]? entityIds)
    {
        _blips = blips;
        _blipEntityIds = entityIds;
    }

    public void SetLocalPlayerEntityId(int? entityId)
    {
        _localPlayerEntityId = entityId;
    }


    public void UpdateTacticalLabels(Dictionary<Vector2i, string> labels)
    {
        TacticalLabels.Clear();
        foreach ((Vector2i pos, string text) in labels)
        {
            TacticalLabels[pos] = text;
        }
    }

    public Vector2 IndicesToPosition(Vector2i indices)
    {
        return GetDrawPosition(indices) * MapScale;
    }

    public Vector2i PositionToIndices(Vector2 controlPosition)
    {
        if (Texture == null)
            return Vector2i.Zero;

        Vector2 pixelPosition = LogicalToPixel(controlPosition);
        (Vector2 actualSize, Vector2 actualTopLeft, float overlayScale) = GetDrawParameters();

        Vector2 relativeToTexture = (pixelPosition - actualTopLeft) / overlayScale;

        return new Vector2i(
            (int)(relativeToTexture.X / MapScale) + _min.X,
            _delta.Y - (int)(relativeToTexture.Y / MapScale) + _min.Y
        );
    }

    private Vector2 PositionToLineCoordinatesFloat(Vector2 controlPosition, Vector2 actualTopLeft, float overlayScale)
    {
        Vector2 pixelPosition = LogicalToPixel(controlPosition);
        return (pixelPosition - actualTopLeft) / overlayScale;
    }

    private void AddLineSegment(Vector2 start, Vector2 end)
    {
        if ((end - start).LengthSquared() < 0.01f)
            return;

        AddLineToCanvas(start, end);
    }

    private void TryEraseAt(Vector2 controlPosition)
    {
        if (Texture == null || Lines.Count == 0)
            return;

        (_, Vector2 actualTopLeft, float overlayScale) = GetDrawParameters();
        if (overlayScale <= 0f)
            return;

        Vector2 linePosition = PositionToLineCoordinatesFloat(controlPosition, actualTopLeft, overlayScale);
        float eraserRadius = (EraserRadiusPixels + LineThickness * 1.5f) / Math.Max(overlayScale, 0.001f);

        EraseLinesNear(linePosition, eraserRadius);
    }

    private void EraseLinesNear(Vector2 linePosition, float radius)
    {
        float radiusSquared = radius * radius;

        for (int i = Lines.Count - 1; i >= 0; i--)
        {
            TacticalMapLine line = Lines[i];
            float thickness = GetLineThickness(i, line);
            float effectiveRadius = radius + thickness * 0.6f;
            float effectiveRadiusSquared = effectiveRadius * effectiveRadius;

            if (DistanceSquaredPointToSegment(linePosition, line.Start, line.End) <= effectiveRadiusSquared)
            {
                Lines.RemoveAt(i);
                if (i < LineThicknesses.Count)
                    LineThicknesses.RemoveAt(i);
            }
        }
    }

    private static float DistanceSquaredPointToSegment(Vector2 point, Vector2 a, Vector2 b)
    {
        Vector2 ab = b - a;
        float abLengthSquared = ab.LengthSquared();
        if (abLengthSquared <= 0.0001f)
            return Vector2.DistanceSquared(point, a);

        float t = Vector2.Dot(point - a, ab) / abLengthSquared;
        t = Math.Clamp(t, 0f, 1f);
        Vector2 closest = a + ab * t;
        return Vector2.DistanceSquared(point, closest);
    }

    public bool CenterOnPosition(Vector2i indices)
    {
        if (Texture == null)
            return false;

        Vector2 availableSize = new(PixelWidth, PixelHeight);

        if (availableSize.X <= 0 || availableSize.Y <= 0)
            return false;

        Vector2 targetPosition = IndicesToPosition(indices);

        Vector2 textureSize = Texture.Size;
        float baseScaleX = availableSize.X / textureSize.X;
        float baseScaleY = availableSize.Y / textureSize.Y;
        float baseScale = Math.Min(baseScaleX, baseScaleY);
        float actualScale = baseScale * _zoomFactor;
        Vector2 actualSize = textureSize * actualScale;
        float overlayScale = actualScale / MapScale;

        Vector2 currentTargetScreenPos = targetPosition * overlayScale + (availableSize - actualSize) / 2 + _panOffset;
        Vector2 screenCenter = availableSize / 2;

        Vector2 oldPanOffset = _panOffset;
        _panOffset = screenCenter - targetPosition * overlayScale - (availableSize - actualSize) / 2;

        float maxPan = Math.Max(availableSize.X, availableSize.Y) * _zoomFactor * 0.5f;
        _panOffset = Vector2.Clamp(_panOffset, new Vector2(-maxPan), new Vector2(maxPan));

        return true;
    }

    public void ResetZoomAndPan()
    {
        _zoomFactor = 1.0f;
        _panOffset = Vector2.Zero;
        NotifyViewChanged();
    }

    public Vector2 ConvertIndicesToLineCoordinates(Vector2i indices)
    {
        return GetDrawPosition(indices) * MapScale;
    }

    public void ShowTunnelInfo(Vector2i indices, string tunnelName, Vector2 screenPosition)
    {
        if (_tunnelInfoLabel == null)
            return;

        _tunnelInfoLabel.Text = tunnelName;
        _tunnelInfoLabel.Visible = true;

        LayoutContainer.SetPosition(_tunnelInfoLabel, screenPosition + new Vector2(-(_tunnelInfoLabel.DesiredSize.X / 2), -45));
    }

    public void HideTunnelInfo()
    {
        if (_tunnelInfoLabel != null)
            _tunnelInfoLabel.Visible = false;
    }

    private float GetUIScale()
    {
        return Width > 0 ? PixelWidth / Width : 1.0f;
    }

    private Vector2 LogicalToPixel(Vector2 logicalPosition)
    {
        float uiScale = GetUIScale();
        return logicalPosition * uiScale;
    }

    private Vector2 PixelToLogical(Vector2 pixelPosition)
    {
        float uiScale = GetUIScale();
        return pixelPosition / uiScale;
    }

    private float GetScaledBlipSize(float overlayScale)
    {
        float baseScaledSize = BaseBlipSize * (1.0f + (overlayScale - 1.0f) * 0.6f);
        float zoomReduction = 1.0f / (float)Math.Pow(Math.Max(_zoomFactor, 0.3f), 0.3f);
        return baseScaledSize * zoomReduction * BlipSizeMultiplier;
    }

    private (Vector2 actualSize, Vector2 actualTopLeft, float overlayScale) GetDrawParameters()
    {
        if (Texture == null)
            return (Vector2.Zero, Vector2.Zero, 1.0f);

        Vector2 textureSize = Texture.Size;
        Vector2 availableSize = new(PixelWidth, PixelHeight);

        float baseScaleX = availableSize.X / textureSize.X;
        float baseScaleY = availableSize.Y / textureSize.Y;
        float baseScale = Math.Min(baseScaleX, baseScaleY);
        float actualScale = baseScale * _zoomFactor;

        Vector2 actualSize = textureSize * actualScale;
        Vector2 actualTopLeft = (availableSize - actualSize) / 2 + _panOffset;
        float overlayScale = actualScale / MapScale;

        return (actualSize, actualTopLeft, overlayScale);
    }

    private Vector2i GetDrawPosition(Vector2i pos)
    {
        return new Vector2i(pos.X - _min.X, _delta.Y - (pos.Y - _min.Y));
    }

    private TacticalMapBlip? GetBlipAtPosition(Vector2 controlPosition)
    {
        if (_blips == null || Texture == null)
            return null;

        Vector2 pixelPosition = LogicalToPixel(controlPosition);
        (Vector2 actualSize, Vector2 actualTopLeft, float overlayScale) = GetDrawParameters();
        float clickTolerance = ClickTolerance * overlayScale;

        foreach (TacticalMapBlip blip in _blips)
        {
            Vector2 blipPosition = IndicesToPosition(blip.Indices) * overlayScale + actualTopLeft;
            float scaledBlipSize = GetScaledBlipSize(overlayScale);

            UIBox2 blipRect = UIBox2.FromDimensions(
                blipPosition - new Vector2(clickTolerance, clickTolerance),
                new Vector2(scaledBlipSize + clickTolerance * 2, scaledBlipSize + clickTolerance * 2)
            );

            if (blipRect.Contains(pixelPosition))
                return blip;
        }

        return null;
    }

    private Vector2i? GetLabelAtPosition(Vector2 controlPosition)
    {
        if (Texture == null)
            return null;

        if (CurrentLabelMode == LabelMode.None)
            return null;

        Vector2 pixelPosition = LogicalToPixel(controlPosition);
        (Vector2 actualSize, Vector2 actualTopLeft, float overlayScale) = GetDrawParameters();
        float clickTolerance = LabelClickTolerance * overlayScale;

        Vector2i? CheckLabels(Dictionary<Vector2i, string> labels, float yOffsetMultiplier)
        {
            foreach ((Vector2i indices, string label) in labels)
            {
                Vector2 position = IndicesToPosition(indices) * overlayScale + actualTopLeft;
                position = position with { Y = position.Y - (LabelYOffset + LabelStackOffset * yOffsetMultiplier) * overlayScale };

                float fontSize = Math.Max(LabelMinFontSize, overlayScale * LabelFontScale);
                float textWidth = label.Length * fontSize * 0.6f;
                float textHeight = fontSize;
                Vector2 textSize = new(textWidth, textHeight);
                UIBox2 labelRect = UIBox2.FromDimensions(
                    position - textSize / 2 - new Vector2(clickTolerance),
                    textSize + new Vector2(clickTolerance * 2)
                );

                if (labelRect.Contains(pixelPosition))
                    return indices;
            }

            return null;
        }

        if (CurrentLabelMode == LabelMode.All)
        {
            return CheckLabels(TacticalLabels, 1f) ?? CheckLabels(_areaLabels, 0f);
        }

        return CurrentLabelMode == LabelMode.Area
            ? CheckLabels(_areaLabels, 0f)
            : CheckLabels(TacticalLabels, 0f);
    }

    private Vector2i? GetTacticalLabelAtPosition(Vector2 controlPosition)
    {
        if (CurrentLabelMode == LabelMode.Area || CurrentLabelMode == LabelMode.None)
            return null;

        if (Texture == null)
            return null;

        Vector2 pixelPosition = LogicalToPixel(controlPosition);
        (Vector2 actualSize, Vector2 actualTopLeft, float overlayScale) = GetDrawParameters();
        float clickTolerance = LabelClickTolerance * overlayScale;

        foreach ((Vector2i indices, string label) in TacticalLabels)
        {
            Vector2 position = IndicesToPosition(indices) * overlayScale + actualTopLeft;
            float stackOffset = CurrentLabelMode == LabelMode.All && _areaLabels.ContainsKey(indices)
                ? LabelStackOffset
                : 0f;
            position = position with { Y = position.Y - (LabelYOffset + stackOffset) * overlayScale };

            float fontSize = Math.Max(LabelMinFontSize, overlayScale * LabelFontScale);
            float textWidth = label.Length * fontSize * 0.6f;
            float textHeight = fontSize;
            Vector2 textSize = new(textWidth, textHeight);
            UIBox2 labelRect = UIBox2.FromDimensions(
                position - textSize / 2 - new Vector2(clickTolerance),
                textSize + new Vector2(clickTolerance * 2)
            );

            if (labelRect.Contains(pixelPosition))
                return indices;
        }

        return null;
    }

    private string? GetLabelAt(Vector2i position)
    {
        if (CurrentLabelMode == LabelMode.None)
            return null;

        if (CurrentLabelMode == LabelMode.Tactical)
            return TacticalLabels.GetValueOrDefault(position);

        if (CurrentLabelMode == LabelMode.Area)
            return _areaLabels.GetValueOrDefault(position);

        return TacticalLabels.GetValueOrDefault(position) ?? _areaLabels.GetValueOrDefault(position);
    }

    private Vector2i SnapToStraightLine(Vector2i start, Vector2i end)
    {
        int deltaX = end.X - start.X;
        int deltaY = end.Y - start.Y;
        int absDeltaX = Math.Abs(deltaX);
        int absDeltaY = Math.Abs(deltaY);

        if (absDeltaX > absDeltaY * 2)
        {
            return new Vector2i(end.X, start.Y);
        }
        else if (absDeltaY > absDeltaX * 2)
        {
            return new Vector2i(start.X, end.Y);
        }
        else
        {
            int diagDist = Math.Min(absDeltaX, absDeltaY);
            return new Vector2i(
                start.X + (deltaX >= 0 ? diagDist : -diagDist),
                start.Y + (deltaY >= 0 ? diagDist : -diagDist)
            );
        }
    }

    private void AddLineToCanvas(Vector2 start, Vector2 end)
    {
        Lines.Add(new TacticalMapLine(start, end, Color, LineThickness));
        LineThicknesses.Add(LineThickness);

        while (LineLimit >= 0 && Lines.Count > LineLimit)
        {
            Lines.RemoveAt(0);
            if (LineThicknesses.Count > 0)
                LineThicknesses.RemoveAt(0);
        }
    }

    private void ShowLabelInputDialog(Vector2i position, string existingText = "")
    {
        LabelTextDialog.Show(
            position,
            existingText,
            onConfirmed: text =>
            {
                if (string.IsNullOrWhiteSpace(text))
                {
                    if (!string.IsNullOrEmpty(existingText))
                        OnDeleteLabel?.Invoke(position);
                }
                else
                {
                    if (string.IsNullOrEmpty(existingText))
                        OnCreateLabel?.Invoke(position, text);
                    else
                        OnEditLabel?.Invoke(position, text);
                }
            },
            onDeleted: () => OnDeleteLabel?.Invoke(position)
        );
    }

    public void RequestTacticalLabelEditor(Vector2i position)
    {
        var existingText = TacticalLabels.GetValueOrDefault(position) ?? string.Empty;
        ShowLabelInputDialog(position, existingText);
    }

    protected override void Draw(DrawingHandleScreen handle)
    {
        if (Texture == null)
            return;

        SpriteSystem system = IoCManager.Resolve<IEntityManager>().System<SpriteSystem>();
        TimeSpan curTime = IoCManager.Resolve<IGameTiming>().CurTime;
        SpriteSpecifier.Rsi backgroundRsi = new(new ResPath("/Textures/_RMC14/Interface/map_blips.rsi"), "background");
        SpriteSpecifier.Rsi defibbableRsi = new(new ResPath("/Textures/_RMC14/Interface/map_blips.rsi"), "defibbable");
        SpriteSpecifier.Rsi defibbableRsi2 = new(new ResPath("/Textures/_RMC14/Interface/map_blips.rsi"), "defibbable2");
        SpriteSpecifier.Rsi defibbableRsi3 = new(new ResPath("/Textures/_RMC14/Interface/map_blips.rsi"), "defibbable3");
        SpriteSpecifier.Rsi defibbableRsi4 = new(new ResPath("/Textures/_RMC14/Interface/map_blips.rsi"), "defibbable4");
        SpriteSpecifier.Rsi undefibbableRsi = new(new ResPath("/Textures/_RMC14/Interface/map_blips.rsi"), "undefibbable");
        SpriteSpecifier.Rsi hiveLeaderRsi = new(new ResPath("/Textures/_RMC14/Interface/map_blips.rsi"), "xenoleader");
        Texture background = system.Frame0(backgroundRsi);

        (Vector2 actualSize, Vector2 actualTopLeft, float overlayScale) = GetDrawParameters();

        UIBox2 textureRect = UIBox2.FromDimensions(actualTopLeft, actualSize);
        if (_backgroundTexture != null)
            handle.DrawTextureRect(_backgroundTexture, textureRect);
        handle.DrawTextureRect(Texture, textureRect);

        DrawTileGrid(handle, actualTopLeft, actualSize);
        DrawModeBorder(handle, actualTopLeft, actualSize, overlayScale);
        DrawLines(handle, overlayScale, actualTopLeft);
        DrawPreviewLine(handle, overlayScale, actualTopLeft);
        DrawBlips(handle, system, background, defibbableRsi, defibbableRsi2, defibbableRsi3, defibbableRsi4, undefibbableRsi, hiveLeaderRsi, actualTopLeft, overlayScale, curTime);
        DrawEraserPreview(handle);
        DrawLabels(handle, overlayScale, actualTopLeft);
    }

    private void DrawTileGrid(DrawingHandleScreen handle, Vector2 actualTopLeft, Vector2 actualSize)
    {
        if (Texture == null || _tileMask == null)
            return;

        Vector2 textureSize = Texture.Size;
        if (textureSize.X <= 0 || textureSize.Y <= 0)
            return;

        if (_tileMaskWidth <= 0 || _tileMaskHeight <= 0)
            return;

        float tileWidth = actualSize.X / _tileMaskWidth;
        float tileHeight = actualSize.Y / _tileMaskHeight;
        float minTile = Math.Min(tileWidth, tileHeight);
        if (minTile < 1.5f)
            return;

        float thickness = Math.Clamp(minTile * 0.12f, 1f, 1.25f);
        if (thickness > minTile)
            thickness = minTile;
        Color gridColor = Color.FromHex("#88C7FA").WithAlpha(0.06f);

        int columns = _tileMaskWidth;
        int rows = _tileMaskHeight;

        for (int y = 0; y < rows; y++)
        {
            float yTop = actualTopLeft.Y + y * tileHeight;
            float yBottom = yTop + tileHeight;
            float yTopEdge = Math.Min(yTop + thickness, yBottom);
            float yBottomEdge = Math.Max(yBottom - thickness, yTop);

            for (int x = 0; x < columns; x++)
            {
                if (!IsTilePresent(x, y))
                    continue;

                float xLeft = actualTopLeft.X + x * tileWidth;
                float xRight = xLeft + tileWidth;
                float xLeftEdge = Math.Min(xLeft + thickness, xRight);
                float xRightEdge = Math.Max(xRight - thickness, xLeft);

                handle.DrawRect(new UIBox2(xLeft, yTop, xRight, yTopEdge), gridColor);
                handle.DrawRect(new UIBox2(xLeft, yTop, xLeftEdge, yBottom), gridColor);

                if (!IsTilePresent(x + 1, y))
                    handle.DrawRect(new UIBox2(xRightEdge, yTop, xRight, yBottom), gridColor);

                if (!IsTilePresent(x, y + 1))
                    handle.DrawRect(new UIBox2(xLeft, yBottomEdge, xRight, yBottom), gridColor);
            }
        }
    }

    private bool IsTilePresent(int x, int y)
    {
        if (_tileMask == null)
            return false;

        if ((uint)x >= (uint)_tileMaskWidth || (uint)y >= (uint)_tileMaskHeight)
            return false;

        return _tileMask[y * _tileMaskWidth + x];
    }

    private void DrawModeBorder(DrawingHandleScreen handle, Vector2 actualTopLeft, Vector2 actualSize, float overlayScale)
    {
        float borderWidth = 3f * overlayScale;
        UIBox2 rect = UIBox2.FromDimensions(actualTopLeft, actualSize);

        if (LabelEditMode)
        {
            Color borderColor = Color.Green.WithAlpha(0.3f);
            DrawBorder(handle, rect, borderColor, borderWidth);
        }

        if (QueenEyeMode)
        {
            Color borderColor = Color.Purple.WithAlpha(0.3f);
            DrawBorder(handle, rect, borderColor, borderWidth);
        }
    }

    private void DrawBorder(DrawingHandleScreen handle, UIBox2 rect, Color color, float width)
    {
        handle.DrawRect(new UIBox2(rect.Left, rect.Top, rect.Right, rect.Top + width), color);
        handle.DrawRect(new UIBox2(rect.Left, rect.Bottom - width, rect.Right, rect.Bottom), color);
        handle.DrawRect(new UIBox2(rect.Left, rect.Top, rect.Left + width, rect.Bottom), color);
        handle.DrawRect(new UIBox2(rect.Right - width, rect.Top, rect.Right, rect.Bottom), color);
    }

    private void DrawBlips(DrawingHandleScreen handle, SpriteSystem system, Texture background,
        SpriteSpecifier.Rsi defibbableRsi, SpriteSpecifier.Rsi defibbableRsi2, SpriteSpecifier.Rsi defibbableRsi3, SpriteSpecifier.Rsi defibbableRsi4,
        SpriteSpecifier.Rsi undefibbableRsi, SpriteSpecifier.Rsi hiveLeaderRsi, Vector2 actualTopLeft, float overlayScale, TimeSpan curTime)
    {
        if (_blips == null)
            return;

        for (int i = 0; i < _blips.Length; i++)
        {
            TacticalMapBlip blip = _blips[i];
            Vector2 position = IndicesToPosition(blip.Indices) * overlayScale + actualTopLeft;
            float scaledBlipSize = GetScaledBlipSize(overlayScale);
            UIBox2 rect = UIBox2.FromDimensions(position, new Vector2(scaledBlipSize, scaledBlipSize));

            handle.DrawTextureRect(blip.Background != null ? system.GetFrame(blip.Background, curTime) : background, rect, blip.Color);
            handle.DrawTextureRect(system.GetFrame(blip.Image, curTime), rect);

            if (_localPlayerEntityId.HasValue && _blipEntityIds != null && i < _blipEntityIds.Length)
            {
                if (_blipEntityIds[i] == _localPlayerEntityId.Value)
                {
                    DrawPingEffect(handle, position, scaledBlipSize, overlayScale, curTime, blip.Color);
                }
            }

            if (blip.HiveLeader)
                handle.DrawTextureRect(system.GetFrame(hiveLeaderRsi, curTime), rect);

            var defibTexture = blip.Status switch
            {
                TacticalMapBlipStatus.Defibabble => defibbableRsi,
                TacticalMapBlipStatus.Defibabble2 => defibbableRsi2,
                TacticalMapBlipStatus.Defibabble3 => defibbableRsi3,
                TacticalMapBlipStatus.Defibabble4 => defibbableRsi4,
                TacticalMapBlipStatus.Undefibabble => undefibbableRsi,
                _ => null,
            };
            if (defibTexture != null)
                handle.DrawTextureRect(system.GetFrame(defibTexture, curTime), rect);
        }
    }

    private void DrawPingEffect(DrawingHandleScreen handle, Vector2 center, float blipSize, float overlayScale, TimeSpan curTime, Color blipColor)
    {
        float totalSeconds = (float)curTime.TotalSeconds;
        float cycleProgress = (totalSeconds % PingDuration) / PingDuration;

        float scale = PingMinScale + (PingMaxScale - PingMinScale) * cycleProgress;
        float alpha = PingMaxAlpha - (PingMaxAlpha - PingMinAlpha) * cycleProgress;

        float ringSize = blipSize * scale;
        Vector2 ringCenter = center + new Vector2(blipSize / 2, blipSize / 2);

        Color pingColor = Color.FromHex("#00FFFF").WithAlpha(alpha);

        float thickness = PingRingThickness * overlayScale;
        int segments = 32;
        float angleStep = MathF.PI * 2 / segments;

        for (int i = 0; i < segments; i++)
        {
            float angle1 = i * angleStep;
            float angle2 = (i + 1) * angleStep;

            Vector2 outerP1 = ringCenter + new Vector2(MathF.Cos(angle1), MathF.Sin(angle1)) * (ringSize / 2);
            Vector2 outerP2 = ringCenter + new Vector2(MathF.Cos(angle2), MathF.Sin(angle2)) * (ringSize / 2);

            Vector2 innerP1 = ringCenter + new Vector2(MathF.Cos(angle1), MathF.Sin(angle1)) * (ringSize / 2 - thickness);
            Vector2 innerP2 = ringCenter + new Vector2(MathF.Cos(angle2), MathF.Sin(angle2)) * (ringSize / 2 - thickness);

            handle.DrawPrimitives(DrawPrimitiveTopology.TriangleList,
                new[] { outerP1, outerP2, innerP1, innerP1, outerP2, innerP2 },
                pingColor);
        }
    }


    private void DrawLines(DrawingHandleScreen handle, float overlayScale, Vector2 actualTopLeft)
    {
        int i = 0;
        float joinEpsilonSquared = LineJoinEpsilon * LineJoinEpsilon;

        while (i < Lines.Count)
        {
            TacticalMapLine line = Lines[i];
            float thickness = GetLineThickness(i, line);
            Color color = line.Color;

            var points = new List<Vector2> { line.Start, line.End };
            int j = i + 1;
            for (; j < Lines.Count; j++)
            {
                TacticalMapLine next = Lines[j];
                float nextThickness = GetLineThickness(j, next);

                if (next.Color != color || MathF.Abs(nextThickness - thickness) > 0.001f)
                    break;

                if ((points[^1] - next.Start).LengthSquared() > joinEpsilonSquared)
                    break;

                points.Add(next.End);
            }

            if (points.Count >= 3)
            {
                DrawSmoothPolyline(handle, points, color, thickness, overlayScale, actualTopLeft);
            }
            else
            {
                for (int p = 0; p < points.Count - 1; p++)
                {
                    DrawLineSegment(handle, points[p], points[p + 1], color, thickness, overlayScale, actualTopLeft, true);
                }
            }

            i = j;
        }
    }

    private void DrawPreviewLine(DrawingHandleScreen handle, float overlayScale, Vector2 actualTopLeft)
    {
        if (!_dragging || !Drawing || !StraightLineMode || _dragStart == null || _previewEnd == null || Texture == null)
            return;

        Vector2i diff = _previewEnd.Value - _dragStart.Value;
        if (diff.Length < MinDragDistance)
            return;

        Vector2i startIndices = PositionToIndices(PixelToLogical(new Vector2(_dragStart.Value.X, _dragStart.Value.Y)));
        Vector2i endIndices = PositionToIndices(PixelToLogical(new Vector2(_previewEnd.Value.X, _previewEnd.Value.Y)));

        endIndices = SnapToStraightLine(startIndices, endIndices);

        Vector2 lineStart = ConvertIndicesToLineCoordinates(startIndices);
        Vector2 lineEnd = ConvertIndicesToLineCoordinates(endIndices);
        TacticalMapLine previewLine = new(lineStart, lineEnd, Color.WithAlpha(0.5f), LineThickness);

        DrawLineWithThickness(handle, previewLine, overlayScale, actualTopLeft, LineThickness);
    }

    private void DrawEraserPreview(DrawingHandleScreen handle)
    {
        if (!Drawing || !EraserMode || _lastMousePosition == null)
            return;

        float radius = EraserRadiusPixels + LineThickness * 1.5f;
        Vector2 center = LogicalToPixel(_lastMousePosition.Value);
        handle.DrawCircle(center, radius, EraserPreviewColor);
    }

    private void DrawLabels(DrawingHandleScreen handle, float overlayScale, Vector2 actualTopLeft)
    {
        if (CurrentLabelMode == LabelMode.None)
            return;

        if (CurrentLabelMode == LabelMode.All)
        {
            foreach ((Vector2i indices, string label) in _areaLabels)
            {
                Vector2 position = IndicesToPosition(indices) * overlayScale + actualTopLeft;
                position = position with { Y = position.Y - LabelYOffset * overlayScale };
                DrawLabelAtPosition(handle, label, position, overlayScale, AreaLabelColor, AreaLabelBackground, false);

                if (TacticalLabels.TryGetValue(indices, out var tacticalLabel))
                {
                    Vector2 tacticalPosition = position + new Vector2(0f, LabelStackOffset * overlayScale);
                    if (_draggingLabel == indices && _currentDragPosition != null)
                    {
                        DrawLabelAtPosition(handle, tacticalLabel, _currentDragPosition.Value, overlayScale, TacticalLabelTextColor, TacticalLabelBackground, true);
                    }
                    else
                    {
                        DrawLabelAtPosition(handle, tacticalLabel, tacticalPosition, overlayScale, TacticalLabelTextColor, TacticalLabelBackground, false);
                    }
                }
            }

            foreach ((Vector2i indices, string label) in TacticalLabels)
            {
                if (_areaLabels.ContainsKey(indices))
                    continue;

                if (_draggingLabel == indices && _currentDragPosition != null)
                {
                    DrawLabelAtPosition(handle, label, _currentDragPosition.Value, overlayScale, TacticalLabelTextColor, TacticalLabelBackground, true);
                }
                else
                {
                    Vector2 position = IndicesToPosition(indices) * overlayScale + actualTopLeft;
                    position = position with { Y = position.Y - LabelYOffset * overlayScale };
                    DrawLabelAtPosition(handle, label, position, overlayScale, TacticalLabelTextColor, TacticalLabelBackground, false);
                }
            }

            return;
        }

        bool isTactical = CurrentLabelMode == LabelMode.Tactical;
        var labelsToDisplay = isTactical ? TacticalLabels : _areaLabels;
        var textColor = isTactical ? TacticalLabelTextColor : AreaLabelColor;
        var backgroundColor = isTactical ? TacticalLabelBackground : AreaLabelBackground;

        foreach ((Vector2i indices, string label) in labelsToDisplay)
        {
            if (isTactical && _draggingLabel == indices && _currentDragPosition != null)
            {
                DrawLabelAtPosition(handle, label, _currentDragPosition.Value, overlayScale, textColor, backgroundColor, true);
                continue;
            }

            Vector2 position = IndicesToPosition(indices) * overlayScale + actualTopLeft;
            position = position with { Y = position.Y - LabelYOffset * overlayScale };
            DrawLabelAtPosition(handle, label, position, overlayScale, textColor, backgroundColor, false);
        }
    }

    private void DrawLabelAtPosition(
        DrawingHandleScreen handle,
        string label,
        Vector2 position,
        float overlayScale,
        Color textColor,
        Color backgroundColor,
        bool isDragging)
    {
        float fontSize = Math.Max(LabelMinFontSize, overlayScale * LabelFontScale);
        VectorFont labelFont = new(_resourceCache.GetResource<FontResource>("/Fonts/NotoSans/NotoSans-Bold.ttf"), (int)fontSize);

        Vector2 textSize = handle.GetDimensions(labelFont, label, 1f);
        position -= textSize / 2;

        float padding = LabelPadding * overlayScale;
        Vector2 boxSize = textSize + new Vector2(padding * 2f, padding * 2f);

        Color bgColor = isDragging ? LabelDragBackground : backgroundColor;
        if (bgColor.A > 0)
            handle.DrawRect(UIBox2.FromDimensions(position - new Vector2(padding, padding), boxSize), bgColor);

        handle.DrawString(labelFont, position, label, textColor);
    }

    private void DrawLineWithThickness(DrawingHandleScreen handle, TacticalMapLine line, float overlayScale, Vector2 actualTopLeft, float thickness)
    {
        DrawLineSegment(handle, line.Start, line.End, line.Color, thickness, overlayScale, actualTopLeft, true);
    }

    private void UpdateHoverInfo(Vector2 controlPosition)
    {
        if (OnHoverAreaInfo == null || Texture == null)
            return;

        Vector2i indices = PositionToIndices(controlPosition);
        if (!IsWithinMap(indices))
        {
            ClearHoverInfo();
            return;
        }

        if (_lastHoverIndices == indices)
            return;

        _lastHoverIndices = indices;

        TacticalMapAreaInfo info;
        if (!TryGetAreaInfo(indices, out info))
            info = CreateFallbackAreaInfo(indices);

        OnHoverAreaInfo?.Invoke(info);
    }

    private void ClearHoverInfo()
    {
        if (_lastHoverIndices == null)
            return;

        _lastHoverIndices = null;
        OnHoverAreaInfo?.Invoke(null);
    }

    private bool IsWithinMap(Vector2i indices)
    {
        if (_tileMaskWidth <= 0 || _tileMaskHeight <= 0)
            return true;

        Vector2i drawPosition = GetDrawPosition(indices);
        return drawPosition.X >= 0 && drawPosition.Y >= 0 &&
               drawPosition.X < _tileMaskWidth && drawPosition.Y < _tileMaskHeight;
    }

    private static TacticalMapAreaInfo CreateFallbackAreaInfo(Vector2i indices)
    {
        return new TacticalMapAreaInfo(
            indices,
            Loc.GetString("rmc-tacmap-alert-no-area"),
            null,
            null,
            null,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            null);
    }

    private void DrawLineSegment(
        DrawingHandleScreen handle,
        Vector2 start,
        Vector2 end,
        Color color,
        float thickness,
        float overlayScale,
        Vector2 actualTopLeft,
        bool drawCaps)
    {
        Vector2 startScreen = start * overlayScale + actualTopLeft;
        Vector2 endScreen = end * overlayScale + actualTopLeft;
        Vector2 diff = endScreen - startScreen;

        float actualThickness = thickness * overlayScale;
        float softThickness = actualThickness + LineSoftEdgePixels;
        Color softColor = color.WithAlpha(color.A * LineSoftEdgeAlpha);

        if (diff.Length() < 1.0f)
        {
            if (!drawCaps)
                return;

            DrawLineCap(handle, startScreen, softThickness, softColor);
            DrawLineCap(handle, startScreen, actualThickness, color);
            return;
        }

        DrawLineBox(handle, startScreen, diff, softThickness, softColor);
        DrawLineBox(handle, startScreen, diff, actualThickness, color);

        if (drawCaps)
        {
            DrawLineCap(handle, startScreen, softThickness, softColor);
            DrawLineCap(handle, endScreen, softThickness, softColor);
            DrawLineCap(handle, startScreen, actualThickness, color);
            DrawLineCap(handle, endScreen, actualThickness, color);
        }
    }

    private void DrawLineCaps(
        DrawingHandleScreen handle,
        Vector2 start,
        Vector2 end,
        Color color,
        float thickness,
        float overlayScale,
        Vector2 actualTopLeft)
    {
        Vector2 startScreen = start * overlayScale + actualTopLeft;
        Vector2 endScreen = end * overlayScale + actualTopLeft;

        float actualThickness = thickness * overlayScale;
        float softThickness = actualThickness + LineSoftEdgePixels;
        Color softColor = color.WithAlpha(color.A * LineSoftEdgeAlpha);

        DrawLineCap(handle, startScreen, softThickness, softColor);
        DrawLineCap(handle, endScreen, softThickness, softColor);
        DrawLineCap(handle, startScreen, actualThickness, color);
        DrawLineCap(handle, endScreen, actualThickness, color);
    }

    private void DrawSmoothPolyline(
        DrawingHandleScreen handle,
        List<Vector2> points,
        Color color,
        float thickness,
        float overlayScale,
        Vector2 actualTopLeft)
    {
        if (points.Count < 2)
            return;

        float step = SmoothSamplePixels / Math.Max(overlayScale, 0.001f);
        Vector2? previous = null;

        for (int i = 0; i < points.Count - 1; i++)
        {
            Vector2 p0 = i > 0 ? points[i - 1] : points[i];
            Vector2 p1 = points[i];
            Vector2 p2 = points[i + 1];
            Vector2 p3 = i + 2 < points.Count ? points[i + 2] : points[i + 1];

            float segmentLength = (p2 - p1).Length();
            int steps = Math.Max(1, (int)MathF.Ceiling(segmentLength / step));

            for (int s = 0; s <= steps; s++)
            {
                float t = s / (float)steps;
                Vector2 position = CatmullRom(p0, p1, p2, p3, t);

                if (previous != null)
                    DrawLineSegment(handle, previous.Value, position, color, thickness, overlayScale, actualTopLeft, false);

                previous = position;
            }
        }

        DrawLineCaps(handle, points[0], points[^1], color, thickness, overlayScale, actualTopLeft);
    }

    private static Vector2 CatmullRom(Vector2 p0, Vector2 p1, Vector2 p2, Vector2 p3, float t)
    {
        float t2 = t * t;
        float t3 = t2 * t;

        return 0.5f * (
            (2f * p1) +
            (-p0 + p2) * t +
            (2f * p0 - 5f * p1 + 4f * p2 - p3) * t2 +
            (-p0 + 3f * p1 - 3f * p2 + p3) * t3
        );
    }

    private float GetLineThickness(int index, TacticalMapLine line)
    {
        return line.Thickness > 0
            ? line.Thickness
            : (index < LineThicknesses.Count ? LineThicknesses[index] : 2.0f);
    }

    private void DrawLineBox(DrawingHandleScreen handle, Vector2 start, Vector2 diff, float thickness, Color color)
    {
        if (diff.Length() < 0.001f)
            return;

        Vector2 center = start + diff / 2;
        Box2 box = Box2.CenteredAround(center, new Vector2(thickness, diff.Length()));
        Box2Rotated boxRotated = new(box, diff.ToWorldAngle(), center);

        _reusableLineVectors[0] = boxRotated.BottomLeft;
        _reusableLineVectors[1] = boxRotated.BottomRight;
        _reusableLineVectors[2] = boxRotated.TopRight;
        _reusableLineVectors[3] = boxRotated.BottomLeft;
        _reusableLineVectors[4] = boxRotated.TopLeft;
        _reusableLineVectors[5] = boxRotated.TopRight;

        handle.DrawPrimitives(DrawPrimitiveTopology.TriangleList, _reusableLineVectors, color);
    }

    private void DrawLineCap(DrawingHandleScreen handle, Vector2 position, float thickness, Color color)
    {
        float radius = thickness / 2f;
        if (radius <= 0.01f)
            return;

        handle.DrawCircle(position, radius, color);
    }

    protected override void KeyBindDown(GUIBoundKeyEventArgs args)
    {
        base.KeyBindDown(args);

        if (args.Function == EngineKeyFunctions.UIClick)
        {
            if (HandleQueenEyeClick(args))
                return;

            if (HandleLabelClick(args))
                return;

            if (HandleBlipClick(args))
                return;

            HandleDrawingClick(args);
        }
        else if (args.Function == EngineKeyFunctions.UIRightClick)
        {
            HandlePanningStart(args);
        }
    }

    private bool HandleQueenEyeClick(GUIBoundKeyEventArgs args)
    {
        if (QueenEyeMode && !Drawing && !IsCanvas)
        {
            Vector2i clickPosition = PositionToIndices(args.RelativePosition);
            OnQueenEyeMove?.Invoke(clickPosition);
            args.Handle();
            return true;
        }
        return false;
    }

    private bool HandleLabelClick(GUIBoundKeyEventArgs args)
    {
        if (!LabelEditMode || !Drawing || CurrentLabelMode == LabelMode.None)
            return false;

        Vector2i? labelPosition = GetLabelAtPosition(args.RelativePosition);
        if (labelPosition != null)
        {
            if (CurrentLabelMode == LabelMode.Tactical)
            {
                _draggingLabel = labelPosition;
                _labelDragStart = LogicalToPixel(args.RelativePosition).Floored();
                _currentDragPosition = LogicalToPixel(args.RelativePosition);
            }
            args.Handle();
            return true;
        }

        Vector2i clickPosition = PositionToIndices(args.RelativePosition);
        ShowLabelInputDialog(clickPosition);
        args.Handle();
        return true;
    }

    private bool HandleBlipClick(GUIBoundKeyEventArgs args)
    {
        TacticalMapBlip? clickedBlip = GetBlipAtPosition(args.RelativePosition);
        if (clickedBlip != null && !Drawing && !QueenEyeMode)
        {
            OnBlipClicked?.Invoke(clickedBlip.Value.Indices);
            args.Handle();
            return true;
        }
        return false;
    }

    private void HandleDrawingClick(GUIBoundKeyEventArgs args)
    {
        HideTunnelInfo();

        if (Drawing && !LabelEditMode)
        {
            _dragging = true;
            Vector2 startPixel = LogicalToPixel(args.RelativePosition);
            _dragStart = startPixel.Floored();
            _lastDrag = _dragStart;
            _previewEnd = _dragStart;
            _lastErasePosition = null;

            if (EraserMode)
            {
                _lastErasePosition = startPixel;
                TryEraseAt(args.RelativePosition);
            }

            OnUserInteraction?.Invoke();
            args.Handle();
        }
    }

    private bool HandleLabelRightClick(GUIBoundKeyEventArgs args)
    {
        Vector2i? labelPosition = GetTacticalLabelAtPosition(args.RelativePosition);
        if (labelPosition == null)
            return false;

        string? existingText = TacticalLabels.GetValueOrDefault(labelPosition.Value);
        if (string.IsNullOrWhiteSpace(existingText))
            return false;

        ShowLabelInputDialog(labelPosition.Value, existingText);
        args.Handle();
        return true;
    }

    private bool HandleBlipRightClick(GUIBoundKeyEventArgs args)
    {
        TacticalMapBlip? clickedBlip = GetBlipAtPosition(args.RelativePosition);
        if (clickedBlip != null && OnBlipRightClicked != null)
        {
            OnBlipRightClicked.Invoke(clickedBlip.Value.Indices, "");
            args.Handle();
            return true;
        }
        return false;
    }

    private void HandleRightClickAction(GUIBoundKeyEventArgs args)
    {
        if (HandleLabelRightClick(args))
            return;

        if (HandleBlipRightClick(args))
            return;

        HandleContextMenuRequest(args);
    }

    private bool HandleContextMenuRequest(GUIBoundKeyEventArgs args)
    {
        if (OnContextMenuRequested == null || Texture == null)
            return false;

        Vector2i clickPosition = PositionToIndices(args.RelativePosition);
        OnContextMenuRequested.Invoke(this, clickPosition, args.PointerLocation.Position);
        args.Handle();
        return true;
    }

    private void HandlePanningStart(GUIBoundKeyEventArgs args)
    {
        HideTunnelInfo();
        _rightClickPanning = true;
        _rightClickMoved = false;
        _rightClickStartPosition = LogicalToPixel(args.RelativePosition);
        _lastPanPosition = _rightClickStartPosition;
        args.Handle();
    }

    protected override void KeyBindUp(GUIBoundKeyEventArgs args)
    {
        base.KeyBindUp(args);

        if (args.Function == EngineKeyFunctions.UIClick)
        {
            if (_draggingLabel != null && _labelDragStart != null && _currentDragPosition != null)
            {
                Vector2 currentPixelPos = LogicalToPixel(args.RelativePosition);
                Vector2 dragDiff = currentPixelPos - _labelDragStart.Value;

                if (dragDiff.Length() > MinDragDistance)
                {
                    Vector2i newPosition = PositionToIndices(args.RelativePosition);
                    OnMoveLabel?.Invoke(_draggingLabel.Value, newPosition);
                }
                else
                {
                    string? existingText = GetLabelAt(_draggingLabel.Value);
                    if (existingText != null)
                    {
                        ShowLabelInputDialog(_draggingLabel.Value, existingText);
                    }
                }

                _draggingLabel = null;
                _labelDragStart = null;
                _currentDragPosition = null;
                args.Handle();
            }
            else if (_dragging && Drawing && !LabelEditMode)
            {
                if (!EraserMode && _dragStart != null && StraightLineMode)
                {
                    Vector2i currentPos = LogicalToPixel(args.RelativePosition).Floored();
                    Vector2i diff = currentPos - _dragStart.Value;

                    if (diff.Length >= MinDragDistance)
                    {
                        Vector2i startIndices = PositionToIndices(PixelToLogical(new Vector2(_dragStart.Value.X, _dragStart.Value.Y)));
                        Vector2i endIndices = PositionToIndices(args.RelativePosition);

                        if (StraightLineMode)
                            endIndices = SnapToStraightLine(startIndices, endIndices);

                        Vector2 lineStart = ConvertIndicesToLineCoordinates(startIndices);
                        Vector2 lineEnd = ConvertIndicesToLineCoordinates(endIndices);
                        AddLineToCanvas(lineStart, lineEnd);
                    }
                }

                _dragging = false;
                _lastDrag = null;
                _dragStart = null;
                _previewEnd = null;
                _lastErasePosition = null;
                args.Handle();
            }
        }
        else if (args.Function == EngineKeyFunctions.UIRightClick)
        {
            if (!_rightClickMoved)
                HandleRightClickAction(args);

            _rightClickPanning = false;
            _lastPanPosition = null;
            _rightClickStartPosition = null;
            _rightClickMoved = false;
            args.Handle();
        }
    }

    protected override void MouseMove(GUIMouseMoveEventArgs args)
    {
        base.MouseMove(args);

        _lastMousePosition = args.RelativePosition;

        if (_draggingLabel != null)
        {
            _currentDragPosition = LogicalToPixel(args.RelativePosition);
            args.Handle();
        }
        else if (_dragging && Drawing && !LabelEditMode)
        {
            Vector2 currentPixelPos = LogicalToPixel(args.RelativePosition);
            Vector2i currentPos = currentPixelPos.Floored();

            if (EraserMode)
            {
                if (_lastErasePosition == null ||
                    (currentPixelPos - _lastErasePosition.Value).Length() >= MinEraserSegmentPixels)
                {
                    TryEraseAt(args.RelativePosition);
                    _lastErasePosition = currentPixelPos;
                }
            }
            else if (StraightLineMode)
            {
                _previewEnd = currentPos;
            }
            else
            {
                if (_lastDrag != null)
                {
                    Vector2i diff = currentPos - _lastDrag.Value;
                    if (diff.Length >= MinDragDistance)
                    {
                        if (Texture == null)
                            return;

                        (_, Vector2 actualTopLeft, float overlayScale) = GetDrawParameters();
                        float minSegment = MinFreehandSegmentPixels / Math.Max(overlayScale, 0.001f);

                        Vector2 lineStart = PositionToLineCoordinatesFloat(
                            PixelToLogical(new Vector2(_lastDrag.Value.X, _lastDrag.Value.Y)),
                            actualTopLeft,
                            overlayScale);
                        Vector2 lineEnd = PositionToLineCoordinatesFloat(
                            args.RelativePosition,
                            actualTopLeft,
                            overlayScale);

                        Vector2 delta = lineEnd - lineStart;
                        float distance = delta.Length();
                        if (distance >= minSegment)
                        {
                            int steps = (int)MathF.Ceiling(distance / minSegment);
                            Vector2 step = delta / steps;
                            Vector2 prev = lineStart;
                            for (int i = 1; i <= steps; i++)
                            {
                                Vector2 next = lineStart + step * i;
                                AddLineSegment(prev, next);
                                prev = next;
                            }
                        }
                        _lastDrag = currentPos;
                    }
                }
            }
            args.Handle();
        }
        else if (_rightClickPanning && _lastPanPosition != null)
        {
            Vector2 currentPixelPos = LogicalToPixel(args.RelativePosition);

            if (_rightClickStartPosition == null)
            {
                _rightClickStartPosition = currentPixelPos;
                _lastPanPosition = currentPixelPos;
            }

            if (!_rightClickMoved)
            {
                if ((currentPixelPos - _rightClickStartPosition.Value).Length() < MinDragDistance)
                    return;

                _rightClickMoved = true;
                _lastPanPosition = currentPixelPos;
            }

            Vector2 panDelta = currentPixelPos - _lastPanPosition.Value;

            _panOffset += panDelta;
            ApplyViewSettings();
            NotifyViewChanged();

            _lastPanPosition = currentPixelPos;
            args.Handle();
        }

        UpdateHoverInfo(args.RelativePosition);
    }

    protected override void MouseExited()
    {
        base.MouseExited();
        _lastMousePosition = null;
        ClearHoverInfo();
    }

    protected override void MouseWheel(GUIMouseWheelEventArgs args)
    {
        base.MouseWheel(args);

        if (Texture == null)
            return;

        Vector2 mousePixelPos = LogicalToPixel(args.RelativePosition);
        (Vector2 oldActualSize, Vector2 oldActualTopLeft, float oldOverlayScale) = GetDrawParameters();

        float oldZoom = _zoomFactor;

        if (args.Delta.Y > 0)
            _zoomFactor *= ZoomSpeed;
        else if (args.Delta.Y < 0)
            _zoomFactor /= ZoomSpeed;

        _zoomFactor = Math.Clamp(_zoomFactor, MinZoom, MaxZoom);

        if (Math.Abs(_zoomFactor - oldZoom) > 0.001f)
        {
            Vector2 relativeToTexture = (mousePixelPos - oldActualTopLeft) / oldOverlayScale;

            ApplyViewSettings();

            (Vector2 newActualSize, Vector2 newActualTopLeft, float newOverlayScale) = GetDrawParameters();
            Vector2 newMousePos = relativeToTexture * newOverlayScale + newActualTopLeft;
            Vector2 mouseDelta = mousePixelPos - newMousePos;

            _panOffset += mouseDelta;
            ApplyViewSettings();
            NotifyViewChanged();
        }

        args.Handle();
    }

    public void RemoveLinesByColor(Color color)
    {
        for (int i = Lines.Count - 1; i >= 0; i--)
        {
            if (Lines[i].Color == color)
            {
                Lines.RemoveAt(i);
                if (i < LineThicknesses.Count)
                    LineThicknesses.RemoveAt(i);
            }
        }
    }

    public void AddDashedTunnelPath(List<Vector2i> waypoints, Color pathColor, bool removeExisting = true)
    {
        if (removeExisting)
            RemoveLinesByColor(pathColor);

        if (waypoints.Count < 2)
            return;

        if (waypoints.Count == 2)
        {
            Vector2 startPos = ConvertIndicesToLineCoordinates(waypoints[0]);
            Vector2 endPos = ConvertIndicesToLineCoordinates(waypoints[1]);
            float distance = Vector2.Distance(startPos, endPos);
            float scaledBlipSize = BaseBlipSize;

            if (distance < scaledBlipSize * 1.2f)
                return;
        }

        for (int i = 0; i < waypoints.Count - 1; i++)
        {
            Vector2i start = waypoints[i];
            Vector2i end = waypoints[i + 1];

            Vector2 fromPoint = GetEdgePoint(start, end, true);
            Vector2 toPoint = GetEdgePoint(start, end, false);

            if (i == waypoints.Count - 2)
            {
                Vector2 direction = toPoint - fromPoint;
                float lineLength = direction.Length();

                if (lineLength > 0f)
                {
                    float scaledBlipSize = BaseBlipSize;
                    float arrowStartOffset = scaledBlipSize * 0.45f + ArrowLength;

                    if (lineLength > arrowStartOffset)
                    {
                        toPoint -= direction / lineLength * arrowStartOffset;
                    }
                }
            }

            AddDashedSegment(fromPoint, toPoint, pathColor);
        }

        if (waypoints.Count >= 2)
        {
            AddSimpleArrowHead(
                ConvertIndicesToLineCoordinates(waypoints[^2]),
                ConvertIndicesToLineCoordinates(waypoints[^1]),
                pathColor
            );
        }
    }

    public void AddDashedTunnelPathClosest(List<Vector2i> waypoints, Color pathColor, bool removeExisting = true)
    {
        if (removeExisting)
            RemoveLinesByColor(pathColor);

        if (waypoints.Count < 2)
            return;

        if (waypoints.Count == 2)
        {
            Vector2 startPos = ConvertIndicesToLineCoordinates(waypoints[0]);
            Vector2 endPos = ConvertIndicesToLineCoordinates(waypoints[1]);
            float distance = Vector2.Distance(startPos, endPos);
            float scaledBlipSize = BaseBlipSize;

            if (distance < scaledBlipSize * 1.2f)
                return;
        }

        for (int i = 0; i < waypoints.Count - 1; i++)
        {
            Vector2 fromPoint = GetClosestEdgePoint(waypoints[i], waypoints[i + 1], true);
            Vector2 toPoint = GetClosestEdgePoint(waypoints[i], waypoints[i + 1], false);

            if (i == waypoints.Count - 2)
            {
                Vector2 direction = toPoint - fromPoint;
                float lineLength = direction.Length();

                if (lineLength > 0f)
                {
                    float scaledBlipSize = BaseBlipSize;
                    float arrowStartOffset = scaledBlipSize * 0.45f + ArrowLength;

                    if (lineLength > arrowStartOffset)
                    {
                        toPoint -= direction / lineLength * arrowStartOffset;
                    }
                }
            }

            AddDashedSegment(fromPoint, toPoint, pathColor);
        }

        if (waypoints.Count >= 2)
        {
            AddSimpleArrowHead(
                ConvertIndicesToLineCoordinates(waypoints[^2]),
                ConvertIndicesToLineCoordinates(waypoints[^1]),
                pathColor
            );
        }
    }

    private Vector2 GetClosestEdgePoint(Vector2i fromIndices, Vector2i toIndices, bool getFromPoint)
    {
        Vector2 fromUI = ConvertIndicesToLineCoordinates(fromIndices);
        Vector2 toUI = ConvertIndicesToLineCoordinates(toIndices);
        Vector2 sourcePoint = getFromPoint ? fromUI : toUI;
        Vector2 targetPoint = getFromPoint ? toUI : fromUI;
        Vector2 direction = targetPoint - sourcePoint;
        float distance = direction.Length();

        if (distance == 0f)
            return sourcePoint;

        float edgeOffset = BaseBlipSize * BlipEdgeRatio;
        if (distance < edgeOffset * CloseBlipThreshold)
            edgeOffset = edgeOffset * (distance / (edgeOffset * CloseBlipThreshold)) * CloseBlipSafety;

        return sourcePoint + direction / distance * edgeOffset;
    }

    private Vector2 GetEdgePoint(Vector2i fromIndices, Vector2i toIndices, bool getFromPoint)
    {
        Vector2 fromUI = ConvertIndicesToLineCoordinates(fromIndices);
        Vector2 toUI = ConvertIndicesToLineCoordinates(toIndices);
        Vector2 sourcePoint = getFromPoint ? fromUI : toUI;
        Vector2 targetPoint = getFromPoint ? toUI : fromUI;
        Vector2 direction = targetPoint - sourcePoint;
        float distance = direction.Length();

        if (distance == 0f)
            return sourcePoint;

        float scaledBlipSize = BaseBlipSize;
        float edgeOffset = scaledBlipSize * 0.4f;
        float minOffset = scaledBlipSize * 0.2f;

        if (distance < scaledBlipSize * 1.5f)
        {
            edgeOffset = Math.Max(minOffset, distance * 0.3f);
        }

        return sourcePoint + direction / distance * edgeOffset;
    }

    private void AddDashedSegment(Vector2 fromUI, Vector2 toUI, Color color)
    {
        Vector2 direction = toUI - fromUI;
        float totalLength = direction.Length();

        if (totalLength < 1f)
            return;

        for (float distance = 0; distance < totalLength; distance += DashLength + GapLength)
        {
            Lines.Add(new TacticalMapLine(
                fromUI + direction / totalLength * distance,
                fromUI + direction / totalLength * Math.Min(distance + DashLength, totalLength),
                color,
                LineThickness
            ));
            LineThicknesses.Add(LineThickness);
        }
    }

    private void AddSimpleArrowHead(Vector2 start, Vector2 end, Color color)
    {
        Vector2 direction = end - start;
        float length = direction.Length();

        if (length < 10f)
            return;

        float scaledBlipSize = BaseBlipSize;
        float blipEdgeOffset = scaledBlipSize * 0.45f;

        Vector2 arrowTip = end - direction / length * blipEdgeOffset;

        Vector2 arrowBase = arrowTip - direction / length * ArrowLength;

        Vector2 perp = new(-direction.Y / length, direction.X / length);

        Vector2 leftWing = arrowBase + perp * ArrowWidth;

        Vector2 rightWing = arrowBase - perp * ArrowWidth;

        Lines.Add(new TacticalMapLine(arrowTip, leftWing, color, LineThickness));
        LineThicknesses.Add(LineThickness);
        Lines.Add(new TacticalMapLine(arrowTip, rightWing, color, LineThickness));
        LineThicknesses.Add(LineThickness);
        Lines.Add(new TacticalMapLine(leftWing, rightWing, color, LineThickness));
        LineThicknesses.Add(LineThickness);
    }
}
