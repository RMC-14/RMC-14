using System.Numerics;
using Content.Shared._RMC14.Areas;
using Content.Shared._RMC14.TacticalMap;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.Graphics;
using Robust.Client.ResourceManagement;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Input;
using Robust.Shared.Maths;
using Robust.Shared.Utility;
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.PixelFormats;
using Color = Robust.Shared.Maths.Color;

namespace Content.Client._RMC14.TacticalMap;

[GenerateTypedNameReferences]
public sealed partial class TacticalMapControl : TextureRect
{
    [Dependency] private readonly IResourceCache _resourceCache = default!;

    private TacticalMapBlip[]? _blips;
    private Dictionary<Vector2i, string>? _labels;
    private Vector2i _min;
    private Vector2i _delta;
    private bool _dragging;
    private Vector2i? _lastDrag;
    private readonly Font _font;
    public readonly List<TacticalMapLine> Lines = new();
    public int LineLimit;
    public bool Drawing { get; set; }
    public bool DrawAreaLabels { get; set; } = true;
    public Color Color;

    public Action<Vector2i>? OnBlipClicked;
    public Action<Vector2i, string>? OnBlipRightClicked;

    private Label? _tunnelInfoLabel;
    private readonly Vector2[] _reusableLineVectors = new Vector2[6];

    private const float MAP_SCALE = 3f;
    private const float BASE_BLIP_SIZE = 14f;
    private const float CLICK_TOLERANCE = 8f;
    private const float BLIP_EDGE_RATIO = 0.7f;
    private const float CLOSE_BLIP_THRESHOLD = 2.2f;
    private const float CLOSE_BLIP_SAFETY = 0.8f;
    private const int DASH_LENGTH = 6;
    private const int GAP_LENGTH = 3;
    private const int ARROW_LENGTH = 15;
    private const int ARROW_WIDTH = 8;
    private const float MIN_DRAG_DISTANCE = 10f;
    private const float LABEL_Y_OFFSET = 6f;

    public TacticalMapControl()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
        _font = new VectorFont(_resourceCache.GetResource<FontResource>("/Fonts/NotoSans/NotoSans-Bold.ttf"), 10);

        _tunnelInfoLabel = new Label
        {
            Visible = false,
            StyleClasses = { "LabelHeading" },
            FontColorOverride = Color.Black,
            Margin = new Thickness(8, 8),
            HorizontalAlignment = Control.HAlignment.Center,
            VerticalAlignment = Control.VAlignment.Center
        };

        AddChild(_tunnelInfoLabel);
    }

    public void UpdateTexture(Entity<AreaGridComponent> grid)
    {
        if (grid.Comp.Colors.Count == 0) return;

        _min = Vector2i.Zero;
        var max = Vector2i.Zero;
        foreach (var position in grid.Comp.Colors.Keys)
        {
            _min = Vector2i.ComponentMin(_min, position);
            max = Vector2i.ComponentMax(max, position);
        }

        if (max.X - _min.X <= 0 || max.Y - _min.Y <= 0) return;

        _delta = max - _min;
        var image = new Image<Rgba32>(_delta.X + 1, _delta.Y + 1);
        foreach (var (position, color) in grid.Comp.Colors)
        {
            var (x, y) = GetDrawPosition(position);
            image[x, y] = new Rgba32(color.R, color.G, color.B, color.A);
        }

        Texture = Texture.LoadFromImage(image);
        _labels = new Dictionary<Vector2i, string>(grid.Comp.Labels);
    }

    public void UpdateBlips(TacticalMapBlip[]? blips)
    {
        _blips = blips;
    }

    private Vector2i GetDrawPosition(Vector2i pos)
    {
        return new Vector2i(pos.X - _min.X, _delta.Y - (pos.Y - _min.Y));
    }

    public Vector2 IndicesToPosition(Vector2i indices)
    {
        return GetDrawPosition(indices) * MAP_SCALE;
    }

    public Vector2i PositionToIndices(Vector2 screenPosition)
    {
        var relativePos = screenPosition / MAP_SCALE;
        return new Vector2i(
            (int)relativePos.X + _min.X,
            _delta.Y - (int)relativePos.Y + _min.Y
        );
    }

    private TacticalMapBlip? GetBlipAtPosition(Vector2 controlPosition)
    {
        if (_blips == null || Texture == null) return null;

        var draw = GetDrawDimensions(Texture);
        var screenPosition = controlPosition * UIScale;
        var clickTolerance = CLICK_TOLERANCE * UIScale;

        foreach (var blip in _blips)
        {
            var blipRect = UIBox2.FromDimensions(
                IndicesToPosition(blip.Indices) * UIScale + new Vector2(draw.Left, draw.Top) - new Vector2(clickTolerance, clickTolerance),
                new Vector2(BASE_BLIP_SIZE * UIScale + clickTolerance * 2, BASE_BLIP_SIZE * UIScale + clickTolerance * 2)
            );

            if (blipRect.Contains(screenPosition))
                return blip;
        }

        return null;
    }

    protected override void Draw(DrawingHandleScreen handle)
    {
        base.Draw(handle);
        if (Texture == null) return;

        var system = IoCManager.Resolve<IEntityManager>().System<SpriteSystem>();
        var backgroundRsi = new SpriteSpecifier.Rsi(new ResPath("_RMC14/Interface/map_blips.rsi"), "background");
        var defibbableRsi = new SpriteSpecifier.Rsi(new ResPath("_RMC14/Interface/map_blips.rsi"), "defibbable");
        var undefibbableRsi = new SpriteSpecifier.Rsi(new ResPath("_RMC14/Interface/map_blips.rsi"), "undefibbable");
        var hiveLeaderRsi = new SpriteSpecifier.Rsi(new ResPath("_RMC14/Interface/map_blips.rsi"), "xenoleader");
        var background = system.Frame0(backgroundRsi);
        var draw = GetDrawDimensions(Texture);
        var offset = new Vector2(draw.Left, draw.Top);
        if (_blips != null)
        {
            foreach (var blip in _blips)
            {
                var position = IndicesToPosition(blip.Indices) * UIScale + offset;
                var scaledBlipSize = BASE_BLIP_SIZE * UIScale;
                var rect = UIBox2.FromDimensions(position, new Vector2(scaledBlipSize, scaledBlipSize));

                handle.DrawTextureRect(blip.Background != null ? system.Frame0(blip.Background) : background, rect, blip.Color);
                handle.DrawTextureRect(system.Frame0(blip.Image), rect);

                if (blip.HiveLeader)
                    handle.DrawTextureRect(system.Frame0(hiveLeaderRsi), rect);

                switch (blip.Status)
                {
                    case TacticalMapBlipStatus.Defibabble:
                        handle.DrawTextureRect(system.Frame0(defibbableRsi), rect);
                        break;
                    case TacticalMapBlipStatus.Undefibabble:
                        handle.DrawTextureRect(system.Frame0(undefibbableRsi), rect);
                        break;
                }
            }
        }

        var lineVectors = new Vector2[6];
        foreach (var line in Lines)
        {
            var start = new Vector2(line.Start.X, line.Start.Y) * UIScale + offset;
            var end = new Vector2(line.End.X, line.End.Y) * UIScale + offset;
            var diff = end - start;
            var box = Box2.CenteredAround(start + diff / 2, new Vector2(5, (int)diff.Length()));
            var boxRotated = new Box2Rotated(box, diff.ToWorldAngle(), start + diff / 2);
            lineVectors[0] = boxRotated.BottomLeft;
            lineVectors[1] = boxRotated.BottomRight;
            lineVectors[2] = boxRotated.TopRight;
            lineVectors[3] = boxRotated.BottomLeft;
            lineVectors[4] = boxRotated.TopLeft;
            lineVectors[5] = boxRotated.TopRight;
            handle.DrawPrimitives(DrawPrimitiveTopology.TriangleList, lineVectors, line.Color);
        }

        if (_labels != null && DrawAreaLabels)
        {
            foreach (var (indices, label) in _labels)
            {
                var position = IndicesToPosition(indices) * UIScale + offset;

                // Center vertically
                position = position with { Y = position.Y - LABEL_Y_OFFSET * UIScale };

                // Get text size
                var drawn = handle.DrawString(_font, position, label, Color.Transparent);

                // Offset by half to center
                position -= drawn / 2;

                // Add 4 and 2 to give the background a margin around the text
                drawn = drawn with { X = drawn.X + 4 * UIScale, Y = drawn.Y + _font.GetLineHeight(UIScale) + 2 * UIScale };

                // Remove 2 for background margin
                handle.DrawRect(UIBox2.FromDimensions(position - new Vector2(2 * UIScale, 0), drawn), Color.Black.WithAlpha(0.85f));
                handle.DrawString(_font, position, label, Color.White);
            }
        }
    }

    public void AddDirectionalLine(Vector2i fromIndices, Vector2i toIndices, Color color, bool removeExisting = true)
    {
        if (removeExisting)
            Lines.RemoveAll(line => line.Color == color);

        Lines.Add(new TacticalMapLine(
            ConvertIndicesToLineCoordinates(fromIndices),
            ConvertIndicesToLineCoordinates(toIndices),
            color
        ));
    }

    public void RemoveLinesByColor(Color color)
    {
        Lines.RemoveAll(line => line.Color.R == color.R && line.Color.G == color.G && line.Color.B == color.B);
    }

    protected override void KeyBindDown(GUIBoundKeyEventArgs args)
    {
        base.KeyBindDown(args);

        if (args.Function == EngineKeyFunctions.UIClick)
        {
            var clickedBlip = GetBlipAtPosition(args.RelativePosition);

            if (clickedBlip != null)
            {
                OnBlipClicked?.Invoke(clickedBlip.Value.Indices);
                args.Handle();
                return;
            }

            HideTunnelInfo();

            if (Drawing)
            {
                _dragging = true;
                _lastDrag = args.RelativePosition.Floored();
            }
        }
        else if (args.Function == EngineKeyFunctions.UIRightClick)
        {
            var clickedBlip = GetBlipAtPosition(args.RelativePosition);

            if (clickedBlip != null && OnBlipRightClicked != null)
            {
                OnBlipRightClicked.Invoke(clickedBlip.Value.Indices, "");
                args.Handle();
            }
            else
            {
                HideTunnelInfo();
            }
        }
    }

    public Vector2i ConvertIndicesToLineCoordinates(Vector2i indices)
    {
        var scaled = GetDrawPosition(indices) * MAP_SCALE;
        return new Vector2i((int)scaled.X, (int)scaled.Y);
    }

    protected override void KeyBindUp(GUIBoundKeyEventArgs args)
    {
        base.KeyBindUp(args);

        if (args.Function == EngineKeyFunctions.UIClick)
        {
            _dragging = false;
            _lastDrag = null;
        }
    }

    protected override void MouseMove(GUIMouseMoveEventArgs args)
    {
        base.MouseMove(args);

        if (!Drawing || !_dragging)
            return;

        var relative = args.RelativePosition.Floored();
        if (_lastDrag == null)
        {
            _lastDrag = relative;
            return;
        }

        var diff = relative - _lastDrag.Value;
        if (diff == Vector2i.Zero) return;

        if (diff.Length < MIN_DRAG_DISTANCE) return;

        if (Texture == null) return;

        var draw = GetDrawDimensions(Texture);
        var controlOffset = new Vector2(draw.Left, draw.Top) / UIScale;

        var textureStartF = new Vector2(_lastDrag.Value.X, _lastDrag.Value.Y) - controlOffset;
        var textureEndF = new Vector2(relative.X, relative.Y) - controlOffset;

        var textureStart = new Vector2i((int)textureStartF.X, (int)textureEndF.Y);
        var textureEnd = new Vector2i((int)textureEndF.X, (int)textureEndF.Y);

        Lines.Add(new TacticalMapLine(textureStart, textureEnd, Color));
        while (LineLimit >= 0 && Lines.Count > LineLimit)
        {
            Lines.RemoveAt(0);
        }

        _lastDrag = relative;
    }

    public void AddTunnelPath(List<Vector2i> waypoints, Color pathColor, bool removeExisting = true)
    {
        if (removeExisting)
            RemoveLinesByColor(pathColor);

        if (waypoints.Count < 2) return;

        for (int i = 0; i < waypoints.Count - 1; i++)
        {
            Lines.Add(new TacticalMapLine(
                ConvertIndicesToLineCoordinates(waypoints[i]),
                ConvertIndicesToLineCoordinates(waypoints[i + 1]),
                pathColor
            ));
        }
    }

    private Vector2i GetClosestEdgePoint(Vector2i fromIndices, Vector2i toIndices, bool getFromPoint)
    {
        var fromUI = ConvertIndicesToLineCoordinates(fromIndices);
        var toUI = ConvertIndicesToLineCoordinates(toIndices);
        var sourcePoint = getFromPoint ? fromUI : toUI;
        var targetPoint = getFromPoint ? toUI : fromUI;
        var direction = targetPoint - sourcePoint;
        var distance = Math.Sqrt(direction.X * direction.X + direction.Y * direction.Y);

        if (distance == 0) return sourcePoint;

        var edgeOffset = (int)(BASE_BLIP_SIZE * BLIP_EDGE_RATIO);
        if (distance < edgeOffset * CLOSE_BLIP_THRESHOLD)
            edgeOffset = (int)(edgeOffset * (distance / (edgeOffset * CLOSE_BLIP_THRESHOLD)) * CLOSE_BLIP_SAFETY);

        return new Vector2i(
            sourcePoint.X + (int)(direction.X / distance * edgeOffset),
            sourcePoint.Y + (int)(direction.Y / distance * edgeOffset)
        );
    }

    private Vector2i GetEdgePoint(Vector2i fromIndices, Vector2i toIndices, bool getFromPoint)
    {
        var fromUI = ConvertIndicesToLineCoordinates(fromIndices);
        var toUI = ConvertIndicesToLineCoordinates(toIndices);
        var sourcePoint = getFromPoint ? fromUI : toUI;
        var targetPoint = getFromPoint ? toUI : fromUI;
        var direction = targetPoint - sourcePoint;
        var distance = Math.Sqrt(direction.X * direction.X + direction.Y * direction.Y);

        if (distance == 0) return sourcePoint;

        var scaledBlipSize = BASE_BLIP_SIZE * MAP_SCALE;
        var edgeOffset = (int)(scaledBlipSize * 0.4f);

        var minOffset = (int)(scaledBlipSize * 0.2f);

        if (distance < scaledBlipSize * 1.5f)
        {
            edgeOffset = Math.Max(minOffset, (int)(distance * 0.3f));
        }

        return new Vector2i(
            sourcePoint.X + (int)(direction.X / distance * edgeOffset),
            sourcePoint.Y + (int)(direction.Y / distance * edgeOffset)
        );
    }

    public void AddDashedTunnelPathClosest(List<Vector2i> waypoints, Color pathColor, bool removeExisting = true)
    {
        if (removeExisting)
            RemoveLinesByColor(pathColor);

        if (waypoints.Count < 2) return;

        if (waypoints.Count == 2)
        {
            var startPos = ConvertIndicesToLineCoordinates(waypoints[0]);
            var endPos = ConvertIndicesToLineCoordinates(waypoints[1]);
            var distance = Math.Sqrt(Math.Pow(endPos.X - startPos.X, 2) + Math.Pow(endPos.Y - startPos.Y, 2));
            var scaledBlipSize = BASE_BLIP_SIZE * MAP_SCALE;

            if (distance < scaledBlipSize * 1.2f)
                return;
        }

        for (int i = 0; i < waypoints.Count - 1; i++)
        {
            var fromPoint = GetClosestEdgePoint(waypoints[i], waypoints[i + 1], true);
            var toPoint = GetClosestEdgePoint(waypoints[i], waypoints[i + 1], false);

            if (i == waypoints.Count - 2)
            {
                var direction = toPoint - fromPoint;
                var lineLength = Math.Sqrt(direction.X * direction.X + direction.Y * direction.Y);

                if (lineLength > 0)
                {
                    var scaledBlipSize = BASE_BLIP_SIZE * MAP_SCALE;
                    var arrowStartOffset = (int)(scaledBlipSize * 0.45f + ARROW_LENGTH);

                    if (lineLength > arrowStartOffset)
                    {
                        toPoint = new Vector2i(
                            toPoint.X - (int)(direction.X / lineLength * arrowStartOffset),
                            toPoint.Y - (int)(direction.Y / lineLength * arrowStartOffset)
                        );
                    }
                }
            }

            AddDashedSegment(fromPoint, toPoint, pathColor);
        }

        if (waypoints.Count >= 2)
        {
            AddSimpleArrowHead(
                ConvertIndicesToLineCoordinates(waypoints[waypoints.Count - 2]),
                ConvertIndicesToLineCoordinates(waypoints[waypoints.Count - 1]),
                pathColor
            );
        }
    }

    public void AddDashedTunnelPath(List<Vector2i> waypoints, Color pathColor, bool removeExisting = true)
    {
        if (removeExisting)
            RemoveLinesByColor(pathColor);

        if (waypoints.Count < 2) return;

        if (waypoints.Count == 2)
        {
            var startPos = ConvertIndicesToLineCoordinates(waypoints[0]);
            var endPos = ConvertIndicesToLineCoordinates(waypoints[1]);
            var distance = Math.Sqrt(Math.Pow(endPos.X - startPos.X, 2) + Math.Pow(endPos.Y - startPos.Y, 2));
            var scaledBlipSize = BASE_BLIP_SIZE * MAP_SCALE;

            if (distance < scaledBlipSize * 1.2f)
                return;
        }

        for (int i = 0; i < waypoints.Count - 1; i++)
        {
            var start = waypoints[i];
            var end = waypoints[i + 1];

            var fromPoint = GetEdgePoint(start, end, true);
            var toPoint = GetEdgePoint(start, end, false);

            if (i == waypoints.Count - 2)
            {
                var direction = toPoint - fromPoint;
                var lineLength = Math.Sqrt(direction.X * direction.X + direction.Y * direction.Y);

                if (lineLength > 0)
                {
                    var scaledBlipSize = BASE_BLIP_SIZE * MAP_SCALE;
                    var arrowStartOffset = (int)(scaledBlipSize * 0.45f + ARROW_LENGTH);

                    if (lineLength > arrowStartOffset)
                    {
                        toPoint = new Vector2i(
                            toPoint.X - (int)(direction.X / lineLength * arrowStartOffset),
                            toPoint.Y - (int)(direction.Y / lineLength * arrowStartOffset)
                        );
                    }
                }
            }

            AddDashedSegment(fromPoint, toPoint, pathColor);
        }

        if (waypoints.Count >= 2)
        {
            AddSimpleArrowHead(
                ConvertIndicesToLineCoordinates(waypoints[waypoints.Count - 2]),
                ConvertIndicesToLineCoordinates(waypoints[waypoints.Count - 1]),
                pathColor
            );
        }
    }

    private void AddDashedSegment(Vector2i fromUI, Vector2i toUI, Color color)
    {
        var direction = toUI - fromUI;
        var totalLength = Math.Sqrt(direction.X * direction.X + direction.Y * direction.Y);

        if (totalLength < 1) return;

        for (double distance = 0; distance < totalLength; distance += DASH_LENGTH + GAP_LENGTH)
        {
            Lines.Add(new TacticalMapLine(
                new Vector2i(
                    fromUI.X + (int)(direction.X / totalLength * distance),
                    fromUI.Y + (int)(direction.Y / totalLength * distance)
                ),
                new Vector2i(
                    fromUI.X + (int)(direction.X / totalLength * Math.Min(distance + DASH_LENGTH, totalLength)),
                    fromUI.Y + (int)(direction.Y / totalLength * Math.Min(distance + DASH_LENGTH, totalLength))
                ),
                color
            ));
        }
    }

    private void AddSimpleArrowHead(Vector2i start, Vector2i end, Color color)
    {
        var direction = end - start;
        var length = Math.Sqrt(direction.X * direction.X + direction.Y * direction.Y);

        if (length < 10) return;

        var scaledBlipSize = BASE_BLIP_SIZE * MAP_SCALE;
        var blipEdgeOffset = (int)(scaledBlipSize * 0.45f);

        var arrowTip = new Vector2i(
            end.X - (int)(direction.X / length * blipEdgeOffset),
            end.Y - (int)(direction.Y / length * blipEdgeOffset)
        );

        var arrowBase = new Vector2i(
            arrowTip.X - (int)(direction.X / length * ARROW_LENGTH),
            arrowTip.Y - (int)(direction.Y / length * ARROW_LENGTH)
        );

        var perpX = -direction.Y / length;
        var perpY = direction.X / length;

        var leftWing = new Vector2i(
            arrowBase.X + (int)(perpX * ARROW_WIDTH),
            arrowBase.Y + (int)(perpY * ARROW_WIDTH)
        );

        var rightWing = new Vector2i(
            arrowBase.X - (int)(perpX * ARROW_WIDTH),
            arrowBase.Y - (int)(perpY * ARROW_WIDTH)
        );

        Lines.Add(new TacticalMapLine(arrowTip, leftWing, color));
        Lines.Add(new TacticalMapLine(arrowTip, rightWing, color));
        Lines.Add(new TacticalMapLine(leftWing, rightWing, color));
    }

    public void AddTunnelPathWithArrow(List<Vector2i> waypoints, Color pathColor, bool removeExisting = true)
    {
        AddTunnelPath(waypoints, pathColor, removeExisting);

        if (waypoints.Count >= 2)
        {
            AddSimpleArrowHead(
                ConvertIndicesToLineCoordinates(waypoints[waypoints.Count - 2]),
                ConvertIndicesToLineCoordinates(waypoints[waypoints.Count - 1]),
                pathColor
            );
        }
    }

    public void ShowTunnelInfo(Vector2i indices, string tunnelName, Vector2 screenPosition)
    {
        if (_tunnelInfoLabel == null) return;

        _tunnelInfoLabel.Text = tunnelName;
        _tunnelInfoLabel.Visible = true;

        LayoutContainer.SetPosition(_tunnelInfoLabel, screenPosition + new Vector2(-(_tunnelInfoLabel.DesiredSize.X / 2), -45));
    }

    public void HideTunnelInfo()
    {
        if (_tunnelInfoLabel != null)
            _tunnelInfoLabel.Visible = false;
    }
}
