<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.CodeAnalysis.CSharp.Features</name>
    </assembly>
    <members>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS0103">
            <summary>
            name does not exist in context
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS0234">
            <summary>
            The type or namespace name 'X' does not exist in the namespace 'Y' (are you missing an assembly reference?)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS0246">
            <summary>
            type or namespace could not be found
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS0305">
            <summary>
            wrong number of type args
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS1061">
            <summary>
            type does not contain a definition of method or extension method
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS1935">
            <summary>
            cannot find implementation of query pattern
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS0308">
            <summary>
            The non-generic type 'A' cannot be used with type arguments
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS0122">
            <summary>
            'A' is inaccessible due to its protection level
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS0307">
            <summary>
            The using alias 'A' cannot be used with type arguments
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS0616">
            <summary>
            'A' is not an attribute class
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS1501">
            <summary>
             No overload for method 'X' takes 'N' arguments
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS1503">
            <summary>
            cannot convert from 'int' to 'string'
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS1574">
            <summary>
            XML comment on 'construct' has syntactically incorrect cref attribute 'name'
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS1580">
            <summary>
            Invalid type for parameter 'parameter number' in XML comment cref attribute
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS1581">
            <summary>
            Invalid return type in XML comment cref attribute
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS1584">
            <summary>
            XML comment has syntactically incorrect cref attribute
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS1929">
            <summary>
            Type 'X' does not contain a valid extension method accepting 'Y'
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS1955">
            <summary>
            Property cannot be used like a method
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS0428">
            <summary>
            Cannot convert method group 'X' to non-delegate type 'Y'. Did you intend to invoke the method?
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS7036">
            <summary>
             There is no argument given that corresponds to the required parameter 'X' of 'Y'
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS8129">
            <summary>
            o Deconstruct instance or extension method was found for type 'X', with N out parameters
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS0281">
            <summary>
            Internal symbol inaccessible because public key is wrong
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS4036">
            <summary>
            'X' does not contain a definition for 'Y' and no extension method 'Y' accepting a first argument of type 'X' could be found (are you missing a using directive for 'System'?)
            Specialized for WinRT
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS1579">
            <summary>
            foreach statement cannot operate on variables of type 'X' because 'X' does not contain a public instance or extension definition for 'GetEnumerator'
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS8414">
            <summary>
            foreach statement cannot operate on variables of type 'X' because 'X' does not contain a public instance or extension definition for 'GetEnumerator'. Did you mean 'await foreach' rather than 'foreach'?
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS8411">
            <summary>
            Asynchronous foreach statement cannot operate on variables of type 'X' because 'X' does not contain a suitable public instance or extension definition for 'GetAsyncEnumerator'
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds.CS8415">
            <summary>
            Asynchronous foreach statement cannot operate on variables of type 'X' because 'X' does not contain a suitable public instance or extension definition for 'GetAsyncEnumerator'. Did you mean 'foreach' rather than 'await foreach'?
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AddImport.CSharpAddImportCodeFixProvider.#ctor(Microsoft.CodeAnalysis.Packaging.IPackageInstallerService,Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchService)">
            <summary>For testing purposes only (so that tests can pass in mock values)</summary> 
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BraceCompletion.AbstractCurlyBraceOrBracketCompletionService.s_closingBraceFormatAnnotation">
            <summary>
            Annotation used to find the closing brace location after formatting changes are applied.
            The closing brace location is then used as the caret location.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BraceCompletion.AbstractCurlyBraceOrBracketCompletionService.FormatTrackingSpan(Microsoft.CodeAnalysis.ParsedDocument,System.Int32,System.Int32,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule},Microsoft.CodeAnalysis.Indentation.IndentationOptions,System.Threading.CancellationToken)">
            <summary>
            Formats the span between the opening and closing points, options permitting.
            Returns the text changes that should be applied to the input document to 
            get the formatted text and the end of the close curly brace in the formatted text.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.BraceCompletion.InterpolatedStringBraceCompletionService">
            <summary>
            Brace completion service for double quotes marking an interpolated string. Note that the <see
            cref="T:Microsoft.CodeAnalysis.CSharp.BraceCompletion.StringLiteralBraceCompletionService"/> is used for other double quote completions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BraceCompletion.InterpolatedStringBraceCompletionService.#ctor">
            <summary>
            Brace completion service for double quotes marking an interpolated string. Note that the <see
            cref="T:Microsoft.CodeAnalysis.CSharp.BraceCompletion.StringLiteralBraceCompletionService"/> is used for other double quote completions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BraceCompletion.InterpolatedStringBraceCompletionService.CanProvideBraceCompletion(System.Char,System.Int32,Microsoft.CodeAnalysis.ParsedDocument,System.Threading.CancellationToken)">
            <summary>
            Only return this service as valid when we're starting an interpolated string. Otherwise double quotes should be
            completed using the <see cref="T:Microsoft.CodeAnalysis.CSharp.BraceCompletion.StringLiteralBraceCompletionService"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BraceCompletion.InterpolatedStringBraceCompletionService.IsPositionInInterpolatedStringContext(Microsoft.CodeAnalysis.ParsedDocument,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Returns true when the input position could be starting an interpolated string if opening quotes were typed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.BraceCompletion.InterpolationBraceCompletionService">
            <summary>
            Brace completion service used for completing curly braces inside interpolated strings.
            In other curly brace completion scenarios the <see cref="T:Microsoft.CodeAnalysis.CSharp.BraceCompletion.CurlyBraceCompletionService"/> should be used.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BraceCompletion.InterpolationBraceCompletionService.#ctor">
            <summary>
            Brace completion service used for completing curly braces inside interpolated strings.
            In other curly brace completion scenarios the <see cref="T:Microsoft.CodeAnalysis.CSharp.BraceCompletion.CurlyBraceCompletionService"/> should be used.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BraceCompletion.InterpolationBraceCompletionService.CanProvideBraceCompletion(System.Char,System.Int32,Microsoft.CodeAnalysis.ParsedDocument,System.Threading.CancellationToken)">
            <summary>
            Only return this service as valid when we're typing curly braces inside an interpolated string.
            Otherwise curly braces should be completed using the <see cref="T:Microsoft.CodeAnalysis.CSharp.BraceCompletion.CurlyBraceCompletionService"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BraceCompletion.InterpolationBraceCompletionService.IsPositionInInterpolationContext(Microsoft.CodeAnalysis.ParsedDocument,System.Int32)">
            <summary>
            Returns true when the input position could be starting an interpolation expression if a curly brace was typed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.FullyQualify.CSharpFullyQualifyCodeFixProvider.CS0103">
            <summary>
            name does not exist in context
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.FullyQualify.CSharpFullyQualifyCodeFixProvider.CS0104">
            <summary>
            'reference' is an ambiguous reference between 'identifier' and 'identifier'
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.FullyQualify.CSharpFullyQualifyCodeFixProvider.CS0246">
            <summary>
            type or namespace could not be found
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.FullyQualify.CSharpFullyQualifyCodeFixProvider.CS0305">
            <summary>
            wrong number of type args
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.FullyQualify.CSharpFullyQualifyCodeFixProvider.CS0308">
            <summary>
            The non-generic type 'A' cannot be used with type arguments
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.AddExplicitCast.CSharpAddExplicitCastCodeFixProvider.CS0266">
            <summary>
            CS0266: Cannot implicitly convert from type 'x' to 'y'. An explicit conversion exists (are you missing a cast?)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.AddExplicitCast.CSharpAddExplicitCastCodeFixProvider.CS1503">
            <summary>
            CS1503: Argument 1: cannot convert from 'x' to 'y'
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.AddInheritdoc.AddInheritdocCodeFixProvider.CS1591">
            <summary>
            CS1591: Missing XML comment for publicly visible type or member 'Type_or_Member'
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.ConvertToAsync.CSharpConvertToAsyncMethodCodeFixProvider.CS4008">
            <summary>
            Cannot await void.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CodeFixes.FixReturnType.CSharpFixReturnTypeCodeFixProvider">
            <summary>
            Helps fix void-returning methods or local functions to return a correct type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeFixes.FixReturnType.CSharpFixReturnTypeCodeFixProvider.#ctor">
            <summary>
            Helps fix void-returning methods or local functions to return a correct type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.Iterator.CSharpAddYieldCodeFixProvider.CS0029">
            <summary>
            CS0029: Cannot implicitly convert from type 'x' to 'y'
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.Iterator.CSharpAddYieldCodeFixProvider.CS0266">
            <summary>
            CS0266: Cannot implicitly convert from type 'x' to 'y'. An explicit conversion exists (are you missing a cast?)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.Iterator.CSharpChangeToIEnumerableCodeFixProvider.CS1624">
            <summary>
            CS1624: The body of 'x' cannot be an iterator block because 'y' is not an iterator interface type
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeLens.CSharpCodeLensDisplayInfoService.GetDisplayNode(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns the node that should be displayed
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeLens.CSharpCodeLensDisplayInfoService.GetDisplayName(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the DisplayName for the given node.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CodeRefactorings.AddAwait.CSharpAddAwaitCodeRefactoringProvider">
            <summary>
            This refactoring complements the AddAwait fixer. It allows adding `await` and `await ... .ConfigureAwait(false)` even there is no compiler error to trigger the fixer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeRefactorings.AddAwait.CSharpAddAwaitCodeRefactoringProvider.#ctor">
            <summary>
            This refactoring complements the AddAwait fixer. It allows adding `await` and `await ... .ConfigureAwait(false)` even there is no compiler error to trigger the fixer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeRefactorings.ExtractClass.CSharpExtractClassCodeRefactoringProvider.#ctor(Microsoft.CodeAnalysis.ExtractClass.IExtractClassOptionsService)">
            <summary>
            Test purpose only.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeRefactorings.UseRecursivePatterns.UseRecursivePatternsCodeRefactoringProvider.TryGetCommonReceiver(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionOrPatternSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionOrPatternSyntax,Microsoft.CodeAnalysis.SemanticModel)">
            <summary>
            Obtain the outermost common receiver between two expressions.  This can succeed with a null 'CommonReceiver'
            in the case that the common receiver is the 'implicit this'.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ChangeNamespace.CSharpChangeNamespaceService.TryGetReplacementReferenceSyntax(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray{System.String},Microsoft.CodeAnalysis.LanguageService.ISyntaxFactsService,Microsoft.CodeAnalysis.SyntaxNode@,Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            Try to get a new node to replace given node, which is a reference to a top-level type declared inside the namespace to be changed.
            If this reference is the right side of a qualified name, the new node returned would be the entire qualified name. Depends on 
            whether <paramref name="newNamespaceParts"/> is provided, the name in the new node might be qualified with this new namespace instead.
            </summary>
            <param name="reference">A reference to a type declared inside the namespace to be changed, which is calculated based on results from 
            `SymbolFinder.FindReferencesAsync`.</param>
            <param name="newNamespaceParts">If specified, and the reference is qualified with namespace, the namespace part of original reference 
            will be replaced with given namespace in the new node.</param>
            <param name="oldNode">The node to be replaced. This might be an ancestor of original reference.</param>
            <param name="newNode">The replacement node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ChangeNamespace.CSharpChangeNamespaceService.ChangeNamespaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax,System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
            Try to change the namespace declaration based on the following rules:
                - if neither declared nor target namespace are "" (i.e. global namespace),
                then we try to change the name of the namespace.
                - if declared namespace is "", then we try to move all types declared 
                in global namespace in the document into a new namespace declaration.
                - if target namespace is "", then we try to move all members in declared 
                namespace to global namespace (i.e. remove the namespace declaration).    
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ChangeNamespace.CSharpChangeNamespaceService.TryGetApplicableContainerFromSpanAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
             <summary>
             For the node specified by <paramref name="span"/> to be applicable container, it must be a namespace 
             declaration or a compilation unit, contain no partial declarations and meet the following additional
             requirements:
             
             - If a namespace declaration:
                1. It doesn't contain or is nested in other namespace declarations
                2. The name of the namespace is valid (i.e. no errors)
            
             - If a compilation unit (i.e. <paramref name="span"/> is empty), there must be no namespace declaration
               inside (i.e. all members are declared in global namespace)
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ChangeNamespace.CSharpChangeNamespaceService.GetOpeningAndClosingTriviaOfNamespaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.BaseNamespaceDeclarationSyntax)">
            <summary>
            return trivia attached to namespace declaration. 
            Leading trivia of the node and trivia around opening brace, as well as
            trivia around closing brace are concatenated together respectively.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Completion.Providers.AwaitCompletionProvider.GetAsyncKeywordInsertionPosition(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the span start where async keyword should go.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Completion.Providers.CompletionUtilities.IsCompilerDirectiveTriggerCharacter(Microsoft.CodeAnalysis.Text.SourceText,System.Int32)">
            <summary>
            Tells if we are in positions like this: <c>#nullable $$</c> or <c>#pragma warning $$</c>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Completion.Providers.DeclarationName.DeclarationNameRecommender.IsRelevantSymbolKind(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Check if the symbol is a relevant kind.
            Only relevant if symbol could cause a conflict with a local variable.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Completion.Providers.FirstBuiltInCompletionProvider">
            <summary>
            Provides a completion provider that always appears before any built-in completion provider. This completion
            provider does not provide any completions.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Completion.Providers.LastBuiltInCompletionProvider">
            <summary>
            Provides a completion provider that always appears after all built-in completion providers. This completion
            provider does not provide any completions.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Completion.Providers.UnnamedSymbolCompletionProvider">
            <summary>
            Provides completion for uncommon unnamed symbols, like conversions, indexer and operators.  These completion 
            items will be brought up with <c>dot</c> like normal, but will end up inserting more than just a name into
            the editor.  For example, committing a conversion will insert the conversion prior to the expression being
            dotted off of.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Completion.Providers.UnnamedSymbolCompletionProvider.SortingPrefix">
            <summary>
            CompletionItems for indexers/operators should be sorted below other suggestions like methods or properties
            of the type.  We accomplish this by placing a character known to be greater than all other normal identifier
            characters as the start of our item's name. This doesn't affect what we insert though as all derived
            providers have specialized logic for what they need to do.
            </summary> 
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Completion.Providers.UnnamedSymbolCompletionProvider.KindName">
            <summary>
            Used to store what sort of unnamed symbol a completion item represents.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Completion.Providers.UnnamedSymbolCompletionProvider.DocumentationCommentXmlName">
            <summary>
            Used to store the doc comment for some operators/conversions.  This is because some of them will be
            synthesized, so there will be no symbol we can recover after the fact in <see cref="M:Microsoft.CodeAnalysis.CSharp.Completion.Providers.UnnamedSymbolCompletionProvider.GetDescriptionAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Completion.CompletionItem,Microsoft.CodeAnalysis.Completion.CompletionOptions,Microsoft.CodeAnalysis.LanguageService.SymbolDescriptionOptions,System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Completion.Providers.UnnamedSymbolCompletionProvider.SortText(System.Int32,System.String)">
            <summary>
            We keep operators sorted in a specific order.  We don't want to sort them alphabetically, but instead want
            to keep things like <c>==</c> and <c>!=</c> together.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Completion.Providers.UnnamedSymbolCompletionProvider.GetDotAndExpressionStart(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Gets the dot-like token we're after, and also the start of the expression we'd want to place any text before.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Completion.Providers.UnnamedSymbolCompletionProvider.RehydrateName">
            <summary>
            Tag to let us know we need to rehydrate the conversion from the parameter and return type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Completion.Providers.UnnamedSymbolCompletionProvider.s_operatorInfo">
            <summary>
            Ordered in the order we want to display operators in the completion list.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Completion.Providers.UnnamedSymbolCompletionProvider.s_operatorNameToInfo">
            <summary>
            Mapping from operator name to info about it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Completion.Providers.SymbolCompletionProvider.IsTriggerInArgumentListAsync(Microsoft.CodeAnalysis.Document,System.Int32,System.Threading.CancellationToken)">
            <returns><see langword="null"/> if not an argument list character, otherwise whether the trigger is in an argument list.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Completion.Providers.FirstBuiltInArgumentProvider">
            <summary>
            Provides an argument provider that always appears before any built-in argument provider. This argument
            provider does not provide any argument values.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Completion.Providers.LastBuiltInArgumentProvider">
            <summary>
            Provides an argumnet provider that always appears after all built-in argument providers. This argument
            provider does not provide any argument values.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.AbstractSyntacticSingleKeywordRecommender.DefaultMatchPriority">
            <summary>
            Matching priority for the provided item when <see cref="M:Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.AbstractSyntacticSingleKeywordRecommender.ShouldPreselect(Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery.CSharpSyntaxContext,System.Threading.CancellationToken)"/> returns <see langword="false"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.NuintKeywordRecommender.Keyword">
            <summary>
            We set the <see cref="T:Microsoft.CodeAnalysis.Completion.MatchPriority"/> of this item less than the default value so that completion selects
            the <see langword="null"/> keyword over it as the user starts typing.  Being able to type <see
            langword="null"/> with just <c>nu</c> is ingrained in muscle memory and is more important to maintain versus
            strict adherence to our normal textual matching procedure.  The user can always still get this item simply
            by typing one additional character and unambiguously referring to <c>nui</c>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.RefKeywordRecommender.RefMemberModifiers">
            <summary>
            Same as <see cref="F:Microsoft.CodeAnalysis.CSharp.Utilities.SyntaxKindSet.AllMemberModifiers"/> with ref specific exclusions
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.RefKeywordRecommender.RefGlobalMemberModifiers">
            <summary>
            Same as <see cref="F:Microsoft.CodeAnalysis.CSharp.Utilities.SyntaxKindSet.AllGlobalMemberModifiers"/> with ref-specific exclusions
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.RefKeywordRecommender.RefGlobalMemberScriptModifiers">
            <summary>
            Same as <see cref="F:Microsoft.CodeAnalysis.CSharp.Utilities.SyntaxKindSet.AllGlobalMemberModifiers"/> with ref-specific exclusions for C# script
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.UShortKeywordRecommender.DefaultMatchPriority">
            <summary>
            We set the <see cref="T:Microsoft.CodeAnalysis.Completion.MatchPriority"/> of this item less than the default value so that
            completion selects the <see langword="using"/> keyword over it as the user starts typing.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ConvertCast.CSharpConvertDirectCastToTryCastCodeRefactoringProvider">
             <summary>
             Refactor:
                 var o = (object)1;
            
             Into:
                 var o = 1 as object;
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ConvertCast.CSharpConvertTryCastToDirectCastCodeRefactoringProvider">
             <summary>
             Refactor:
                 var o = 1 as object;
            
             Into:
                 var o = (object)1;
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.AbstractConverter.CreateQueryExpressionOrLinqInvocation(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Boolean)">
            <summary>
            Creates a query expression or a linq invocation expression.
            </summary>
            <param name="selectExpression">expression to be used into the last Select in the query expression or linq invocation.</param>
            <param name="leadingTokensForSelect">extra leading tokens to be added to the select clause</param>
            <param name="trailingTokensForSelect">extra trailing tokens to be added to the select clause</param>
            <param name="convertToQuery">Flag indicating if a query expression should be generated</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.AbstractConverter.CreateQueryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Creates a query expression.
            </summary>
            <param name="selectExpression">expression to be used into the last 'select ...' in the query expression</param>
            <param name="leadingTokensForSelect">extra leading tokens to be added to the select clause</param>
            <param name="trailingTokensForSelect">extra trailing tokens to be added to the select clause</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.AbstractConverter.CreateLinqInvocationOrSimpleExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Creates a linq invocation expression.
            </summary>
            <param name="selectExpression">expression to be used in the last 'Select' invocation</param>
            <param name="leadingTokensForSelect">extra leading tokens to be added to the select clause</param>
            <param name="trailingTokensForSelect">extra trailing tokens to be added to the select clause</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.AbstractConverter.CreateLinqInvocationForExtendedNode(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Int32@,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax@,System.Boolean@)">
            <summary>
            Creates a linq invocation expression for the <see cref="P:Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.ForEachInfo`2.ConvertingExtendedNodes"/> node at the given index <paramref name="extendedNodeIndex"/>
            or returns the <paramref name="selectExpression"/> if all extended nodes have been processed.
            </summary>
            <param name="selectExpression">Innermost select expression</param>
            <param name="extendedNodeIndex">Index into <see cref="P:Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.ForEachInfo`2.ConvertingExtendedNodes"/> to be processed and updated.</param>
            <param name="receiver">Receiver for the generated linq invocation. Updated when processing an if statement.</param>
            <param name="hasForEachChild">Flag indicating if any of the processed <see cref="P:Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.ForEachInfo`2.ConvertingExtendedNodes"/> is a <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax"/>.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.AbstractToMethodConverter">
            <summary>
            Provides a conversion to query.Method() like query.ToList(), query.Count().
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.AbstractToMethodConverter.#ctor(Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.ForEachInfo{Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxTrivia[])">
            <summary>
            Provides a conversion to query.Method() like query.ToList(), query.Count().
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.ToCountConverter">
            <summary>
            Provides a conversion to query.Count().
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.ToCountConverter.#ctor(Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.ForEachInfo{Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxTrivia[])">
            <summary>
            Provides a conversion to query.Count().
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.ToCountConverter.CreateDefaultStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            Input:
            foreach(...)
            {
                ...
                ...
                counter++;
             }
             
             Output:
             counter += queryGenerated.Count();
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.ToToListConverter">
            <summary>
            Provides a conversion to query.ToList().
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.ToToListConverter.#ctor(Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.ForEachInfo{Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxTrivia[])">
            <summary>
            Provides a conversion to query.ToList().
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.ToToListConverter.CanReplaceInitialization(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
            Checks that the expression is "new List();"
            Exclude "new List(a);" and new List() { 1, 2, 3}
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.ToToListConverter.CreateDefaultStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            Input:
            foreach(...)
            {
                ...
                ...
                list.Add(item);
             }
             
             Output:
             list.AddRange(queryGenerated);
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertLinq.CSharpConvertLinqQueryToForEachProvider.FindNodeToRefactorAsync(Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext)">
            <summary>
            Finds a QueryExpressionSyntax node for the span.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertLinq.CSharpConvertLinqQueryToForEachProvider.Converter.CanTryConvertToLocalFunction">
            <summary>
            Checks if the location of the query expression allows to convert it at least to a local function.
            It still does not guarantees that the conversion can be performed. There can be bail outs of later stages.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertNamespace.ConvertNamespaceTransform.ConvertNamespaceDeclarationAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax,Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptions,System.Threading.CancellationToken)">
            <summary>
            Asynchronous implementation for code fixes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertNamespace.ConvertNamespaceTransform.ConvertNamespaceDeclaration(Microsoft.CodeAnalysis.ParsedDocument,Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax,Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptions,System.Threading.CancellationToken)">
            <summary>
            Synchronous implementation for a command handler.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ConvertToExtension.ConvertToExtensionCodeRefactoringProvider">
            <summary>
            Refactoring to convert from classic extension methods to modern C# 14 extension types.  Practically all classic
            extension methods are supported <em>except</em> for those where the 'this' parameter references method type
            parameters that are not the starting type parameters of the extension method.  Those extension methods do not
            have a 'modern' form as modern extensions have no way of lowering to that classic ABI shape.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertToExtension.ConvertToExtensionCodeRefactoringProvider.#ctor">
            <summary>
            Refactoring to convert from classic extension methods to modern C# 14 extension types.  Practically all classic
            extension methods are supported <em>except</em> for those where the 'this' parameter references method type
            parameters that are not the starting type parameters of the extension method.  Those extension methods do not
            have a 'modern' form as modern extensions have no way of lowering to that classic ABI shape.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ConvertToExtension.ConvertToExtensionCodeRefactoringProvider.ExtensionMethodInfo">
            <summary>
            Information about a class extension method we can convert to a modern extension.  Extension methods with
            'identical' receiver parameters will compare/hash as equal.  That way we can easily find and group all the
            methods we want to move into a single extension together.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertToExtension.ConvertToExtensionCodeRefactoringProvider.ExtensionMethodInfo.#ctor(Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax,Microsoft.CodeAnalysis.IParameterSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ITypeParameterSymbol})">
            <summary>
            Information about a class extension method we can convert to a modern extension.  Extension methods with
            'identical' receiver parameters will compare/hash as equal.  That way we can easily find and group all the
            methods we want to move into a single extension together.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertToExtension.ConvertToExtensionCodeRefactoringProvider.GetAllExtensionMethods(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Returns all the legal extension methods in <paramref name="classDeclaration"/> grouped by their receiver
            parameter. The groupings are only for receiver parameters that are considered <em>identical</em>, and thus could
            be the extension parameter P in a new <c>extension(P)</c> declaration.  This means they must have the same type,
            name, ref-ness, constraints, attributes, etc.
            </summary>
            <remarks>
            Because the methods are processed in order within the <paramref name="classDeclaration"/>, the arrays of grouped
            extension methods in the dictionary will also be similarly ordered.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertToExtension.ConvertToExtensionCodeRefactoringProvider.ConvertToExtension(Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService,Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax,System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.CSharp.ConvertToExtension.ConvertToExtensionCodeRefactoringProvider.ExtensionMethodInfo,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.ConvertToExtension.ConvertToExtensionCodeRefactoringProvider.ExtensionMethodInfo}},System.Nullable{Microsoft.CodeAnalysis.CSharp.ConvertToExtension.ConvertToExtensionCodeRefactoringProvider.ExtensionMethodInfo})">
            <summary>
            Core function that the normal fix and the fix-all-provider call into to fixup one class declaration and the set
            of desired extension methods within that class declaration.  When called on an extension method itself, this
            will just be one extension method.  When called on a class declaration, this will be all the extension methods
            in that class.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertToRawString.ConvertToRawStringHelpers.CanConvert(Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence,System.Boolean@)">
            <summary>
            Returns if this sequence of characters can be converted to a raw string.  If it can, also returns if it
            contained an explicitly escaped newline (like <c>\r\n</c>) within it.  It it can't convert, then the value of
            <paramref name="containsEscapedEndOfLineCharacter"/> is undefined.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.ConvertToRecordHelpers.IsDefaultEqualsOperator(Microsoft.CodeAnalysis.Operations.IMethodBodyOperation)">
            <summary>
            Returns true if the method contents match a simple reference to the equals method
            which would be the compiler generated implementation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.ConvertToRecordHelpers.IsDefaultNotEqualsOperator(Microsoft.CodeAnalysis.Operations.IMethodBodyOperation)">
            <summary>
            Whether the method simply returns !(equals), where "equals" is
            c1 == c2 or c1.Equals(c2)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.ConvertToRecordHelpers.IsSimplePrimaryConstructor(Microsoft.CodeAnalysis.Operations.IConstructorBodyOperation,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IPropertySymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IParameterSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IPropertySymbol}@)">
            <summary>
            Matches constructors where each statement simply assigns one of the provided parameters to one of the provided properties
            with no duplicate assignment or any other type of statement
            </summary>
            <param name="operation">Constructor body</param>
            <param name="properties">Properties expected to be assigned (would be replaced with positional constructor).
            Will re-order this list to match parameter order if successful.</param>
            <param name="parameters">Constructor parameters</param>
            <returns>Whether the constructor body matches the pattern described</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.ConvertToRecordHelpers.IsSimpleCopyConstructor(Microsoft.CodeAnalysis.Operations.IConstructorBodyOperation,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IFieldSymbol},Microsoft.CodeAnalysis.IParameterSymbol)">
            <summary>
            Checks to see if all fields/properties were assigned from the parameter
            </summary>
            <param name="operation">constructor body</param>
            <param name="fields">all instance fields, including backing fields of constructors</param>
            <param name="parameter">parameter to copy constructor</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.ConvertToRecordHelpers.GetAssignmentValuesForNonPrimaryConstructor(Microsoft.CodeAnalysis.Operations.IConstructorBodyOperation,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IPropertySymbol})">
            <summary>
            Given a non-primary, non-copy constructor, get expressions that are assigned to
            primary constructor properties via simple assignment.
            </summary>
            <param name="operation">The constructor body operation</param>
            <param name="positionalParams">the primary constructor parameters</param>
            <returns>
            Expressions that were assigned to a primary constructor property in the constructor,
            or default/null if there wasn't an assignment found. Returned in order of primary parameters.
            </returns>
            <remarks>
            Example (assume we decided on positional parameters int Foo, bool Bar, int Baz):
            <code>
            public C(int foo, bool bar)
            {
                Bar = bar;
                Foo = foo;
                Mumble = 0;
            }
            </code>
            we would return: [foo, bar, default]
            where foo and bar are the nodes in the assignment, and default is factory constructed.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.ConvertToRecordHelpers.GetAssignmentValuesFromObjectCreation(Microsoft.CodeAnalysis.Operations.IObjectCreationOperation,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IPropertySymbol})">
            <summary>
            Given an object creation with a block initializer and a parameterless constructor declaration,
            finds values that were assigned to the primary constructor parameters
            </summary>
            <param name="operation">Object creation expression operation</param>
            <param name="positionalParams">primary constructor parameters</param>
            <returns>
            values that were assigned to primary constructor parameters, in order of the passed in primary constructor
            </returns>
            <remarks>
             Example (assume we decided on positional parameters int Foo, bool Bar, int Baz):
            <code>
            var c = new C
            {
                Bar = true;
                Foo = 10;
                Mumble = 0;
            };
            </code>
            We would return [10, true, default]
            where 10 and true are the actual nodes and default was a constructed node
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.ConvertToRecordHelpers.IsSafeAssignment(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Determines whether the operation is safe to move into the "this(...)" initializer
            i.e. Doesn't reference any other created variables but the parameters
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.ConvertToRecordHelpers.GetEqualizedFields(Microsoft.CodeAnalysis.Operations.IMethodBodyOperation,Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Get all the fields (including implicit fields underlying properties) that this
            equals method compares
            </summary>
            <param name="operation"></param>
            <param name="methodSymbol">the symbol of the equals method</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.ConvertToRecordHelpers.TryGetAssignmentFromParameterWithExplicitCast(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.IParameterSymbol,Microsoft.CodeAnalysis.ISymbol@)">
            <summary>
            Matches: var otherC = (C) other;
            or: var otherC = other as C;
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.ConvertToRecordHelpers.GetParamFromArgument(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Get the referenced parameter (and unwraps implicit cast if necessary) or null if a parameter wasn't referenced
            </summary>
            <param name="operation">The operation for which to get the parameter</param>
            <returns>the referenced parameter or null if unable to find</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.ConvertToRecordHelpers.IsDotEqualsInvocation(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            matches form:
            c1.Equals(c2)
            where c1 and c2 are parameter references
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.ConvertToRecordHelpers.IsNullCheck(Microsoft.CodeAnalysis.IOperation,System.Boolean,Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            checks for binary expressions of the type otherC == null or null == otherC
            or a pattern against null like otherC is (not) null
            and "otherC" is a reference to otherObject.
            </summary>
            <param name="operation">Operation to check for</param>
            <param name="successRequirement">if we're in a context where the operation evaluating to true
            would end up being false within the equals method, we look for != instead</param>
            <param name="otherObject">Object to be compared to null</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.ConvertToRecordHelpers.TryAddEqualizedFieldsForCondition(Microsoft.CodeAnalysis.IOperation,System.Boolean,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.IFieldSymbol})">
            <summary>
            looks just at conditional expressions such as "A == other.A &amp;&amp; B == other.B..."
            To determine which members were accessed and compared
            </summary>
            <param name="condition">Condition to look at, should be a boolean expression</param>
            <param name="successRequirement">Whether to look for operators that would indicate equality success
            (==, .Equals, &amp;&amp;) or inequality operators (!=, ||)</param>
            <param name="currentObject">Symbol that would be referenced with this</param>
            <param name="otherObject">symbol representing other object, either from a param or cast as a local</param>
            <param name="builder">Builder to add members to</param>
            <returns>true if addition was successful, false if we see something odd 
            (equality checking in the wrong order, side effects, etc)</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.ConvertToRecordHelpers.TryAddEqualizedFieldsForConditionWithoutTypedVariable(Microsoft.CodeAnalysis.IOperation,System.Boolean,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.IFieldSymbol},Microsoft.CodeAnalysis.ISymbol@,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IOperation})">
            <summary>
            Same as <see cref="M:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.ConvertToRecordHelpers.TryAddEqualizedFieldsForCondition(Microsoft.CodeAnalysis.IOperation,System.Boolean,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.IFieldSymbol})"/> but we're looking for
            a variable binding through an "is" pattern first/>
            </summary>
            <returns>the cast parameter symbol if found, null if not</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.ConvertToRecordHelpers.TryAddEqualizedFieldsForStatements(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IOperation},Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.IFieldSymbol})">
            <summary>
            Match a list of statements and add members that are compared
            </summary>
            <param name="statementsToCheck">operations which should compare members</param>
            <param name="otherC">non-this comparison of the type we're equating</param>
            <param name="type">the this symbol</param>
            <param name="builder">builder for property/field comparisons we encounter</param>
            <returns>whether every statment was one of the expected forms</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.ConvertToRecordHelpers.TryGetBindingCastInFirstIfStatement(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IOperation},Microsoft.CodeAnalysis.IParameterSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.IFieldSymbol},Microsoft.CodeAnalysis.ISymbol@,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IOperation}@)">
            <summary>
            Matches a pattern where the first statement is an if statement that ensures a cast
            of the parameter to the correct type, and either binds it through an "is" pattern
            or later assigns it to a local varaiable
            </summary>
            <param name="bodyOps">method body to search in</param>
            <param name="parameter">uncast object parameter</param>
            <param name="type">type which is being called</param>
            <param name="builder">members that may have been incidentally checked</param>
            <param name="otherC">if matched, the variable that the cast parameter was assigned to</param>
            <param name="statementsToCheck">remaining non-check, non-assignment operations
            to look for additional compared members. This can have statements even if there was no binding
            as long as it found an if check that checks the correct type</param>
            <returns>whether or not the pattern matched</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.ConvertToRecordHelpers.TryGetSuccessCondition(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.IOperation,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IOperation},System.Boolean@,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IOperation}@)">
            <summary>
            Attempts to get information about an if operation in an equals method,
            such as whether the condition being true would cause the method to return false
            and the remaining statments in the branch not returning false (if any)
            </summary>
            <param name="whenTrue">"then" branch</param>
            <param name="whenFalse">"else" branch (if any)</param>
            <param name="successRequirement">whether the condition being true would cause the method to return false
            or the condition being false would cause the method to return false</param>
            <param name="remainingStatements">Potential remaining statements of the branch that does not return false</param>
            <returns>whether the pattern was matched (one of the branches must have a simple "return false")</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.ConvertToRecordHelpers.OverridesEquals(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Whether the equals method overrides object or IEquatable Equals method
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.PositionalParameterInfo">
            <summary>
            Represents a property that should be added as a positional parameter
            </summary>
            <param name="Declaration">Original declaration, null iff IsInherited is true
            Null iff <see cref="P:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.PositionalParameterInfo.IsInherited"/> is true</param>
            <param name="Symbol">Symbol of the property</param>
            <param name="KeepAsOverride">Whether we should keep the original declaration present</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.PositionalParameterInfo.#ctor(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax,Microsoft.CodeAnalysis.IPropertySymbol,System.Boolean)">
            <summary>
            Represents a property that should be added as a positional parameter
            </summary>
            <param name="Declaration">Original declaration, null iff IsInherited is true
            Null iff <see cref="P:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.PositionalParameterInfo.IsInherited"/> is true</param>
            <param name="Symbol">Symbol of the property</param>
            <param name="KeepAsOverride">Whether we should keep the original declaration present</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.PositionalParameterInfo.Declaration">
            <summary>Original declaration, null iff IsInherited is true
            Null iff <see cref="P:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.PositionalParameterInfo.IsInherited"/> is true</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.PositionalParameterInfo.Symbol">
            <summary>Symbol of the property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.PositionalParameterInfo.KeepAsOverride">
            <summary>Whether we should keep the original declaration present</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.PositionalParameterInfo.IsInherited">
            <summary>
            Whether this property is inherited from another base record
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.PositionalParameterInfo.ConvertStatus">
            <summary>
            for each property, say whether we can convert
            to primary constructor parameter or not (and whether it would imply changes)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.PositionalParameterInfo.ConvertStatus.DoNotConvert">
            <summary>
            no way we can convert this
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.PositionalParameterInfo.ConvertStatus.Override">
            <summary>
            we can convert this because we feel it would be used in a primary constructor,
            but some accessibility is non-default and we want to override
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.PositionalParameterInfo.ConvertStatus.OverrideIfConvertingSetToInit">
            <summary>
            we can convert this if we see that the user only ever uses set (not init)
            otherwise we should give an override
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ConvertToRecord.PositionalParameterInfo.ConvertStatus.AlwaysConvert">
            <summary>
            we can convert this without changing the meaning 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Copilot.CSharpCopilotCodeFixProvider">
            <summary>
            Code fix provider which provides fixes for Copilot diagnostics produced by
            <see cref="T:Microsoft.CodeAnalysis.Copilot.ICopilotCodeAnalysisService"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Copilot.CSharpCopilotCodeFixProvider.#ctor">
            <summary>
            Code fix provider which provides fixes for Copilot diagnostics produced by
            <see cref="T:Microsoft.CodeAnalysis.Copilot.ICopilotCodeAnalysisService"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Copilot.CSharpCopilotCodeFixProvider.ComputeRequestPriority">
            <summary>
            Ensure that fixes for Copilot diagnostics are always towards the bottom of the lightbulb.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Copilot.CSharpCopilotCodeFixProvider.GetFixAllProvider">
            <summary>
            We do not support a FixAll operation for Copilot suggestions.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Copilot.CSharpCopilotCodeFixProvider.CopilotDismissChangesCodeAction">
            <summary>
            Code action that triggers the dismissal of the Copilot suggestion.
            Reports telemetry when the suggestion is dismissed and will be extended to support
            dismissal of the diagnostic and removal of the suggestion from being shown again.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Copilot.CSharpCopilotCodeFixProvider.CopilotDismissChangesCodeAction.#ctor(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            Code action that triggers the dismissal of the Copilot suggestion.
            Reports telemetry when the suggestion is dismissed and will be extended to support
            dismissal of the diagnostic and removal of the suggestion from being shown again.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Copilot.CSharpCopilotCodeFixProvider.CopilotDocumentChangeCodeAction">
            <summary>
            The CodeAction that represents the change that will be made to the document per the Copilot suggestion.
            It also contains a special <see cref="T:Microsoft.CodeAnalysis.CSharp.Copilot.CSharpCopilotCodeFixProvider.CopilotDismissChangesCodeAction"/> that is reported as part
            of <see cref="P:Microsoft.CodeAnalysis.CSharp.Copilot.CSharpCopilotCodeFixProvider.CopilotDocumentChangeCodeAction.AdditionalPreviewFlavors"/> so that the lightbulb preview for this Copilot suggestion
            shows a 'Dismiss' hyperlink for dismissing bad Copilot suggestions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Copilot.CSharpCopilotCodeFixProvider.CopilotDocumentChangeCodeAction.#ctor(System.String,System.Func{System.IProgress{Microsoft.CodeAnalysis.CodeAnalysisProgress},System.Threading.CancellationToken,System.Threading.Tasks.Task{Microsoft.CodeAnalysis.Document}},System.String,Microsoft.CodeAnalysis.CSharp.Copilot.CSharpCopilotCodeFixProvider.CopilotDismissChangesCodeAction,Microsoft.CodeAnalysis.CodeActions.CodeActionPriority)">
            <summary>
            The CodeAction that represents the change that will be made to the document per the Copilot suggestion.
            It also contains a special <see cref="T:Microsoft.CodeAnalysis.CSharp.Copilot.CSharpCopilotCodeFixProvider.CopilotDismissChangesCodeAction"/> that is reported as part
            of <see cref="P:Microsoft.CodeAnalysis.CSharp.Copilot.CSharpCopilotCodeFixProvider.CopilotDocumentChangeCodeAction.AdditionalPreviewFlavors"/> so that the lightbulb preview for this Copilot suggestion
            shows a 'Dismiss' hyperlink for dismissing bad Copilot suggestions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Debugging.CSharpBreakpointResolutionService.ResolveBreakpointAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
            <summary>
            Returns null if a breakpoint can't be placed at the specified position.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Debugging.CSharpProximityExpressionsService">
            <summary>
            Given a position in a source file, returns the expressions in close proximity that should
            show up in the debugger 'autos' window.  In general, the expressions we place into the autos
            window are things that appear to be 'side effect free'.  Note: because we only use the syntax
            tree for this, it's possible for us to get this wrong.  However, this should only happen in
            code that behaves unexpectedly.  For example, we will assume that "a + b" is side effect free
            (when in practice it may not be).  
            
            The general tactic we take is to add the expressions for the statements on the
            line the debugger is currently at.  We will also try to find the 'previous' statement as well
            to add the expressions from that.  The 'previous' statement is a bit of an interesting beast.
            Consider, for example, if the user has just jumped out of a switch and is the statement
            directly following it.  What is the previous statement?  Without keeping state, there's no way
            to know.  So, in this case, we treat all 'exit points' (i.e. the last statement of a switch
            section) of the switch statement as the 'previous statement'.  There are many cases like this
            we need to handle.  Basically anything that might have nested statements/blocks might
            contribute to the 'previous statement'
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Debugging.CSharpProximityExpressionsService.GetProximityExpressionsAsync(Microsoft.CodeAnalysis.Document,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Returns null indicating a failure.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Diagnostics.Analyzers.CSharpPreferFrameworkTypeDiagnosticAnalyzer.IsPredefinedTypeReplaceableWithFrameworkType(Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax)">
            <remarks>
             every predefined type keyword except <c>void</c> can be replaced by its framework type in code.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Diagnostics.SimplifyTypeNames.TypeSyntaxSimplifierWalker.s_predefinedTypeMetadataNames">
            <summary>
            This set contains the full names of types that have equivalent predefined names in the language.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Diagnostics.SimplifyTypeNames.TypeSyntaxSimplifierWalker._aliasedNames">
            <summary>
            Set of type and namespace names that have an alias associated with them.  i.e. if the
            user has <c>using X = System.DateTime</c>, then <c>DateTime</c> will be in this set.
            This is used so we can easily tell if we should try to simplify some identifier to an
            alias when we encounter it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Diagnostics.SimplifyTypeNames.TypeSyntaxSimplifierWalker.TrySimplify(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            This is the root helper that all other TrySimplify methods in this type must call
            through once they think there is a good chance something is simplifiable.  It does the
            work of actually going through the real simplification system to validate that the
            simplification is legal and does not affect semantics.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Diagnostics.AddBraces.CSharpAddBracesDiagnosticAnalyzer.ContainsInterleavedDirective(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,System.Threading.CancellationToken)">
            <summary>
            Check if there are interleaved directives on the statement.
            Handles special case with if/else.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Diagnostics.AddBraces.CSharpAddBracesDiagnosticAnalyzer.IsConsideredMultiLine(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            <para>In general, statements are considered multiline if any of the following span more than one line:</para>
            <list type="bullet">
            <item><description>The part of the statement preceding the embedded statement</description></item>
            <item><description>The embedded statement itself</description></item>
            <item><description>The part of the statement following the embedded statement, for example the
            <c>while (...);</c> portion of a <c>do ... while (...);</c> statement</description></item>
            </list>
            <para>The third condition is not checked for <c>else</c> clauses because they are only considered multiline
            when their embedded statement is multiline.</para>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Diagnostics.AddBraces.CSharpAddBracesDiagnosticAnalyzer.RequiresBracesToMatchContext(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Determines whether <paramref name="statement"/> should use braces under a
            <see cref="F:Microsoft.CodeAnalysis.CodeStyle.PreferBracesPreference.WhenMultiline"/> preference due to the presence of braces on one or more
            sibling statements (the "context").
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Diagnostics.AddBraces.CSharpAddBracesDiagnosticAnalyzer.GetOutermostIfStatementOfSequence(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the top-most <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax"/> for which <paramref name="ifStatementOrElseClause"/> is
            part of the <c>if</c>/<c>else if</c>/<c>else</c> sequence.
            </summary>
            <remarks>
            <para>For the purpose of brace usage analysis, the embedded statements of an <c>if</c>/<c>else if</c>/<c>else</c>
            sequence are considered sibling statements, even though they don't appear as immediate siblings in the
            syntax tree. This method walks up the syntax tree to find the <c>if</c> statement that starts the
            sequence.</para>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Diagnostics.AddBraces.CSharpAddBracesDiagnosticAnalyzer.AnyPartOfIfSequenceUsesBraces(Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax)">
            <summary>
            Determines if any embedded statement of an <c>if</c>/<c>else if</c>/<c>else</c> sequence uses braces. Only
            the embedded statements falling <em>immediately</em> under one of these nodes are checked.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DocumentationComments.CSharpAddDocCommentNodesCodeFixProvider.CS1573">
            <summary>
            Parameter has no matching param tag in XML comment
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DocumentationComments.CSharpRemoveDocCommentNodeCodeFixProvider.CS1571">
            <summary>
            Duplicate param tag
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DocumentationComments.CSharpRemoveDocCommentNodeCodeFixProvider.CS1572">
            <summary>
            Param tag with no matching parameter
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DocumentationComments.CSharpRemoveDocCommentNodeCodeFixProvider.CS1710">
            <summary>
            Duplicate typeparam tag
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.BreakpointSpans.TryGetClosestBreakpointSpan(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Int32,Microsoft.CodeAnalysis.Text.TextSpan@)">
            <summary>
            Given a syntax token determines a text span delimited by the closest applicable sequence points 
            encompassing the token.
            </summary>
            <param name="minLength">
            In case there are multiple breakpoint spans starting at the given <paramref name="position"/>,
            <paramref name="minLength"/> can be used to disambiguate between them. 
            The inner-most available span whose length is at least <paramref name="minLength"/> is returned.
            </param>
            <remarks>
            If the span exists it is possible to place a breakpoint at the given position.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.BreakpointSpans.IsBreakableExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
             <summary>
             There are a few places where we allow breakpoints on expressions. 
            
             1) When the expression is the body of a lambda/method/operator/property/indexer.
             2) The expression is a breakable expression inside a query expression.
             3) The expression is in a for statement initializer, condition or incrementor.
             4) The expression is a foreach initializer.
             5) The expression is the value of an arm of a switch expression
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.CSharpEditAndContinueAnalyzer.TryFindMemberDeclaration(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Collections.OneOrMany{Microsoft.CodeAnalysis.SyntaxNode}@)">
            <returns>
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax"/> for methods, operators, constructors, destructors and accessors.
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax"/> for field initializers.
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax"/> for property initializers and expression bodies.
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax"/> for indexer expression bodies.
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax"/> for getter of an expression-bodied property/indexer.
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax"/> for top-level statements.
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax"/> for record copy-constructors.
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax"/> for primary constructors.
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax"/> for record primary constructor parameters.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.CSharpEditAndContinueAnalyzer.GetExceptionHandlingAncestors(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            Return nodes that represent exception handlers encompassing the given active statement node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.CSharpEditAndContinueAnalyzer.GetExceptionHandlingRegion(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean@)">
            <summary>
            An active statement (leaf or not) inside a "catch" makes the catch block read-only.
            An active statement (leaf or not) inside a "finally" makes the whole try/catch/finally block read-only.
            An active statement (non leaf)    inside a "try" makes the catch/finally block read-only.
            </summary>
            <remarks>
            Exception handling regions are only needed to be tracked if they contain user code.
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax"/> and using <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax"/> generate finally blocks,
            but they do not contain non-hidden sequence points.
            </remarks>
            <param name="node">An exception handling ancestor of an active statement node.</param>
            <param name="coversAllChildren">
            True if all child nodes of the <paramref name="node"/> are contained in the exception region represented by the <paramref name="node"/>.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.CSharpEditAndContinueAnalyzer.ReportRudeEditsForSwitchWhenClauses(Microsoft.CodeAnalysis.EditAndContinue.RudeEditDiagnosticsBuilder,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Reports rude edits when an active statement is a when clause in a switch statement and any of the switch cases or the switch value changed.
            This is necessary since the switch emits long-lived synthesized variables to store results of pattern evaluations.
            These synthesized variables are mapped to the slots of the new methods via ordinals. The mapping preserves the values of these variables as long as 
            exactly the same variables are emitted for the new switch as they were for the old one and their order didn't change either.
            This is guaranteed if none of the case clauses have changed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.EditAndContinue.CopyConstructorDeclarationBody">
            <summary>
            record [|C{T}|](int a, int b);
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.CopyConstructorDeclarationBody.#ctor(Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax)">
            <summary>
            record [|C{T}|](int a, int b);
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.EditAndContinue.ExplicitAutoPropertyAccessorDeclarationBody">
            <summary>
            Auto-property accessor:
              T P { [|get;|] }
              T P { [|set;|] }
              T P { [|init;|] }
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.ExplicitAutoPropertyAccessorDeclarationBody.#ctor(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax)">
            <summary>
            Auto-property accessor:
              T P { [|get;|] }
              T P { [|set;|] }
              T P { [|init;|] }
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.EditAndContinue.FieldWithInitializerDeclarationBody">
            <summary>
            Breakpoint spans:
            
            [|public int a = expr;|]
            [|public int a = expr|], [|b = expr|];
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.FieldWithInitializerDeclarationBody.#ctor(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax)">
            <summary>
            Breakpoint spans:
            
            [|public int a = expr;|]
            [|public int a = expr|], [|b = expr|];
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.EditAndContinue.InstanceConstructorDeclarationBody.ExplicitBody">
            <summary>
            Expression or block body.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.EditAndContinue.InstanceConstructorDeclarationBody.ParameterClosure">
            <summary>
            Node that represents the closure that constructor parameters captured within its body are lifted to.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.EditAndContinue.OrdinaryInstanceConstructorWithExplicitInitializerDeclarationBody">
            <summary>
            C() : this(...) { ... }
            C() : base(...) { ... }
            
            C() : this(...) => ...
            C() : base(...) => ...
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.OrdinaryInstanceConstructorWithExplicitInitializerDeclarationBody.#ctor(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax)">
            <summary>
            C() : this(...) { ... }
            C() : base(...) { ... }
            
            C() : this(...) => ...
            C() : base(...) => ...
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.EditAndContinue.OrdinaryInstanceConstructorWithImplicitInitializerDeclarationBody">
            <summary>
            C() { ... }
            C() => ...
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.OrdinaryInstanceConstructorWithImplicitInitializerDeclarationBody.#ctor(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax)">
            <summary>
            C() { ... }
            C() => ...
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.EditAndContinue.PrimaryConstructorDeclarationBody">
            <summary>
            Implicit initializer: class [|C(int a, int b)|] : B;
            Explicit initializer: class C(int a, int b) : [|B(expr)|];
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.PrimaryConstructorDeclarationBody.#ctor(Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax)">
            <summary>
            Implicit initializer: class [|C(int a, int b)|] : B;
            Explicit initializer: class C(int a, int b) : [|B(expr)|];
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.EditAndContinue.PrimaryConstructorWithExplicitInitializerDeclarationBody">
            <summary>
            Breakpoint spans:
            
            class C(int a, int b) : [|B(expr)|];
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.PrimaryConstructorWithExplicitInitializerDeclarationBody.#ctor(Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax)">
            <summary>
            Breakpoint spans:
            
            class C(int a, int b) : [|B(expr)|];
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.EditAndContinue.PrimaryConstructorWithImplicitInitializerDeclarationBody">
            <summary>
            Breakpoint spans:
            
            class [|C(int a, int b)|] : B;
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.PrimaryConstructorWithImplicitInitializerDeclarationBody.#ctor(Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax)">
            <summary>
            Breakpoint spans:
            
            class [|C(int a, int b)|] : B;
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.EditAndContinue.PropertyOrIndexerAccessorDeclarationBody">
             <summary>
             Property or indexer accessor with explicit body:
               T P { get => [|expr;|] }
               T P { set => [|expr;|] }
               T P { init => [|expr;|] }
               T P { get { ... } }
               T P { set { ... } }
               T P { init { ... } }
               T this[...] { get => [|expr;|] }
               T this[...] { set => [|expr;|] }
               T this[...] { get { ... } }
               T this[...] { set { ... } }
            
             Property or indexer with explicit body:
               T P => [|expr;|]
               T this[...] => [|expr;|]
               
             Auto-property accessor:
               T P { [|get;|] }
               T P { [|set;|] }
               T P { [|init;|] }
               
             Primary record auto-property: 
               record R([|T P|])
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.EditAndContinue.PropertyOrIndexerAccessorDeclarationBody.ExplicitBody">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax"/> or <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax"/> or <see langword="null"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.EditAndContinue.PropertyOrIndexerAccessorDeclarationBody.HeaderActiveStatement">
            <summary>
            Active statement outside of <see cref="P:Microsoft.CodeAnalysis.CSharp.EditAndContinue.PropertyOrIndexerAccessorDeclarationBody.ExplicitBody"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.EditAndContinue.PropertyOrIndexerAccessorWithExplicitBodyDeclarationBody">
            <summary>
            Property accessor with explicit body:
              T P { get => [|expr;|] }
              T P { set => [|expr;|] }
              T P { init => [|expr;|] }
              T P { get { ... } }
              T P { set { ... } }
              T P { init { ... } }
              T this[...] { get => [|expr;|] }
              T this[...] { set => [|expr;|] }
              T this[...] { get { ... } }
              T this[...] { set { ... } }
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.PropertyOrIndexerAccessorWithExplicitBodyDeclarationBody.#ctor(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax)">
            <summary>
            Property accessor with explicit body:
              T P { get => [|expr;|] }
              T P { set => [|expr;|] }
              T P { init => [|expr;|] }
              T P { get { ... } }
              T P { set { ... } }
              T P { init { ... } }
              T this[...] { get => [|expr;|] }
              T this[...] { set => [|expr;|] }
              T this[...] { get { ... } }
              T this[...] { set { ... } }
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.EditAndContinue.PropertyOrIndexerWithExplicitBodyDeclarationBody">
            <summary>
            Property or with explicit body:
              T P => [|expr;|]
              T this[...] => [|expr;|]
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.PropertyOrIndexerWithExplicitBodyDeclarationBody.#ctor(Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax)">
            <summary>
            Property or with explicit body:
              T P => [|expr;|]
              T this[...] => [|expr;|]
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.EditAndContinue.RecordParameterDeclarationBody">
            <summary>
            record C([Attr] [|in int a|] = 1);
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.RecordParameterDeclarationBody.#ctor(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax)">
            <summary>
            record C([Attr] [|in int a|] = 1);
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer">
            <summary>
            Creates a syntax comparer
            </summary>
            <param name="oldRoot">The root node to start comparisons from</param>
            <param name="newRoot">The new root node to compare against</param>
            <param name="oldRootChildren">Child nodes that should always be compared</param>
            <param name="newRootChildren">New child nodes to compare against</param>
            <param name="compareStatementSyntax">Whether this comparer is in "statement mode"</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.#ctor(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Boolean)">
            <summary>
            Creates a syntax comparer
            </summary>
            <param name="oldRoot">The root node to start comparisons from</param>
            <param name="newRoot">The new root node to compare against</param>
            <param name="oldRootChildren">Child nodes that should always be compared</param>
            <param name="newRootChildren">New child nodes to compare against</param>
            <param name="compareStatementSyntax">Whether this comparer is in "statement mode"</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.Label">
            <summary>
            Assumptions:
            - Each listed label corresponds to one or more syntax kinds.
            - Nodes with same labels might produce Update edits, nodes with different labels don't. 
            - If <see cref="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.TiedToAncestor(Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.Label)"/> is true for a label then all its possible parent labels must precede the label.
              (i.e. both MethodDeclaration and TypeDeclaration must precede TypeParameter label).
            - All descendants of a node whose kind is listed here will be ignored regardless of their labels
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.TiedToAncestor(Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.Label)">
            <summary>
            Return 1 if it is desirable to report two edits (delete and insert) rather than a move edit
            when the node changes its parent.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.GetDescendantTokensIgnoringSeparators``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0})">
            <summary>
            Enumerates tokens of all nodes in the list. Doesn't include separators.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.ComputeDistance(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Calculates the distance between two syntax nodes, disregarding trivia. 
            </summary>
            <remarks>
            Distance is a number within [0, 1], the smaller the more similar the nodes are. 
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.ComputeDistance(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Calculates the distance between two syntax tokens, disregarding trivia. 
            </summary>
            <remarks>
            Distance is a number within [0, 1], the smaller the more similar the tokens are. 
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.ComputeDistance(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Calculates the distance between two sequences of syntax tokens, disregarding trivia. 
            </summary>
            <remarks>
            Distance is a number within [0, 1], the smaller the more similar the sequences are. 
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.ComputeDistance(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Calculates the distance between two sequences of syntax nodes, disregarding trivia. 
            </summary>
            <remarks>
            Distance is a number within [0, 1], the smaller the more similar the sequences are. 
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.GetSequenceEdits(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Calculates the edits that transform one sequence of syntax nodes to another, disregarding trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.GetSequenceEdits(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Calculates the edits that transform one sequence of syntax nodes to another, disregarding trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.GetSequenceEdits(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Calculates the edits that transform one sequence of syntax tokens to another, disregarding trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.GetSequenceEdits(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxToken},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Calculates the edits that transform one sequence of syntax tokens to another, disregarding trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxUtilities.IsAsyncDeclaration(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            True if the specified declaration node is an async method, anonymous function, lambda, local function.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxUtilities.GetSuspensionPoints(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns a list of all await expressions, await foreach statements, await using declarations and yield statements in the given body,
            in the order in which they occur.
            </summary>
            <returns>
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax"/> for await expressions,
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax"/> for yield return statements,
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax"/> for await foreach statements,
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax"/> for await using declarators.
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax"/> for await using statements.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Features.EmbeddedLanguages.CSharpTestEmbeddedLanguageClassifier.StripMarkupCharacters(Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
            <summary>
            Takes a <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence"/> and returns the same characters from it, without any characters
            corresponding to test markup (e.g. <c>$$</c> and the like).  Because the virtual chars contain their
            original text span, these final virtual chars can be used both as the underlying source of a <see
            cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> (which only cares about their <see cref="T:System.Char"/> value), as well as the way to then map
            positions/spans within that <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> to actual full virtual char spans in the original
            document for classification.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Features.EmbeddedLanguages.CSharpTestEmbeddedLanguageClassifier.VirtualCharSequenceSourceText">
            <summary>
            Trivial implementation of a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> that directly maps over a <see
            cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ExternalAccess.Pythia.Api.IPythiaDeclarationNameRecommenderImplementation.ProvideRecommendationsAsync(Microsoft.CodeAnalysis.CSharp.ExternalAccess.Pythia.Api.PythiaDeclarationNameContext,System.Threading.CancellationToken)">
            <summary>
            Order of returned recommendation decides the order of those items in completion list
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ExternalAccess.Pythia.Api.PythiaDeclarationNameContext.LeftToken">
            <summary>
            The token to the left of <see cref="P:Microsoft.CodeAnalysis.CSharp.ExternalAccess.Pythia.Api.PythiaDeclarationNameContext.Position"/>. This token may be touching the position.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpExtractMethodService.CSharpMethodExtractor.CSharpCodeGenerator.AddComplexFlowControlProcessingStatements(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax})">
            <summary>
            Adds the statements after the call to the newly extracted method to handle processing of the control
            flow return value, and optionally the normal return value of the method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpExtractMethodService.CSharpMethodExtractor.CSharpCodeGenerator.ConvertComplexControlFlowStatements(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax})">
            <summary>
            Converts existing <c>break, continue, and return</c> statements into a <c>return</c> statement that
            returns which control flow construct was hit.
            </summary>
            <param name="statements"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpExtractMethodService.CSharpMethodExtractor.CSharpCodeGenerator.FixDeclarationExpressionsAndDeclarationPatterns(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.SyntaxAnnotation})">
            <summary>
            If the statement has an <c>out var</c> declaration expression for a variable which
            needs to be removed, we need to turn it into a plain <c>out</c> parameter, so that
            it doesn't declare a duplicate variable.
            If the statement has a pattern declaration (such as <c>3 is int i</c>) for a variable
            which needs to be removed, we will annotate it as a conflict, since we don't have
            a better refactoring.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpExtractMethodService.CSharpSelectionResult.ExpressionResult">
            <summary>
            Used when selecting just an expression to extract.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpExtractMethodService.CSharpSelectionResult.ExpressionResult.#ctor(Microsoft.CodeAnalysis.SemanticDocument,Microsoft.CodeAnalysis.ExtractMethod.SelectionType,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Used when selecting just an expression to extract.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpExtractMethodService.CSharpSelectionResult.StatementResult">
            <summary>
            Used when extracting either a single statement, or multiple statements to extract.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpExtractMethodService.CSharpSelectionResult.StatementResult.#ctor(Microsoft.CodeAnalysis.SemanticDocument,Microsoft.CodeAnalysis.ExtractMethod.SelectionType,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Used when extracting either a single statement, or multiple statements to extract.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.GenerateConstructors.CSharpGenerateConstructorsCodeRefactoringProvider.#ctor(Microsoft.CodeAnalysis.PickMembers.IPickMembersService)">
            <summary>
            For testing purposes only.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.KeywordHighlighting.KeywordHighlighters.LoopHighlighter.HighlightRelatedKeywords(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.List{Microsoft.CodeAnalysis.Text.TextSpan},System.Boolean,System.Boolean)">
            <summary>
            Finds all breaks and continues that are a child of this node, and adds the appropriate spans to the spans list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.KeywordHighlighting.KeywordHighlighters.ReturnStatementHighlighter.HighlightRelatedKeywords(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.List{Microsoft.CodeAnalysis.Text.TextSpan})">
            <summary>
            Finds all returns that are children of this node, and adds the appropriate spans to the spans list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.KeywordHighlighting.KeywordHighlighters.SwitchStatementHighlighter.HighlightRelatedKeywords(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.List{Microsoft.CodeAnalysis.Text.TextSpan},System.Boolean,System.Boolean)">
            <summary>
            Finds all breaks and continues that are a child of this node, and adds the appropriate spans to the spans
            list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.KeywordHighlighting.KeywordHighlighters.YieldStatementHighlighter.HighlightRelatedKeywords(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.List{Microsoft.CodeAnalysis.Text.TextSpan})">
            <summary>
            Finds all returns that are children of this node, and adds the appropriate spans to the spans list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ImplementInterface.AbstractChangeImplementationCodeRefactoringProvider.GetImplementedMembers(Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.INamedTypeSymbol})">
            <summary>
            Returns a mapping from members in our containing types to all the interface members (of
            the sort we care about) that it implements.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.InlineHints.CSharpInlineHintsService">
            <summary>
            The service to locate all positions where inline hints should be placed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.InlineHints.CSharpInlineHintsService.#ctor">
            <summary>
            The service to locate all positions where inline hints should be placed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.InlineHints.CSharpInlineParameterNameHintsService">
            <summary>
            The service to locate the positions in which the adornments should appear
            as well as associate the adornments back to the parameter name
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.InlineHints.CSharpInlineParameterNameHintsService.#ctor">
            <summary>
            The service to locate the positions in which the adornments should appear
            as well as associate the adornments back to the parameter name
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.IntroduceVariable.CSharpIntroduceVariableService.CanIntroduceVariableFor(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            Checks for conditions where we should not generate a variable for an expression
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LineSeparators.CSharpLineSeparatorService.GetLineSeparatorsAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
            <summary>
            Given a tree returns line separator spans.
            The operation may take fairly long time on a big tree so it is cancellable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LineSeparators.CSharpLineSeparatorService.IsSeparableBlock(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>Node types that are interesting for line separation.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LineSeparators.CSharpLineSeparatorService.IsSeparableContainer(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>Node types that may contain separable blocks.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LineSeparators.CSharpLineSeparatorService.ProcessNodeList``1(Microsoft.CodeAnalysis.SyntaxList{``0},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
            <summary>
            If node is separable and not the last in its container => add line separator after the node
            If node is separable and not the first in its container => ensure separator before the node
            last separable node in Program needs separator after it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MakeLocalFunctionStatic.MakeLocalFunctionStaticCodeFixHelper.CreateParameterSymbols(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISymbol})">
            <summary>
            Creates a new parameter symbol paired with the original captured symbol for each captured variables.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MetadataAsSource.CSharpMetadataAsSourceService.AddNullableRegionsAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Adds <c>#nullable enable</c> and <c>#nullable disable</c> annotations to the file as necessary.  Note that
            this does not try to be 100% accurate, but rather it handles the most common cases out there.  Specifically,
            if a file contains any nullable annotated/not-annotated types, then we prefix the file with <c>#nullable
            enable</c>.  Then if we hit any members that explicitly have *oblivious* types, but no annotated or
            non-annotated types, then we switch to <c>#nullable disable</c> for those specific members.
            <para/>
            This is technically innacurate for possible, but very uncommon cases.  For example, if the user's code
            explicitly did something like this:
            
            <code>
            public void Goo(string goo,
                            #nullable disable
                            string bar
                            #nullable enable
                            string baz);
            </code>
            
            Then we would be unable to handle that.  However, this is highly unlikely to happen, and so we accept the
            inaccuracy for the purpose of simplicity and for handling the much more common cases of either the entire
            file being annotated, or the user individually disabling annotations at the member level.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.QuickInfo.CSharpSemanticQuickInfoProvider.GetBindableNodeForTokenIndicatingLambda(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            If the token is the '=>' in a lambda, or the 'delegate' in an anonymous function,
            return the syntax for the lambda or anonymous function.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ReplacePropertyWithMethods.CSharpReplacePropertyWithMethodsService.IsValueName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax)">
            <summary>
            Used by the documentation comment rewriters to identify top-level <c>&lt;value&gt;</c> nodes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SignatureHelp.AbstractCSharpSignatureHelpProvider.GetAwaitableUsage(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.SemanticModel,System.Int32)">
            <summary>
            We no longer show awaitable usage text in SignatureHelp, but IntelliCode expects this
            method to exist.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SignatureHelp.ElementAccessExpressionSignatureHelpProvider.IncompleteElementAccessExpression">
            Error tolerance case for
                "goo[$$]" or "goo?[$$]"
            which is parsed as an ArrayTypeSyntax variable declaration instead of an ElementAccessExpression  
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SignatureHelp.ElementAccessExpressionSignatureHelpProvider.ConditionalAccessExpression">
            Error tolerance case for
                "new String()?[$$]"
            which is parsed as a BracketedArgumentListSyntax parented by an ElementBindingExpressionSyntax parented by a ConditionalAccessExpressionSyntax
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SignatureHelp.LightweightOverloadResolution">
            <summary>
            Helper type that allows signature help to make better decisions about which overload the user is likely choosing
            when the compiler itself bails out and gives a generic list of options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SignatureHelp.LightweightOverloadResolution.#ctor(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax})">
            <summary>
            Helper type that allows signature help to make better decisions about which overload the user is likely choosing
            when the compiler itself bails out and gives a generic list of options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SignatureHelp.LightweightOverloadResolution.GuessCurrentSymbolAndParameter(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IMethodSymbol})">
            <summary>
            If the symbol could not be bound, we could be dealing with a partial invocation, we'll try to find a possible overload.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SignatureHelp.LightweightOverloadResolution.TryFindParameterIndexIfCompatibleMethod(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Simulates overload resolution with the arguments provided so far and determines if you might be calling this overload.
            Returns true if an overload is acceptable. In that case, we output the parameter that should be highlighted given the cursor's
            position in the partial invocation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SignatureHelp.LightweightOverloadResolution.IsCompatibleArgument(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax,Microsoft.CodeAnalysis.IParameterSymbol)">
            <summary>
            Determines if the given argument is compatible with the given parameter
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SignatureHelp.LightweightOverloadResolution.TryPrepareArgumentToParameterMap(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.Collections.TemporaryArray{System.Int32}@)">
            <summary>
            Find the parameter index corresponding to each argument provided
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SignatureHelp.LightweightOverloadResolution.GetArgumentIndex">
            <summary>
            Given the cursor position, find which argument is active.
            This will be useful to later find which parameter should be highlighted.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SignatureHelp.PrimaryConstructorBaseTypeSignatureHelpProvider">
            <summary>
            Implements SignatureHelp and ParameterInfo for <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.PrimaryConstructorBaseTypeSyntax"/>
            such as 'record Student(int Id) : Person($$"first", "last");`.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Snippets.CSharpForEachLoopSnippetProvider.GetPlaceHolderLocationsList(Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax,Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts,System.Threading.CancellationToken)">
            <summary>
            Goes through each piece of the foreach statement and extracts the identifiers
            as well as their locations to create SnippetPlaceholder's of each.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Snippets.CSharpSnippetIdentifiers">
            <summary>
            Contains C#-specific snippet identifiers.
            These either are C# keywords, contain C# keywords or represent C#-only language constructs
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Structure.IfDirectiveTriviaStructureProvider">
            <summary>
            Adds structure guides for the portions of a #if directive that are active.  The inactive sections already have
            structure guides added through <see cref="T:Microsoft.CodeAnalysis.CSharp.Structure.DisabledTextTriviaStructureProvider"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseExpressionBodyForLambda.UseExpressionBodyForLambdaHelpers.GetOptionSeverity(Microsoft.CodeAnalysis.CodeStyle.CodeStyleOption2{Microsoft.CodeAnalysis.CodeStyle.ExpressionBodyPreference})">
            <summary>
            Helper to get the true ReportDiagnostic severity for a given option.  Importantly, this
            handle ReportDiagnostic.Default and will map that back to the appropriate value in that
            case.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyHelper`1">
            <summary>
            Helper class that allows us to share lots of logic between the diagnostic analyzer and the
            code refactoring provider.  Those can't share a common base class due to their own inheritance
            requirements with <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> and "CodeRefactoringProvider".
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpIsAndCastCheckWithoutNameDiagnosticAnalyzer">
            <summary>
            DiagnosticAnalyzer that looks for is-tests and cast-expressions, and offers to convert them
            to use patterns.  i.e. if the user has <c>obj is TestFile &amp;&amp; ((TestFile)obj).Name == "Test"</c>
            it will offer to convert that <c>obj is TestFile file &amp;&amp; file.Name == "Test"</c>.
            
            Complements <see cref="T:Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpIsAndCastCheckDiagnosticAnalyzer"/> (which does the same,
            but only for code cases where the user has provided an appropriate variable name in
            code that can be used).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpIsAndCastCheckWithoutNameDiagnosticAnalyzer.#ctor">
            <summary>
            DiagnosticAnalyzer that looks for is-tests and cast-expressions, and offers to convert them
            to use patterns.  i.e. if the user has <c>obj is TestFile &amp;&amp; ((TestFile)obj).Name == "Test"</c>
            it will offer to convert that <c>obj is TestFile file &amp;&amp; file.Name == "Test"</c>.
            
            Complements <see cref="T:Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpIsAndCastCheckDiagnosticAnalyzer"/> (which does the same,
            but only for code cases where the user has provided an appropriate variable name in
            code that can be used).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpIsAndCastCheckWithoutNameDiagnosticAnalyzer.AnalyzeExpression(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax},System.Threading.CancellationToken)">
            <summary>
            Returns the name of the local to generate.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpAsAndMemberAccessDiagnosticAnalyzer">
            <summary>
            Looks for code of the forms:
            <code>
                (x as Y)?.Prop == constant
            </code>
            and converts it to:
            <code>
                x is Y { Prop: constant }
            </code>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpAsAndNullCheckDiagnosticAnalyzer">
            <summary>
            Looks for code of the forms:
            <code>
                var x = o as Type;
                if (x != null) ...
            </code>
            and converts it to:
            <code>
                if (o is Type x) ...
            </code>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpAsAndNullCheckDiagnosticAnalyzer.#ctor">
            <summary>
            Looks for code of the forms:
            <code>
                var x = o as Type;
                if (x != null) ...
            </code>
            and converts it to:
            <code>
                if (o is Type x) ...
            </code>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpIsAndCastCheckDiagnosticAnalyzer">
            <summary>
            Looks for code of the form:
            
                if (expr is Type)
                {
                    var v = (Type)expr;
                }
                
            and converts it to:
            
                if (expr is Type v)
                {
                }
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpUseNotPatternDiagnosticAnalyzer">
            <summary>
            Looks for code of the forms:
            
                var x = o as Type;
                if (!(x is Y y)) ...
            
            and converts it to:
            
                if (x is not Y y) ...
                
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpUseNotPatternDiagnosticAnalyzer.#ctor">
            <summary>
            Looks for code of the forms:
            
                var x = o as Type;
                if (!(x is Y y)) ...
            
            and converts it to:
            
                if (x is not Y y) ...
                
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.IsLambda(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns true if the specified node represents a lambda.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.GetLambda(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Given a node that represents a lambda body returns a node that represents the lambda.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.TryGetCorrespondingLambdaBody(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            See SyntaxNode.GetCorrespondingLambdaBody.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.IsLambdaBody(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            Returns true if the specified <paramref name="node"/> represents a body of a lambda.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.IsReducedSelectOrGroupByClause(Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            When queries are translated into expressions select and group-by expressions such that
            1) select/group-by expression is the same identifier as the "source" identifier and
            2) at least one Where or OrderBy clause but no other clause is present in the contained query body or
               the expression in question is a group-by expression and the body has no clause
            
            do not translate into lambdas.
            By "source" identifier we mean the identifier specified in the from clause that initiates the query or the query continuation that includes the body.
            
            The above condition can be derived from the language specification (chapter 7.16.2) as follows:
            - In order for 7.16.2.5 "Select clauses" to be applicable the following conditions must hold:
              - There has to be at least one clause in the body, otherwise the query is reduced into a final form by 7.16.2.3 "Degenerate query expressions".
              - Only where and order-by clauses may be present in the query body, otherwise a transformation in 7.16.2.4 "From, let, where, join and orderby clauses"
                produces pattern that doesn't match the requirements of 7.16.2.5.
              
            - In order for 7.16.2.6 "Groupby clauses" to be applicable the following conditions must hold:
              - Only where and order-by clauses may be present in the query body, otherwise a transformation in 7.16.2.4 "From, let, where, join and orderby clauses"
                produces pattern that doesn't match the requirements of 7.16.2.5.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.IsLambdaBodyStatementOrExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <remarks>
            In C# lambda bodies are expressions or block statements. In both cases it's a single node.
            In VB a lambda body might be a sequence of nodes (statements). 
            We define this function to minimize differences between C# and VB implementation.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.TryGetLambdaBodies(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode@,Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            If the specified node represents a lambda returns a node (or nodes) that represent its body (bodies).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.AreEquivalentIgnoringLambdaBodies(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Compares content of two nodes ignoring lambda bodies and trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.DescendantTokensIgnoringLambdaBodies(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns all tokens of <paramref name="node"/> that are not part of lambda bodies.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.IsQueryPairLambda(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            "Pair lambda" is a synthesized lambda that creates an instance of an anonymous type representing a pair of values. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.IsClosureScope(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns true if the specified node is of a kind that could represent a closure scope -- that
            is, a scope of a captured variable.
            Doesn't check whether or not the node actually declares any captured variable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.GetDeclaratorPosition(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Given a node that represents a variable declaration, lambda or a closure scope return the position to be used to calculate 
            the node's syntax offset with respect to its containing member.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ConvertTypeOfToNameOf.CSharpConvertTypeOfToNameOfDiagnosticAnalyzer">
            <summary>
            Finds code like typeof(someType).Name and determines whether it can be changed to nameof(someType), if yes then it offers a diagnostic
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConvertTypeOfToNameOf.CSharpConvertTypeOfToNameOfDiagnosticAnalyzer.#ctor">
            <summary>
            Finds code like typeof(someType).Name and determines whether it can be changed to nameof(someType), if yes then it offers a diagnostic
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.NewLines.ConsecutiveStatementPlacement.CSharpConsecutiveStatementPlacementDiagnosticAnalyzer">
            <summary>
            Analyzer that finds code of the form:
            <code>
            if (cond)
            {
            }
            NextStatement();
            </code>
            
            And requires it to be of the form:
            <code>
            if (cond)
            {
            }
            
            NextStatement();
            </code>
            
            Specifically, all blocks followed by another statement must have a blank line between them.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryDiscardDesignation.CSharpRemoveUnnecessaryDiscardDesignationDiagnosticAnalyzer">
            <summary>
            Supports code like <c>o switch { int _ => ... }</c> to just <c>o switch { int => ... }</c> in C# 9 and above.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryLambdaExpression.CSharpRemoveUnnecessaryLambdaExpressionDiagnosticAnalyzer">
            <summary>
            DiagnosticAnalyzer that looks code like <c>Goo(() => Bar())</c> and offers to convert it to <c>Goo(Bar)</c>.
            This is only offered on C# 11 and above where this delegate can be cached and will not cause allocations each
            time.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryLambdaExpression.CSharpRemoveUnnecessaryLambdaExpressionDiagnosticAnalyzer.#ctor">
            <summary>
            DiagnosticAnalyzer that looks code like <c>Goo(() => Bar())</c> and offers to convert it to <c>Goo(Bar)</c>.
            This is only offered on C# 11 and above where this delegate can be cached and will not cause allocations each
            time.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.FileHeaders.CSharpFileHeaderHelper">
            <summary>
            Helper class used for working with file headers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.FileHeaders.CSharpFileHeaderHelper.#ctor">
            <summary>
            Helper class used for working with file headers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.FileHeaders.CSharpFileHeaderCodeFixProvider">
            <summary>
            Implements a code fix for file header diagnostics.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.FileHeaders.CSharpFileHeaderCodeFixProvider.#ctor">
            <summary>
            Implements a code fix for file header diagnostics.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.InlineDeclaration.CSharpInlineDeclarationDiagnosticAnalyzer">
            <summary>
            Looks for code of the form:
            
                int i;
                if (int.TryParse(s, out i)) { }
                
            And offers to convert it to:
            
                if (int.TryParse(s, out var i)) { }   or
                if (int.TryParse(s, out int i)) { }   or
            
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.InlineDeclaration.CSharpInlineDeclarationDiagnosticAnalyzer.#ctor">
            <summary>
            Looks for code of the form:
            
                int i;
                if (int.TryParse(s, out i)) { }
                
            And offers to convert it to:
            
                if (int.TryParse(s, out var i)) { }   or
                if (int.TryParse(s, out int i)) { }   or
            
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.MisplacedUsingDirectives.MisplacedUsingDirectivesCodeFixProvider">
            <summary>
            Implements a code fix for all misplaced using statements.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MisplacedUsingDirectives.MisplacedUsingDirectivesCodeFixProvider.#ctor">
            <summary>
            Implements a code fix for all misplaced using statements.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MisplacedUsingDirectives.MisplacedUsingDirectivesCodeFixProvider.s_warningAnnotation">
            <summary>
            A blanket warning that this codefix may change code so that it does not compile.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SimplifyPropertyPattern.CSharpSimplifyPropertyPatternDiagnosticAnalyzer">
            <summary>
            Looks for code of the form:
            
                <c>x is { a: { b: ... } }</c>
                
            and converts it to:
            
                <c>x is { a.b: ... }</c>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.AbstractCSharpUseCollectionExpressionDiagnosticAnalyzer">
            <summary>
            Base type for all analyzers that offer to update code to use a collection-expression.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForBuilderDiagnosticAnalyzer.AnalysisResult">
            <summary>
            Result of analyzing an <c>XXX.CreateBuilder</c> expression to see if it can be replaced with a collection
            expression.
            </summary>
            <param name="DiagnosticLocation">The location to put the diagnostic to tell they user they can convert this
            expression.</param>
            <param name="LocalDeclarationStatement">The declaration of the builder.  Will be removed if the user chooses to make
            the change.</param>
            <param name="CreationExpression">The location of the code like <c>builder.ToImmutable()</c> that will actually be
            replaced with the collection expression</param>
            <param name="Matches">The statements that are mutating the builder that will be converted into elements in the final
            collection expression.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForBuilderDiagnosticAnalyzer.AnalysisResult.#ctor(Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.UseCollectionExpression.CollectionMatch{Microsoft.CodeAnalysis.SyntaxNode}},System.Boolean)">
            <summary>
            Result of analyzing an <c>XXX.CreateBuilder</c> expression to see if it can be replaced with a collection
            expression.
            </summary>
            <param name="DiagnosticLocation">The location to put the diagnostic to tell they user they can convert this
            expression.</param>
            <param name="LocalDeclarationStatement">The declaration of the builder.  Will be removed if the user chooses to make
            the change.</param>
            <param name="CreationExpression">The location of the code like <c>builder.ToImmutable()</c> that will actually be
            replaced with the collection expression</param>
            <param name="Matches">The statements that are mutating the builder that will be converted into elements in the final
            collection expression.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForBuilderDiagnosticAnalyzer.AnalysisResult.DiagnosticLocation">
            <summary>The location to put the diagnostic to tell they user they can convert this
            expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForBuilderDiagnosticAnalyzer.AnalysisResult.LocalDeclarationStatement">
            <summary>The declaration of the builder.  Will be removed if the user chooses to make
            the change.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForBuilderDiagnosticAnalyzer.AnalysisResult.CreationExpression">
            <summary>The location of the code like <c>builder.ToImmutable()</c> that will actually be
            replaced with the collection expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForBuilderDiagnosticAnalyzer.AnalysisResult.Matches">
            <summary>The statements that are mutating the builder that will be converted into elements in the final
            collection expression.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForFluentDiagnosticAnalyzer.s_suffixes">
            <summary>
            Standard names to look at for the final <c>ToXXX</c> method.  For example "ToList", "ToArray", "ToImmutable",
            etc.  Note: this will just be done for a syntactic check of the method being called.  Additional checks will
            ensure that we are preserving semantics.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForFluentDiagnosticAnalyzer.AnalyzeInvocation(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.UseCollectionInitializer.UpdateExpressionState{Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Boolean,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Analyzes an expression looking for one of the form <c>CollectionCreation</c>, followed by some number of 
            <c>.Add(...)/.AddRange(...)</c> or <c>.ToXXX()</c> calls
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForFluentDiagnosticAnalyzer.IsMatch(Microsoft.CodeAnalysis.UseCollectionInitializer.UpdateExpressionState{Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax,System.Boolean,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.UseCollectionExpression.CollectionMatch{Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax}},System.Boolean@,System.Threading.CancellationToken)">
            <summary>
            Tests if this single `expr.SomeInvocation(...)` syntactically matches one of the allowed forms
            (ToList/AsSpan/etc.).  That includes that the arguments present to the invocation are acceptable for that
            particular method call.  If <paramref name="matchesInReverse"/> is provided, the arguments to the method will be
            appropriately extracted so that they can be placed in the final collection expression.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForFluentDiagnosticAnalyzer.AnalysisResult">
            <summary>
            Result of analyzing a fluent chain of collection additions (<c>XXX.Create().Add(...).AddRange(...).ToYYY()</c>
            expression to see if it can be replaced with a collection expression.
            </summary>
            <param name="ExistingInitializer">Optional existing initializer (for example: <c>new[] { 1, 2, 3 }</c>). Used to
            help determine the best collection expression final syntax.</param>
            <param name="CreationExpression">The location of the code like <c>builder.ToImmutable()</c> that will actually be
            replaced with the collection expression</param>
            <param name="PreMatches">The arguments being added to the collection that will be converted into elements in
            the final collection expression *before* the existing initializer elements.</param>
            <param name="PostMatches">The arguments being added to the collection that will be converted into elements in
            the final collection expression *after* the existing initializer elements.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForFluentDiagnosticAnalyzer.AnalysisResult.#ctor(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.UseCollectionExpression.CollectionMatch{Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax}},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.UseCollectionExpression.CollectionMatch{Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax}},System.Boolean)">
            <summary>
            Result of analyzing a fluent chain of collection additions (<c>XXX.Create().Add(...).AddRange(...).ToYYY()</c>
            expression to see if it can be replaced with a collection expression.
            </summary>
            <param name="ExistingInitializer">Optional existing initializer (for example: <c>new[] { 1, 2, 3 }</c>). Used to
            help determine the best collection expression final syntax.</param>
            <param name="CreationExpression">The location of the code like <c>builder.ToImmutable()</c> that will actually be
            replaced with the collection expression</param>
            <param name="PreMatches">The arguments being added to the collection that will be converted into elements in
            the final collection expression *before* the existing initializer elements.</param>
            <param name="PostMatches">The arguments being added to the collection that will be converted into elements in
            the final collection expression *after* the existing initializer elements.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForFluentDiagnosticAnalyzer.AnalysisResult.ExistingInitializer">
            <summary>Optional existing initializer (for example: <c>new[] { 1, 2, 3 }</c>). Used to
            help determine the best collection expression final syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForFluentDiagnosticAnalyzer.AnalysisResult.CreationExpression">
            <summary>The location of the code like <c>builder.ToImmutable()</c> that will actually be
            replaced with the collection expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForFluentDiagnosticAnalyzer.AnalysisResult.PreMatches">
            <summary>The arguments being added to the collection that will be converted into elements in
            the final collection expression *before* the existing initializer elements.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForFluentDiagnosticAnalyzer.AnalysisResult.PostMatches">
            <summary>The arguments being added to the collection that will be converted into elements in
            the final collection expression *after* the existing initializer elements.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForEmptyDiagnosticAnalyzer">
            <summary>
            Analyzer/fixer that looks for code of the form <c>X.Empty&lt;T&gt;()</c> or <c>X&lt;T&gt;.Empty</c> and offers to
            replace with <c>[]</c> if legal to do so.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForEmptyDiagnosticAnalyzer.#ctor">
            <summary>
            Analyzer/fixer that looks for code of the form <c>X.Empty&lt;T&gt;()</c> or <c>X&lt;T&gt;.Empty</c> and offers to
            replace with <c>[]</c> if legal to do so.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.UseCollectionExpressionHelpers.BannedTypes">
            <summary>
            Set of type-names that are blocked from moving over to collection expressions because the semantics of them are
            known to be specialized, and thus could change semantics in undesirable ways if the compiler emitted its own
            code as an replacement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpCollectionExpressionRewriter.CreateCollectionExpressionAsync``2(Microsoft.CodeAnalysis.Document,``0,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.UseCollectionExpression.CollectionMatch{``1}},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.UseCollectionExpression.CollectionMatch{``1}},System.Func{``0,Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax},System.Func{``0,Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax,``0},System.Threading.CancellationToken)">
            <summary>
            Creates the final collection-expression <c>[...]</c> that will replace the given <paramref
            name="expressionToReplace"/> expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpCollectionExpressionRewriter.DetermineEndOfLine``1(Microsoft.CodeAnalysis.ParsedDocument,``0,Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptions)">
            <summary>
            Use the same EOL text when producing the collection as the EOL on the line the original expression was on.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseCollectionInitializer.CSharpUseCollectionInitializerCodeFixProvider.CreateCollectionExpressionAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.CSharp.Syntax.BaseObjectCreationExpressionSyntax,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.UseCollectionExpression.CollectionMatch{Microsoft.CodeAnalysis.SyntaxNode}},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.UseCollectionExpression.CollectionMatch{Microsoft.CodeAnalysis.SyntaxNode}},System.Threading.CancellationToken)">
            <summary>
            Creates the final collection-expression <c>[...]</c> that will replace the given <paramref
            name="objectCreation"/> expression.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UseCompoundAssignment.CSharpUseCompoundCoalesceAssignmentDiagnosticAnalyzer">
            <summary>
            Looks for expressions of the form:
            <list type="number">
                <item><c>expr ?? (expr = value)</c> and converts it to <c>expr ??= value</c>.</item>
                <item><c>if (expr is null) expr = value</c> and converts it to <c>expr ??= value</c>.</item>
            </list>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseCompoundAssignment.CSharpUseCompoundCoalesceAssignmentDiagnosticAnalyzer.#ctor">
            <summary>
            Looks for expressions of the form:
            <list type="number">
                <item><c>expr ?? (expr = value)</c> and converts it to <c>expr ??= value</c>.</item>
                <item><c>if (expr is null) expr = value</c> and converts it to <c>expr ??= value</c>.</item>
            </list>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UseConditionalExpression.MultiLineConditionalExpressionFormattingRule">
            <summary>
            Special formatting rule that will convert a conditional expression into the following
            form if it has the <see cref="F:Microsoft.CodeAnalysis.UseConditionalExpression.UseConditionalExpressionCodeFixHelpers.SpecializedFormattingAnnotation"/> on it:
            
            <code>
                var v = expr
                    ? whenTrue
                    : whenFalse
            </code>
            
            i.e. both branches will be on a newline, indented once from the parent indentation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryCast.CSharpRemoveUnnecessaryCastDiagnosticAnalyzer">
            <summary>
            Supports simplifying cast expressions like <c>(T)x</c> as well as try-cast expressions like <c>x as T</c>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.RemoveUnusedMembers.CSharpRemoveUnusedMembersCodeFixProvider.AdjustAndAddAppropriateDeclaratorsToRemove(System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            This method adjusts the <paramref name="declarators"/> to remove based on whether or not all variable declarators
            within a field declaration should be removed,
            i.e. if all the fields declared within a field declaration are unused,
            we can remove the entire field declaration instead of individual variable declarators.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseIndexOperatorDiagnosticAnalyzer">
             <summary>
             <para>Analyzer that looks for code like:</para>
            
             <list type="number">
             <item><description><c>s[s.Length - n]</c> and offers to change that to <c>s[^n]</c></description></item>
             <item><description></description><c>s.Get(s.Length - n)</c> and offers to change that to <c>s.Get(^n)</c></item>
             </list>
            
             <para>In order to do convert between indexers, the type must look 'indexable'.  Meaning, it must
             have an <see cref="T:System.Int32"/>-returning property called <c>Length</c> or <c>Count</c>, and it must have both an
             <see cref="T:System.Int32"/>-indexer, and a <see cref="T:System.Index"/>-indexer.  In order to convert between methods, the type
             must have identical overloads except that one takes an <see cref="T:System.Int32"/>, and the other a <see cref="T:System.Index"/>.</para>
            
             <para>It is assumed that if the type follows this shape that it is well behaved and that this
             transformation will preserve semantics.  If this assumption is not good in practice, we
             could always limit the feature to only work on an allow list of known safe types.</para>
            
             <para>Note that this feature only works if the code literally has <c>expr1.Length - expr2</c>. If
             code has this, and is calling into a method that takes either an <see cref="T:System.Int32"/> or a <see cref="T:System.Index"/>,
             it feels very safe to assume this is well behaved and switching to <c>^expr2</c> is going to
             preserve semantics.</para>
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseIndexOperatorDiagnosticAnalyzer.InfoCache">
            <summary>
            Helper type to cache information about types while analyzing the compilation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseIndexOperatorDiagnosticAnalyzer.InfoCache.IndexType">
            <summary>
            The <see cref="T:System.Index"/> type.  Needed so that we only fixup code if we see the type
            we're using has an indexer that takes an <see cref="T:System.Index"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseIndexOperatorDiagnosticAnalyzer.InfoCache._methodToMemberInfo">
            <summary>
            Mapping from a method like <c>MyType.Get(int)</c> to the <c>Length</c>/<c>Count</c> property for
            <c>MyType</c> as well as the optional <c>MyType.Get(System.Index)</c> member if it exists.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseRangeOperatorDiagnosticAnalyzer">
             <summary>
             <para>Analyzer that looks for several variants of code like <c>s.Slice(start, end - start)</c> and offers to update
             to <c>s[start..end]</c> or <c>s.Slice(start..end)</c>.  In order to convert to the indexer, the type being called on
             needs a slice-like method that takes two ints, and returns an instance of the same type. It also needs a
             <c>Length</c>/<c>Count</c> property, as well as an indexer that takes a <see cref="T:System.Range"/> instance.  In
             order to convert between methods, there need to be two overloads that are equivalent except that one takes two ints,
             and the other takes a <see cref="T:System.Range"/>.</para>
            
             <para>It is assumed that if the type follows this shape that it is well behaved and that this transformation will
             preserve semantics.  If this assumption is not good in practice, we could always limit the feature to only work on
             an allow list of known safe types.</para>
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseRangeOperatorDiagnosticAnalyzer.#ctor">
             <summary>
             <para>Analyzer that looks for several variants of code like <c>s.Slice(start, end - start)</c> and offers to update
             to <c>s[start..end]</c> or <c>s.Slice(start..end)</c>.  In order to convert to the indexer, the type being called on
             needs a slice-like method that takes two ints, and returns an instance of the same type. It also needs a
             <c>Length</c>/<c>Count</c> property, as well as an indexer that takes a <see cref="T:System.Range"/> instance.  In
             order to convert between methods, there need to be two overloads that are equivalent except that one takes two ints,
             and the other takes a <see cref="T:System.Range"/>.</para>
            
             <para>It is assumed that if the type follows this shape that it is well behaved and that this transformation will
             preserve semantics.  If this assumption is not good in practice, we could always limit the feature to only work on
             an allow list of known safe types.</para>
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseRangeOperatorDiagnosticAnalyzer.InfoCache">
            <summary>
            Helper type to cache information about types while analyzing the compilation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseRangeOperatorDiagnosticAnalyzer.InfoCache.RangeType">
            <summary>
            The <see cref="T:System.Range"/> type.  Needed so that we only fixup code if we see the type
            we're using has an indexer that takes a <see cref="T:System.Range"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseRangeOperatorDiagnosticAnalyzer.ResultKind.Computed">
            <summary>
            like s.Substring(expr, s.Length - expr) or s.Substring(expr).  'expr' has to match on both sides.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseRangeOperatorDiagnosticAnalyzer.ResultKind.Constant">
            <summary>
            like s.Substring(constant1, s.Length - constant2).  the constants don't have to match.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseRangeOperatorDiagnosticAnalyzer.Result.Op1">
            <summary>
            Represents the starting operation of the range we are creating.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseRangeOperatorDiagnosticAnalyzer.Result.Op2">
            <summary>
            Can be null, if we are dealing with one-argument call to a slice-like method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.Helpers.TryGetLengthOrCountProperty(Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Find an `int MyType.Count` or `int MyType.Length` property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.Helpers.TryGetNoArgInt32Property(Microsoft.CodeAnalysis.ITypeSymbol,System.String)">
            <summary>
            Tried to find a public, non-static, int-returning property in the given type with the
            specified <paramref name="name"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.Helpers.IsInstanceLengthCheck(Microsoft.CodeAnalysis.IPropertySymbol,Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Checks if this <paramref name="operation"/> is `expr.Length` where `expr` is equivalent
            to the <paramref name="instance"/> we were originally invoking an accessor/method off
            of.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.Helpers.IsSubtraction(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.Operations.IBinaryOperation@)">
            <summary>
            Checks if <paramref name="operation"/> is a binary subtraction operator. If so, it
            will be returned through <paramref name="subtraction"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.Helpers.IsIntIndexingMethod(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Look for methods like "SomeType MyType.Get(int)".  Also matches against the 'getter'
            of an indexer like 'SomeType MyType.this[int]`
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.Helpers.IsTwoArgumentSliceLikeMethod(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Look for methods like "SomeType MyType.Slice(int start, int length)".  Note that the
            names of the parameters are checked to ensure they are appropriate slice-like.  These
            names were picked by examining the patterns in the BCL for slicing members.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.Helpers.IsOneArgumentSliceLikeMethod(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Look for methods like "SomeType MyType.Slice(int start)".  Note that the
            name of the parameter is checked to ensure it is appropriate slice-like.
            This name was picked by examining the patterns in the BCL for slicing members.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.Helpers.GetIndexer(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Finds a public, non-static indexer in the given type.  The indexer has to accept the
            provided <paramref name="parameterType"/> and must return the provided <paramref
            name="returnType"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.Helpers.GetOverload(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Finds a public, non-static overload of <paramref name="method"/> in the containing type.
            The overload must have the same return type as <paramref name="method"/>.  It must only
            have a single parameter, with the provided <paramref name="parameterType"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.MemberInfo.LengthLikeProperty">
            <summary>
            The <c>Length</c>/<c>Count</c> property on the type.  Must be public, non-static, no-parameter,
            <see cref="T:System.Int32"/>-returning.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.MemberInfo.OverloadedMethod">
            <summary>
            Optional paired overload that takes a <see cref="T:System.Range"/>/<see cref="T:System.Index"/> parameter instead.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseRangeOperatorCodeFixProvider.IsFromEnd(Microsoft.CodeAnalysis.IPropertySymbol,Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.IOperation@)">
            <summary>
            check if its the form: `expr.Length - value`.  If so, update rangeOperation to then
            point to 'value' so that we can generate '^value'.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CodeFixHelpers.IndexExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            Creates an `^expr` index expression from a given `expr`.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UseSystemThreadingLock.CSharpUseSystemThreadingLockDiagnosticAnalyzer">
            <summary>
            Looks for code of the form:
            
                private ... object _gate = new object();
                ...
                lock (_gate)
                {
                }
                
            and converts it to:
            
                private ... Lock _gate = new Lock();
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseSystemThreadingLock.CSharpUseSystemThreadingLockDiagnosticAnalyzer.#ctor">
            <summary>
            Looks for code of the form:
            
                private ... object _gate = new object();
                ...
                lock (_gate)
                {
                }
                
            and converts it to:
            
                private ... Lock _gate = new Lock();
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseSystemThreadingLock.CSharpUseSystemThreadingLockDiagnosticAnalyzer.GetAnalyzerCategory">
            <summary>
            A method body edit anywhere in a type will force us to reanalyze the whole type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UseNameofInAttribute.CSharpUseNameofInAttributeDiagnosticAnalyzer">
            <summary>
            Analyzer that looks for things like `NotNullIfNotNull("param")` and offers to use `NotNullIfNotNull(nameof(param))` instead.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UsePrimaryConstructor.CSharpUsePrimaryConstructorDiagnosticAnalyzer">
            <summary>
            Looks for code of the forms:
            <code>
                class Point
                {
                    private int x;
                    private int y;
            
                    public C(int x, int y)
                    {
                        this.x = x;
                        this.y = y;
                    }
                }
            </code>
            and converts it to:
            <code>
                class Point(int x, int y)
                {
                }
            </code>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UsePrimaryConstructor.CSharpUsePrimaryConstructorDiagnosticAnalyzer.#ctor">
            <summary>
            Looks for code of the forms:
            <code>
                class Point
                {
                    private int x;
                    private int y;
            
                    public C(int x, int y)
                    {
                        this.x = x;
                        this.y = y;
                    }
                }
            </code>
            and converts it to:
            <code>
                class Point(int x, int y)
                {
                }
            </code>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UsePrimaryConstructor.CSharpUsePrimaryConstructorDiagnosticAnalyzer.Analyzer">
            <summary>
            Helper type we create that encapsulates all the state we need while processing.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UsePrimaryConstructor.CSharpUsePrimaryConstructorDiagnosticAnalyzer.Analyzer.#ctor(Microsoft.CodeAnalysis.CSharp.UsePrimaryConstructor.CSharpUsePrimaryConstructorDiagnosticAnalyzer,Microsoft.CodeAnalysis.CodeStyle.CodeStyleOption2{System.Boolean},Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax,Microsoft.CodeAnalysis.PooledObjects.PooledDictionary{Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.IParameterSymbol},System.Collections.Concurrent.ConcurrentDictionary{Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.UsePrimaryConstructor.CSharpUsePrimaryConstructorDiagnosticAnalyzer.Analyzer})">
            <summary>
            Helper type we create that encapsulates all the state we need while processing.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.UsePrimaryConstructor.CSharpUsePrimaryConstructorDiagnosticAnalyzer.Analyzer._membersThatCannotBeRemoved">
            <summary>
            Needs to be concurrent as we can process members in parallel in <see
            cref="M:Microsoft.CodeAnalysis.CSharp.UsePrimaryConstructor.CSharpUsePrimaryConstructorDiagnosticAnalyzer.Analyzer.AnalyzeFieldOrPropertyReference(Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext)"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UsePrimaryConstructor.CSharpUsePrimaryConstructorCodeFixProvider.CSharpUsePrimaryConstructorFixAllProvider">
            <summary>
            Specialized fix-all provider.  Needed because the fix ends up needing to invoke 'find references' to update
            references to removed members to point at parameters.  This allows us to do all that work across all documents
            and diagnostics using a single <see cref="T:Microsoft.CodeAnalysis.Editing.SolutionEditor"/> that aggregates the results efficiently.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UseTupleSwap.CSharpUseTupleSwapDiagnosticAnalyzer">
             <summary>
             Looks for code of the form:
             
             <code>
                 var temp = expr_a;
                 expr_a = expr_b;
                 expr_b = temp;
             </code>
            
             and converts it to:
             
             <code>
                 (expr_b, expr_a) = (expr_a, expr_b);
             </code>
             
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UseLocalFunction.CSharpUseLocalFunctionDiagnosticAnalyzer">
            <summary>
            Looks for code of the form:
            
                Func&lt;int, int&gt; fib = n =>
                {
                    if (n &lt;= 2)
                        return 1
                        
                    return fib(n - 1) + fib(n - 2);
                }
                
            and converts it to:
            
                int fib(int n)
                {
                    if (n &lt;= 2)
                        return 1
                        
                    return fib(n - 1) + fib(n - 2);
                }
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UsePatternCombinators.AnalyzedPattern">
            <summary>
            Base class to represent a pattern constructed from various checks
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UsePatternCombinators.AnalyzedPattern.Type">
            <summary>
            Represents a type-pattern, constructed from an is-expression
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UsePatternCombinators.AnalyzedPattern.Source">
            <summary>
            Represents a source-pattern, constructed from C# patterns
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UsePatternCombinators.AnalyzedPattern.Source.#ctor(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax,Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Represents a source-pattern, constructed from C# patterns
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UsePatternCombinators.AnalyzedPattern.Constant">
            <summary>
            Represents a constant-pattern, constructed from an equality check
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UsePatternCombinators.AnalyzedPattern.Constant.#ctor(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Represents a constant-pattern, constructed from an equality check
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UsePatternCombinators.AnalyzedPattern.Relational">
            <summary>
            Represents a relational-pattern, constructed from relational operators
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UsePatternCombinators.AnalyzedPattern.Relational.#ctor(Microsoft.CodeAnalysis.Operations.BinaryOperatorKind,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Represents a relational-pattern, constructed from relational operators
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UsePatternCombinators.AnalyzedPattern.Binary">
            <summary>
            Represents an and/or pattern, constructed from a logical and/or expression.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UsePatternCombinators.AnalyzedPattern.Not">
            <summary>
            Represents a not-pattern, constructed from inequality check or a logical-not expression.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.UsePatternCombinators.CSharpUsePatternCombinatorsAnalyzer.ConstantResult.None">
            <summary>
            None of operands were constant.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.UsePatternCombinators.CSharpUsePatternCombinatorsAnalyzer.ConstantResult.Left">
            <summary>
            The left operand is the constant.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.UsePatternCombinators.CSharpUsePatternCombinatorsAnalyzer.ConstantResult.Right">
            <summary>
            The right operand is the constant.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UsePatternCombinators.CSharpUsePatternCombinatorsAnalyzer.Flip(Microsoft.CodeAnalysis.Operations.BinaryOperatorKind)">
            <summary>
            Changes the direction the operator is pointing at.
            </summary>
            <remarks>
            Relational patterns only come in the prefix form so we'll have to
            flip the operator if the constant happens to be on the left-hand-side.
            For instance: `123 &gt; x` would be rewritten as `x is &lt; 123`.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UseSimpleUsingStatement.UseSimpleUsingStatementDiagnosticAnalyzer">
             <summary>
             Looks for code like:
            
                 ```c#
                 using (var a = b)
                 using (var c = d)
                 using (var e = f)
                 {
                 }
                 ```
             
             And offers to convert it to:
            
                 ```c#
                 using var a = b;
                 using var c = d;
                 using var e = f;
                 ```
            
             (this of course works in the case where there is only one using).
             
             A few design decisions:
                 
             1. We only offer this if the entire group of usings in a nested stack can be
                converted.  We don't want to take a nice uniform group and break it into
                a combination of using-statements and using-declarations.  That may feel 
                less pleasant to the user than just staying uniform.
             
             2. We're conservative about converting.  Because `using`s may be critical for
                program correctness, we only convert when we're absolutely *certain* that
                semantics will not change.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseSimpleUsingStatement.UseSimpleUsingStatementDiagnosticAnalyzer.#ctor">
             <summary>
             Looks for code like:
            
                 ```c#
                 using (var a = b)
                 using (var c = d)
                 using (var e = f)
                 {
                 }
                 ```
             
             And offers to convert it to:
            
                 ```c#
                 using var a = b;
                 using var c = d;
                 using var e = f;
                 ```
            
             (this of course works in the case where there is only one using).
             
             A few design decisions:
                 
             1. We only offer this if the entire group of usings in a nested stack can be
                converted.  We don't want to take a nice uniform group and break it into
                a combination of using-statements and using-declarations.  That may feel 
                less pleasant to the user than just staying uniform.
             
             2. We're conservative about converting.  Because `using`s may be critical for
                program correctness, we only convert when we're absolutely *certain* that
                semantics will not change.
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UseUnboundGenericTypeInNameOf.CSharpUseUnboundGenericTypeInNameOfDiagnosticAnalyzer">
             <summary>
             Looks for code of the form:
             
             <code>
                 nameof(List&lt;...&gt;)
             </code>
            
             and converts it to:
             
             <code>
                 nameof(List&lt;&gt;)
             </code>
             
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseUnboundGenericTypeInNameOf.CSharpUseUnboundGenericTypeInNameOfDiagnosticAnalyzer.#ctor">
             <summary>
             Looks for code of the form:
             
             <code>
                 nameof(List&lt;...&gt;)
             </code>
            
             and converts it to:
             
             <code>
                 nameof(List&lt;&gt;)
             </code>
             
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AliasAmbiguousType.CSharpAliasAmbiguousTypeCodeFixProvider.CS0104">
            <summary>
            'reference' is an ambiguous reference between 'identifier' and 'identifier'
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.GenerateConstructor.GenerateConstructorCodeFixProvider">
            <summary>
            This <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/> gives users a way to generate constructors for an existing
            type when a user tries to 'new' up an instance of that type with a set of parameter that does
            not match any existing constructor.  i.e. it is the equivalent of 'Generate-Method' but for
            constructors.  Parameters for the constructor will be picked in a manner similar to Generate-
            Method.  However, this type will also attempt to hook up those parameters to existing fields
            and properties, or pass them to a this/base constructor if available.
            
            Importantly, this type is not responsible for generating constructors for a type based on 
            the user selecting some fields/properties of that type.  Nor is it responsible for generating
            derived class constructors for all unmatched base class constructors in a type hierarchy.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.GenerateConstructor.GenerateConstructorCodeFixProvider.#ctor">
            <summary>
            This <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/> gives users a way to generate constructors for an existing
            type when a user tries to 'new' up an instance of that type with a set of parameter that does
            not match any existing constructor.  i.e. it is the equivalent of 'Generate-Method' but for
            constructors.  Parameters for the constructor will be picked in a manner similar to Generate-
            Method.  However, this type will also attempt to hook up those parameters to existing fields
            and properties, or pass them to a this/base constructor if available.
            
            Importantly, this type is not responsible for generating constructors for a type based on 
            the user selecting some fields/properties of that type.  Nor is it responsible for generating
            derived class constructors for all unmatched base class constructors in a type hierarchy.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UseInterpolatedVerbatimString.CSharpUseInterpolatedVerbatimStringCodeFixProvider">
            <summary>
            Converts a verbatim interpolated string @$"" to an interpolated verbatim string $@""
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UseInterpolatedVerbatimString.CSharpUseInterpolatedVerbatimStringCodeFixProvider.#ctor">
            <summary>
            Converts a verbatim interpolated string @$"" to an interpolated verbatim string $@""
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpDeclarationComputer.GetExpressionBodySyntax(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Gets the expression-body syntax from an expression-bodied member. The
            given syntax must be for a member which could contain an expression-body.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Invert_if">
            <summary>Invert if</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Add_await_and_ConfigureAwaitFalse">
            <summary>Add 'await' and 'ConfigureAwait(false)'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.lambda_expression">
            <summary>&lt;lambda expression&gt;</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Autoselect_disabled_due_to_potential_lambda_declaration">
            <summary>Autoselect disabled due to potential lambda declaration.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.member_name">
            <summary>&lt;member name&gt; =</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Autoselect_disabled_due_to_possible_explicitly_named_anonymous_type_member_creation">
            <summary>Autoselect disabled due to possible explicitly named anonymous type member creation.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.pattern_variable">
            <summary>&lt;pattern variable&gt;</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Autoselect_disabled_due_to_potential_pattern_variable_declaration">
            <summary>Autoselect disabled due to potential pattern variable declaration.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.range_variable">
            <summary>&lt;range variable&gt;</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Autoselect_disabled_due_to_potential_range_variable_declaration">
            <summary>Autoselect disabled due to potential range variable declaration.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Remove_this_qualification">
            <summary>Remove 'this' qualification</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Selection_does_not_contain_a_valid_node">
            <summary>Selection does not contain a valid node</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Contains_invalid_selection">
            <summary>Contains invalid selection.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.The_selection_contains_syntactic_errors">
            <summary>The selection contains syntactic errors</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Selection_can_not_cross_over_preprocessor_directives">
            <summary>Selection can not cross over preprocessor directives.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Selection_can_not_contain_a_yield_statement">
            <summary>Selection can not contain a yield statement.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Selection_can_not_contain_throw_statement">
            <summary>Selection can not contain throw statement.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Selection_can_not_be_part_of_constant_initializer_expression">
            <summary>Selection can not be part of constant initializer expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Selection_can_not_contain_a_pattern_expression">
            <summary>Selection can not contain a pattern expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.The_selected_code_is_inside_an_unsafe_context">
            <summary>The selected code is inside an unsafe context.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.deprecated">
            <summary>deprecated</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.extension">
            <summary>extension</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.awaitable">
            <summary>awaitable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.awaitable_extension">
            <summary>awaitable, extension</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Organize_Usings">
            <summary>Organize Usings</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.try_block">
            <summary>try block</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.catch_clause">
            <summary>catch clause</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.filter_clause">
            <summary>filter clause</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.finally_clause">
            <summary>finally clause</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.fixed_statement">
            <summary>fixed statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.using_statement">
            <summary>using statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.lock_statement">
            <summary>lock statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.foreach_statement">
            <summary>foreach statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.asynchronous_foreach_statement">
            <summary>asynchronous foreach statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.using_declaration">
            <summary>using declaration</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.asynchronous_using_declaration">
            <summary>asynchronous using declaration</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.checked_statement">
            <summary>checked statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.unchecked_statement">
            <summary>unchecked statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.yield_return_statement">
            <summary>yield return statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.yield_break_statement">
            <summary>yield break statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.await_expression">
            <summary>await expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.lambda">
            <summary>lambda</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.anonymous_method">
            <summary>anonymous method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.from_clause">
            <summary>from clause</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.join_clause">
            <summary>join clause</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.let_clause">
            <summary>let clause</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.where_clause">
            <summary>where clause</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.orderby_clause">
            <summary>orderby clause</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.select_clause">
            <summary>select clause</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.groupby_clause">
            <summary>groupby clause</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.query_body">
            <summary>query body</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.into_clause">
            <summary>into clause</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.is_pattern">
            <summary>is pattern</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.deconstruction">
            <summary>deconstruction</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.tuple">
            <summary>tuple</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.out_var">
            <summary>out variable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.ref_local_or_expression">
            <summary>ref local or expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.switch_statement">
            <summary>switch statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.top_level_statement">
            <summary>top-level statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.top_level_code">
            <summary>top-level code</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.extern_alias">
            <summary>extern alias</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.using_directive">
            <summary>using directive</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.event_field">
            <summary>event field</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.conversion_operator">
            <summary>conversion operator</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.destructor">
            <summary>destructor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.indexer">
            <summary>indexer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.property_getter">
            <summary>property getter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.indexer_getter">
            <summary>indexer getter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.property_setter">
            <summary>property setter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.indexer_setter">
            <summary>indexer setter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.attribute_target">
            <summary>attribute target</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.The_name_0_does_not_exist_in_the_current_context">
            <summary>The name '{0}' does not exist in the current context.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Autoselect_disabled_due_to_namespace_declaration">
            <summary>Autoselect disabled due to namespace declaration.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Autoselect_disabled_due_to_type_declaration">
            <summary>Autoselect disabled due to type declaration.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Autoselect_disabled_due_to_possible_deconstruction_declaration">
            <summary>Autoselect disabled due to possible deconstruction declaration.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.designation_name">
            <summary>&lt;designation name&gt;</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.struct_name">
            <summary>&lt;struct name&gt;</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Convert_to_switch_statement">
            <summary>Convert to 'switch' statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Convert_to_switch_expression">
            <summary>Convert to 'switch' expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Use_recursive_patterns">
            <summary>Use recursive patterns</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Name">
            <summary>&lt;Name&gt;</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Autoselect_disabled_due_to_member_declaration">
            <summary>Autoselect disabled due to member declaration</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Suggested_name">
            <summary>(Suggested name)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Convert_to_foreach">
            <summary>Convert to 'foreach'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Convert_to_for">
            <summary>Convert to 'for'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Convert_to_method">
            <summary>Convert to method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Add_required_braces_for_single_line_control_statements">
            <summary>Add required braces for single-line control statements</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Apply_expression_block_body_preferences">
            <summary>Apply expression/block body preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Apply_inline_out_variable_preferences">
            <summary>Apply inline 'out' variables preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Make_private_field_readonly_when_possible">
            <summary>Make private fields readonly when possible</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Add_missing_usings">
            <summary>Add missing usings</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Introduce_using_statement">
            <summary>Introduce 'using' statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Warning_Inlining_temporary_into_conditional_method_call">
            <summary>Warning: Inlining temporary into conditional method call.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Warning_Inlining_temporary_variable_may_change_code_meaning">
            <summary>Warning: Inlining temporary variable may change code meaning.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.local_variable_declaration">
            <summary>local variable declaration</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.switch_statement_case_clause">
            <summary>switch statement case clause</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Reverse_for_statement">
            <summary>Reverse 'for' statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Convert_to_regular_string">
            <summary>Convert to regular string</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Convert_to_verbatim_string">
            <summary>Convert to verbatim string</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Change_to_as_expression">
            <summary>Change to 'as' expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Change_to_cast">
            <summary>Change to cast</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.record_">
            <summary>record</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.record_struct">
            <summary>record struct</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Enable_nullable_reference_types_in_project">
            <summary>Enable nullable reference types in project</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Enable_nullable_reference_types_in_solution">
            <summary>Enable nullable reference types in solution</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Selection_cannot_include_global_statements">
            <summary>Selection cannot include global statements</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Selection_cannot_include_top_level_statements">
            <summary>Selection cannot include top-level statements</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Convert_to_raw_string">
            <summary>Convert to raw string</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.without_leading_whitespace_may_change_semantics">
            <summary>... without leading whitespace (may change semantics)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Apply_blank_lines_between_consecutive_braces_preferences_experimental">
            <summary>Apply blank lines between consecutive braces preferences (experimental)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Apply_blank_line_after_colon_in_constructor_initializer_preferences_experimental">
            <summary>Apply blank line after colon in constructor initializer preferences (experimental)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Apply_conditional_delegate_call_preferences">
            <summary>Apply conditional delegate call preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Apply_deconstruct_preferences">
            <summary>Apply deconstruct preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Apply_default_T_preferences">
            <summary>Apply default(T) preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Apply_embedded_statements_on_same_line_preferences_experimental">
            <summary>Apply embedded statements on same line preferences (experimental)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Apply_local_over_anonymous_function_preferences">
            <summary>Apply local over anonymous function preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Apply_method_group_conversion_preferences">
            <summary>Apply method group conversion preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Apply_namespace_preferences">
            <summary>Apply namespace preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Apply_new_preferences">
            <summary>Apply new() preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Apply_pattern_matching_preferences">
            <summary>Apply pattern matching preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Apply_range_preferences">
            <summary>Apply range preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Apply_static_local_function_preferences">
            <summary>Apply static local function preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Apply_throw_expression_preferences">
            <summary>Apply throw expression preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Apply_using_statement_preferences">
            <summary>Apply using statement preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Apply_var_preferences">
            <summary>Apply 'var' preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Global_using_directives">
            <summary>Global 'using' directives</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Convert_0_to_record">
            <summary>Convert '{0}' to record</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Apply_readonly_struct_preferences">
            <summary>Apply 'readonly struct' preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Selection_cannot_be_in_constructor_initializer">
            <summary>Selection cannot be in constructor initializer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.init_only_property">
            <summary>init-only property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.for_loop">
            <summary>for loop</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.reversed_for_loop">
            <summary>reversed for loop</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.static_void_Main">
            <summary>static void Main</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.static_int_Main">
            <summary>static int Main</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Convert_to_regular_constructor">
            <summary>Convert to regular constructor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Apply_0">
            <summary>Apply '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Apply_Copilot_suggestion">
            <summary>Apply Copilot suggestion</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Apply_fix_from">
            <summary>Apply fix from</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Warning_colon_AI_suggestions_might_be_inaccurate">
            <summary>Warning: AI suggestions might be inaccurate.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.do_while_loop">
            <summary>do-while loop</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.required_property">
            <summary>required property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Convert_0_extension_methods_to_extension">
            <summary>Convert '{0}' extension methods to extension</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Convert_all_extension_methods_in_0_to_extension">
            <summary>Convert all extension methods in '{0}' to extension</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Convert_switch_statement_to_expression">
            <summary>Convert switch statement to expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_switch_expression">
            <summary>Use 'switch' expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_explicit_type_instead_of_var">
            <summary>Use explicit type instead of 'var'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_explicit_type">
            <summary>Use explicit type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.use_var_instead_of_explicit_type">
            <summary>use 'var' instead of explicit type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_implicit_type">
            <summary>Use implicit type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Using_directive_is_unnecessary">
            <summary>Using directive is unnecessary.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Add_braces">
            <summary>Add braces</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Add_braces_to_0_statement">
            <summary>Add braces to '{0}' statement.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Misplaced_using_directive">
            <summary>Misplaced using directive</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Move_misplaced_using_directives">
            <summary>Move misplaced using directives</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Using_directives_must_be_placed_inside_of_a_namespace_declaration">
            <summary>Using directives must be placed inside of a namespace declaration</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Using_directives_must_be_placed_outside_of_a_namespace_declaration">
            <summary>Using directives must be placed outside of a namespace declaration</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Warning_colon_Moving_using_directives_may_change_code_meaning">
            <summary>Warning: Moving using directives may change code meaning.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_expression_body_for_method">
            <summary>Use expression body for method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_block_body_for_method">
            <summary>Use block body for method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_block_body_for_accessor">
            <summary>Use block body for accessor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_block_body_for_constructor">
            <summary>Use block body for constructor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_block_body_for_indexer">
            <summary>Use block body for indexer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_block_body_for_operator">
            <summary>Use block body for operator</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_block_body_for_conversion_operator">
            <summary>Use block body for conversion operator</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_block_body_for_property">
            <summary>Use block body for property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_expression_body_for_accessor">
            <summary>Use expression body for accessor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_expression_body_for_constructor">
            <summary>Use expression body for constructor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_expression_body_for_indexer">
            <summary>Use expression body for indexer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_expression_body_for_operator">
            <summary>Use expression body for operator</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_expression_body_for_conversion_operator">
            <summary>Use expression body for conversion operator</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_expression_body_for_property">
            <summary>Use expression body for property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_block_body_for_local_function">
            <summary>Use block body for local function</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_expression_body_for_local_function">
            <summary>Use expression body for local function</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Unreachable_code_detected">
            <summary>Unreachable code detected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_pattern_matching">
            <summary>Use pattern matching</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_is_null_check">
            <summary>Use 'is null' check</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Prefer_null_check_over_type_check">
            <summary>Prefer 'null' check over type check</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_simple_using_statement">
            <summary>Use simple 'using' statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.using_statement_can_be_simplified">
            <summary>'using' statement can be simplified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.if_statement_can_be_simplified">
            <summary>'if' statement can be simplified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Simplify_default_expression">
            <summary>Simplify 'default' expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.default_expression_can_be_simplified">
            <summary>'default' expression can be simplified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Make_readonly_fields_writable">
            <summary>Make readonly fields writable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Struct_contains_assignment_to_this_outside_of_constructor_Make_readonly_fields_writable">
            <summary>Struct contains assignment to 'this' outside of constructor. Make readonly fields writable.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Deconstruct_variable_declaration">
            <summary>Deconstruct variable declaration</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Variable_declaration_can_be_deconstructed">
            <summary>Variable declaration can be deconstructed</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Local_function_can_be_made_static">
            <summary>Local function can be made static</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Make_local_function_static">
            <summary>Make local function 'static'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources._0_can_be_simplified">
            <summary>{0} can be simplified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Indexing_can_be_simplified">
            <summary>Indexing can be simplified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_local_function">
            <summary>Use local function</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_index_operator">
            <summary>Use index operator</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_range_operator">
            <summary>Use range operator</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Delegate_invocation_can_be_simplified">
            <summary>Delegate invocation can be simplified.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Inline_variable_declaration">
            <summary>Inline variable declaration</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Variable_declaration_can_be_inlined">
            <summary>Variable declaration can be inlined</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Negate_expression_changes_semantics">
            <summary>Negate expression (changes semantics)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Remove_operator_preserves_semantics">
            <summary>Remove operator (preserves semantics)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Remove_unnecessary_suppression_operator">
            <summary>Remove unnecessary suppression operator</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Suppression_operator_has_no_effect_and_can_be_misinterpreted">
            <summary>Suppression operator has no effect and can be misinterpreted</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.typeof_can_be_converted_to_nameof">
            <summary>'typeof' can be converted to 'nameof'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_new">
            <summary>Use 'new(...)'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.new_expression_can_be_simplified">
            <summary>'new' expression can be simplified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Lambda_expression_can_be_simplified">
            <summary>Lambda expression can be simplified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_implicitly_typed_lambda">
            <summary>Use implicitly typed lambda</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Discard_can_be_removed">
            <summary>Discard can be removed</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Remove_unnessary_discard">
            <summary>Remove unnecessary discard</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Embedded_statements_must_be_on_their_own_line">
            <summary>Embedded statements must be on their own line</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Consecutive_braces_must_not_have_a_blank_between_them">
            <summary>Consecutive braces must not have blank line between them</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Blank_line_not_allowed_after_constructor_initializer_colon">
            <summary>Blank line not allowed after constructor initializer colon</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Null_check_can_be_clarified">
            <summary>Null check can be clarified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Convert_to_file_scoped_namespace">
            <summary>Convert to file-scoped namespace</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Convert_to_block_scoped_namespace">
            <summary>Convert to block scoped namespace</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_pattern_matching_may_change_code_meaning">
            <summary>Use pattern matching (may change code meaning)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Property_pattern_can_be_simplified">
            <summary>Property pattern can be simplified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Simplify_property_pattern">
            <summary>Simplify property pattern</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_tuple_to_swap_values">
            <summary>Use tuple to swap values</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Lambda_expression_can_be_removed">
            <summary>Lambda expression can be removed</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Remove_unnecessary_lambda_expression">
            <summary>Remove unnecessary lambda expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Simplify_delegate_invocation">
            <summary>Simplify delegate invocation</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_is_not_null_check">
            <summary>Use 'is not null' check</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_is_object_check">
            <summary>Use 'is object' check</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Convert_to_Program_Main_style_program">
            <summary>Convert to 'Program.Main' style program</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Convert_to_top_level_statements">
            <summary>Convert to top-level statements</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_Utf8_string_literal">
            <summary>Use UTF-8 string literal</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Nullable_directive_is_unnecessary">
            <summary>Nullable directive is unnecessary</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Remove_unnecessary_nullable_directive">
            <summary>Remove unnecessary nullable directive</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Nullable_directive_is_redundant">
            <summary>Nullable directive is redundant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Remove_redundant_nullable_directive">
            <summary>Remove redundant nullable directive</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_expression_body_for_lambda_expression">
            <summary>Use expression body for lambda expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_block_body_for_lambda_expression">
            <summary>Use block body for lambda expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Make_struct_readonly">
            <summary>Make struct 'readonly'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Struct_can_be_made_readonly">
            <summary>Struct can be made 'readonly'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Blank_line_not_allowed_after_conditional_expression_token">
            <summary>Blank line not allowed after conditional expression token</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Blank_line_not_allowed_after_arrow_expression_clause_token">
            <summary>Blank line not allowed after arrow expression clause token</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_nameof">
            <summary>Use 'nameof'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Make_member_readonly">
            <summary>Make member 'readonly'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Member_can_be_made_readonly">
            <summary>Member can be made 'readonly'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_primary_constructor">
            <summary>Use primary constructor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Anonymous_function_can_be_made_static">
            <summary>Anonymous function can be made static</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Make_anonymous_function_static">
            <summary>Make anonymous function static</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_System_Threading_Lock">
            <summary>Use 'System.Threading.Lock'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Use_unbound_generic_type">
            <summary>Use unbound generic type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources.Implement_with_Copilot">
            <summary>Implement with Copilot</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Remove_unnecessary_usings">
            <summary>Remove unnecessary usings</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Add_this">
            <summary>Add 'this.'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Remove_unreachable_code">
            <summary>Remove unreachable code</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Pass_in_captured_variables_as_arguments">
            <summary>Pass in captured variables as arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Warning_colon_Adding_parameters_to_local_function_declaration_may_produce_invalid_code">
            <summary>Warning: Adding parameters to local function declaration may produce invalid code.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Convert_typeof_to_nameof">
            <summary>Convert 'typeof' to 'nameof'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Place_statement_on_following_line">
            <summary>Place statement on following line</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Remove_blank_lines_between_braces">
            <summary>Remove blank line between braces</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Fix_record_declaration">
            <summary>Fix record declaration</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Fix_constraint">
            <summary>Fix constraint</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Change_return_type_from_0_to_1">
            <summary>Change return type from {0} to {1}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Hide_base_member">
            <summary>Hide base member</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Add_Obsolete">
            <summary>Add [Obsolete]</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Explicitly_inherit_documentation">
            <summary>Explicitly inherit documentation</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Unseal_class_0">
            <summary>Unseal class '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Use_interpolated_verbatim_string">
            <summary>Use interpolated verbatim string</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Add_await">
            <summary>Add 'await'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Assign_to_0">
            <summary>Assign to '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Compare_to_0">
            <summary>Compare to '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Fix_return_type">
            <summary>Fix return type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Replace_return_with_yield_return">
            <summary>Replace return with yield return</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Declare_as_nullable">
            <summary>Declare as nullable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Place_token_on_following_line">
            <summary>Place token on following line</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Assign_out_parameters">
            <summary>Assign 'out' parameters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Assign_out_parameters_at_start">
            <summary>Assign 'out' parameters (at start)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Add_parentheses_around_conditional_expression_in_interpolated_string">
            <summary>Add parentheses</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Make_0_return_Task_instead_of_void">
            <summary>Make {0} return Task instead of void.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Allow_unsafe_code_in_this_project">
            <summary>Allow unsafe code in this project</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Make_ref_struct">
            <summary>Make 'ref struct'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Remove_unused_function">
            <summary>Remove unused function</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Upgrade_all_csharp_projects_to_language_version_0">
            <summary>Upgrade all C# projects to language version '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Upgrade_this_project_to_csharp_language_version_0">
            <summary>Upgrade this project to C# language version '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Use_0">
            <summary>Use '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Remove_in_keyword">
            <summary>Remove 'in' keyword</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Remove_new_modifier">
            <summary>Remove 'new' modifier</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Convert_to_positional_record">
            <summary>Convert to positional record</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Make_method_async">
            <summary>Make method async</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Make_method_async_remain_void">
            <summary>Make method async (stay void)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Make_field_required">
            <summary>Make field 'required'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Make_property_required">
            <summary>Make property 'required'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Use_primary_constructor_and_remove_members">
            <summary>Use primary constructor (and remove members)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Use_primary_constructor_and_remove_fields">
            <summary>Use primary constructor (and remove fields)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Use_primary_constructor_and_remove_properties">
            <summary>Use primary constructor (and remove properties)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Use_collection_expression">
            <summary>Use collection expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources.Use_explicit_array">
            <summary>Use explicit array</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ExternalAccess.Pythia.PythiaSignatureHelpProvider">
            <summary>
            Ensure this is ordered before the regular invocation signature help provider.
            We must replace the entire list of results, including both Pythia and non-Pythia recommendations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExternalAccess.Pythia.PythiaSignatureHelpProvider.#ctor(System.Lazy{Microsoft.CodeAnalysis.ExternalAccess.Pythia.Api.IPythiaSignatureHelpProviderImplementation})">
            <summary>
            Ensure this is ordered before the regular invocation signature help provider.
            We must replace the entire list of results, including both Pythia and non-Pythia recommendations.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.CSharpAnalyzerOptionsProvider">
            <summary>
            Provides C# analyzers a convenient access to editorconfig options with fallback to IDE default values.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CSharpAnalyzerOptionsProvider.#ctor(Microsoft.CodeAnalysis.Options.IOptionsReader)">
            <summary>
            Provides C# analyzers a convenient access to editorconfig options with fallback to IDE default values.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnnecessaryNullableDirective.CSharpRemoveUnnecessaryNullableDirectiveDiagnosticAnalyzer.IsIgnoredCodeBlock(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Determine if a code block is eligible for analysis by <see cref="M:Microsoft.CodeAnalysis.RemoveUnnecessaryNullableDirective.CSharpRemoveUnnecessaryNullableDirectiveDiagnosticAnalyzer.AnalyzeCodeBlock(Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext,System.Int32)"/>.
            </summary>
            <param name="codeBlock">The syntax node provided via <see cref="P:Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext.CodeBlock"/>.</param>
            <returns><see langword="true"/> if the code block should be analyzed by <see cref="M:Microsoft.CodeAnalysis.RemoveUnnecessaryNullableDirective.CSharpRemoveUnnecessaryNullableDirectiveDiagnosticAnalyzer.AnalyzeCodeBlock(Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext,System.Int32)"/>;
            otherwise, <see langword="false"/> to skip analysis of the block. If a block is skipped, one or more child
            blocks may be analyzed by <see cref="M:Microsoft.CodeAnalysis.RemoveUnnecessaryNullableDirective.CSharpRemoveUnnecessaryNullableDirectiveDiagnosticAnalyzer.AnalyzeCodeBlock(Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext,System.Int32)"/>, and any remaining spans can be analyzed by
            <see cref="M:Microsoft.CodeAnalysis.RemoveUnnecessaryNullableDirective.CSharpRemoveUnnecessaryNullableDirectiveDiagnosticAnalyzer.AnalyzeSemanticModel(Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext,System.Int32,Microsoft.CodeAnalysis.Shared.Collections.TextSpanMutableIntervalTree,Microsoft.CodeAnalysis.Shared.Collections.TextSpanMutableIntervalTree)"/>.</returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RemoveUnnecessaryNullableDirective.CSharpRemoveUnnecessaryNullableDirectiveDiagnosticAnalyzer.AnalyzerImpl._codeBlockIntervals">
            <summary>
            Tracks the analysis state of syntax trees in a compilation.
            </summary>
        </member>
    </members>
</doc>
