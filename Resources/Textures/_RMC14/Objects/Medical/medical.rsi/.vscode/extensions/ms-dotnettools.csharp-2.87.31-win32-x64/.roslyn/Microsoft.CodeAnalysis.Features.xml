<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.CodeAnalysis.Features</name>
    </assembly>
    <members>
        <member name="F:Microsoft.CodeAnalysis.AddConstructorParametersFromMembers.AddConstructorParametersFromMembersCodeRefactoringProvider.AddConstructorParametersCodeAction._useSubMenuName">
            <summary>
            If there is more than one constructor, the suggested actions will be split into two sub menus,
            one for regular parameters and one for optional. This boolean is used by the Title property
            to determine if the code action should be given the complete title or the sub menu title
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AddConstructorParametersFromMembers.AddConstructorParametersFromMembersCodeRefactoringProvider.AddConstructorParametersCodeAction.ActionName">
            <summary>
            A metadata name used by telemetry to distinguish between the different kinds of this code action.
            This code action will perform 2 different actions depending on if missing parameters can be optional.
            
            In this case we don't want to use the title as it depends on the class name for the ctor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddConstructorParametersFromMembers.AddConstructorParametersFromMembersCodeRefactoringProvider.State.GetConstructorCandidatesInfoAsync(Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISymbol},Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IParameterSymbol},System.Threading.CancellationToken)">
            <summary>
            Try to find all constructors in <paramref name="containingType"/> whose parameters
            are a subset of the selected members by comparing name.
            These constructors will not be considered as potential candidates:
             - if the constructor's parameter list contains 'ref' or 'params'
             - any constructor that has a params[] parameter
             - deserialization constructor
             - implicit default constructor
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddFileBanner.AddFileBannerHelpers.UpdateEmbeddedFileNames(Microsoft.CodeAnalysis.Document,System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxTrivia},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,System.String,Microsoft.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Looks at <paramref name="banner"/> to see if it contains the name of <paramref name="sourceDocument"/>
            in it.  If so, those names will be replaced with <paramref name="destinationFilePath"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportCodeFixProvider.#ctor(Microsoft.CodeAnalysis.Packaging.IPackageInstallerService,Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchService)">
            <summary>
            Values for these parameters can be provided (during testing) for mocking purposes.
            </summary> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportCodeFixProvider.ComputeRequestPriority">
            <summary>
            Add-using gets special privileges as being the most used code-action, along with being a core
            'smart tag' feature in VS prior to us even having 'light bulbs'.  We want them to be computed
            first, ahead of everything else, and the main results should show up at the top of the list.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.s_isInPackagesDirectory">
            <summary>
            Cache of information about whether a <see cref="T:Microsoft.CodeAnalysis.PortableExecutableReference"/> is likely contained within a
            NuGet packages directory.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.GetUnreferencedMetadataReferences(Microsoft.CodeAnalysis.Project,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.PortableExecutableReference})">
            <summary>
            Returns the set of PEReferences in the solution that are not currently being referenced
            by this project.  The set returned will be tuples containing the PEReference, and the project-id
            for the project we found the pe-reference in.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.IsInPackagesDirectory(Microsoft.CodeAnalysis.PortableExecutableReference)">
             <summary>
             We ignore references that are in a directory that contains the names
             "Packages", "packs", "NuGetFallbackFolder", or "NuGetPackages"
             These directories are most likely the ones produced by NuGet, and we don't want
             to offer to add .dll reference manually for dlls that are part of NuGet packages.
             
             Note that this is only a heuristic (though a good one), and we should remove this
             when we can get an API from NuGet that tells us if a reference is actually provided
             by a nuget packages.
             Tracking issue: https://github.com/dotnet/project-system/issues/5275
             
             This heuristic will do the right thing in practically all cases for all. It 
             prevents the very unpleasant experience of us offering to add a direct metadata 
             reference to something that should only be referenced as a nuget package.
            
             It does mean that if the following is true:
             You have a project that has a non-nuget metadata reference to something in a "packages"
             directory, and you are in another project that uses a type name that would have matched
             an accessible type from that dll. then we will not offer to add that .dll reference to
             that other project.
             
             However, that would be an exceedingly uncommon case that is degraded.  Whereas we're 
             vastly improved in the common case. This is a totally acceptable and desirable outcome
             for such a heuristic.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.CreateCompilation(Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.PortableExecutableReference)">
            <summary>
            Called when we want to search a metadata reference.  We create a dummy compilation
            containing just that reference and we search that.  That way we can get actual symbols
            returned.
            
            We don't want to use the project that the reference is actually associated with as 
            getting the compilation for that project may be extremely expensive.  For example,
            in a large solution it may cause us to build an enormous amount of skeleton assemblies.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.AssemblyReferenceCodeAction.#ctor(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.AddImport.AddImportFixData)">
            <summary>
            This code action only works by adding a reference.  As such, it requires a non document change (and is
            thus restricted in which hosts it can run).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.MetadataSymbolReferenceCodeAction.#ctor(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.AddImport.AddImportFixData)">
            <summary>
            This code action only works by adding a reference to a metadata dll.  As such, it requires a non
            document change (and is thus restricted in which hosts it can run).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.ProjectSymbolReferenceCodeAction">
            <summary>
            Code action for adding an import when we find a symbol in source in either our
            starting project, or some other unreferenced project in the solution.  If we 
            find a source symbol in a different project, we'll also add a p2p reference when
            we apply the code action.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.ProjectSymbolReferenceCodeAction.#ctor(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.AddImport.AddImportFixData)">
            <summary>
            This code action may or may not add a project reference.  If it does, it requires a non document change
            (and is thus restricted in which hosts it can run).  If it doesn't, it can run anywhere.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReferenceCodeAction">
            <summary>
            Code action we use when just adding a using, possibly with a project or
            metadata reference.  We don't use the standard code action types because
            we want to do things like show a glyph if this will do more than just add
            an import.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.MetadataSymbolReference.ShouldAddWithExistingImport(Microsoft.CodeAnalysis.Document)">
            <summary>
            If we're adding a metadata-reference, then we always offer to do the add,
            even if there's an existing source-import in the file.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.ProjectSymbolReference">
            <summary>
            Handles references to source symbols both from the current project the user is invoking
            'add-import' from, as well as symbols from other viable projects.
            
            In the case where the reference is from another project we put a glyph in the add using
            light bulb and we say "(from ProjectXXX)" to make it clear that this will do more than
            just add a using/import.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.ProjectSymbolReference.#ctor(Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService{`0},Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService{`0}.SymbolResult{Microsoft.CodeAnalysis.INamespaceOrTypeSymbol},Microsoft.CodeAnalysis.Project)">
            <summary>
            Handles references to source symbols both from the current project the user is invoking
            'add-import' from, as well as symbols from other viable projects.
            
            In the case where the reference is from another project we put a glyph in the add using
            light bulb and we say "(from ProjectXXX)" to make it clear that this will do more than
            just add a using/import.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.ProjectSymbolReference.ShouldAddWithExistingImport(Microsoft.CodeAnalysis.Document)">
            <summary>
            If we're adding a reference to another project, it's ok to still add, even if there
            is an existing source-import in the file.  We won't add the import, but we'll still
            add the project-reference.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.AllSymbolsProjectSearchScope">
            <summary>
            SearchScope used for searching *all* the symbols contained within a project/compilation.
            i.e. the symbols created from source *and* symbols from references (both project and
            metadata).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.AllSymbolsProjectSearchScope.#ctor(Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService{`0},Microsoft.CodeAnalysis.Project,System.Boolean)">
            <summary>
            SearchScope used for searching *all* the symbols contained within a project/compilation.
            i.e. the symbols created from source *and* symbols from references (both project and
            metadata).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SearchScope">
            <summary>
            SearchScope is used to control where the <see cref="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1"/>
            searches.  We search different scopes in different ways.  For example we use 
            SymbolTreeInfos to search unreferenced projects and metadata dlls.  However,
            for the current project we're editing we defer to the compiler to do the 
            search.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SearchScope.#ctor(Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService{`0},System.Boolean)">
            <summary>
            SearchScope is used to control where the <see cref="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1"/>
            searches.  We search different scopes in different ways.  For example we use 
            SymbolTreeInfos to search unreferenced projects and metadata dlls.  However,
            for the current project we're editing we defer to the compiler to do the 
            search.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SourceSymbolsProjectSearchScope">
            <summary>
            SearchScope used for searching *only* the source symbols contained within a project/compilation.
            i.e. symbols from metadata will not be searched.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SourceSymbolsProjectSearchScope.#ctor(Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService{`0},System.Collections.Concurrent.ConcurrentDictionary{Microsoft.CodeAnalysis.Project,Roslyn.Utilities.AsyncLazy{Microsoft.CodeAnalysis.IAssemblySymbol}},Microsoft.CodeAnalysis.Project,System.Boolean)">
            <summary>
            SearchScope used for searching *only* the source symbols contained within a project/compilation.
            i.e. symbols from metadata will not be searched.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReferenceFinder._isWithinImport">
            <summary>
            If the search is being conducted inside of a `using/import` directive.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReferenceFinder.GetReferencesForMatchingTypesAsync(Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService{`0}.SearchScope,System.Threading.CancellationToken)">
            <summary>
            Searches for types that match the name the user has written.  Returns <see cref="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReference"/>s
            to the <see cref="T:Microsoft.CodeAnalysis.INamespaceSymbol"/>s or <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/>s those types are
            contained in.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReferenceFinder.GetReferencesForMatchingNamespacesAsync(Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService{`0}.SearchScope,System.Threading.CancellationToken)">
            <summary>
            Searches for namespaces that match the name the user has written.  Returns <see cref="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReference"/>s
            to the <see cref="T:Microsoft.CodeAnalysis.INamespaceSymbol"/>s those namespaces are contained in.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReferenceFinder.GetReferencesForMatchingFieldsAndPropertiesAsync(Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService{`0}.SearchScope,System.Threading.CancellationToken)">
            <summary>
            Specialized finder for the "Color Color" case.  Used when we have "Color.Black" and "Color"
            bound to a Field/Property, but not a type.  In this case, we want to look for namespaces
            containing 'Color' as if we import them it can resolve this issue.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReferenceFinder.GetReferencesForMatchingExtensionMethodsAsync(Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService{`0}.SearchScope,System.Threading.CancellationToken)">
            <summary>
            Searches for extension methods that match the name the user has written.  Returns
            <see cref="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReference"/>s to the <see cref="T:Microsoft.CodeAnalysis.INamespaceSymbol"/>s that contain
            the static classes that those extension methods are contained in.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReferenceFinder.GetReferencesForCollectionInitializerMethodsAsync(Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService{`0}.SearchScope,System.Threading.CancellationToken)">
            <summary>
            Searches for extension methods exactly called 'Add'.  Returns
            <see cref="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReference"/>s to the <see cref="T:Microsoft.CodeAnalysis.INamespaceSymbol"/>s that contain
            the static classes that those extension methods are contained in.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReferenceFinder.GetReferencesForQueryPatternsAsync(Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService{`0}.SearchScope,System.Threading.CancellationToken)">
            <summary>
            Searches for extension methods exactly called 'Select'.  Returns
            <see cref="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReference"/>s to the <see cref="T:Microsoft.CodeAnalysis.INamespaceSymbol"/>s that contain
            the static classes that those extension methods are contained in.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReferenceFinder.GetReferencesForGetAwaiterAsync(Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService{`0}.SearchScope,System.Threading.CancellationToken)">
            <summary>
            Searches for extension methods exactly called 'GetAwaiter'.  Returns
            <see cref="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReference"/>s to the <see cref="T:Microsoft.CodeAnalysis.INamespaceSymbol"/>s that contain
            the static classes that those extension methods are contained in.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReferenceFinder.GetReferencesForGetEnumeratorAsync(Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService{`0}.SearchScope,System.Threading.CancellationToken)">
            <summary>
            Searches for extension methods exactly called 'GetEnumerator'.  Returns
            <see cref="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReference"/>s to the <see cref="T:Microsoft.CodeAnalysis.INamespaceSymbol"/>s that contain
            the static classes that those extension methods are contained in.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReferenceFinder.GetReferencesForGetAsyncEnumeratorAsync(Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService{`0}.SearchScope,System.Threading.CancellationToken)">
            <summary>
            Searches for extension methods exactly called 'GetAsyncEnumerator'.  Returns
            <see cref="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReference"/>s to the <see cref="T:Microsoft.CodeAnalysis.INamespaceSymbol"/>s that contain
            the static classes that those extension methods are contained in.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReferenceFinder.GetReferencesForDeconstructAsync(Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService{`0}.SearchScope,System.Threading.CancellationToken)">
            <summary>
            Searches for extension methods exactly called 'Deconstruct'.  Returns
            <see cref="T:Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1.SymbolReference"/>s to the <see cref="T:Microsoft.CodeAnalysis.INamespaceSymbol"/>s that contain
            the static classes that those extension methods are contained in.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AddImport.AddImportFixData.TextChanges">
            <summary>
            Text changes to make to the document.  Usually just the import to add.  May also
            include a change to the name node the feature was invoked on to fix the casing of it.
            May be empty for fixes that don't need to add an import and only do something like
            add a project/metadata reference.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AddImport.AddImportFixData.Title">
            <summary>
            String to display in the lightbulb menu.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AddImport.AddImportFixData.Tags">
            <summary>
            Tags that control what glyph is displayed in the lightbulb menu.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AddImport.AddImportFixData.Priority">
            <summary>
            The priority this item should have in the lightbulb list.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AddImport.AddImportFixData.ProjectReferenceToAdd">
            <summary>
            The optional id for a <see cref="T:Microsoft.CodeAnalysis.Project"/> we'd like to add a reference to.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AddImport.AddImportFixData.PortableExecutableReferenceProjectId">
            <summary>
            If we're adding <see cref="F:Microsoft.CodeAnalysis.AddImport.AddImportFixData.PortableExecutableReferenceFilePathToAdd"/> then this
            is the id for the <see cref="T:Microsoft.CodeAnalysis.Project"/> we can find that <see cref="T:Microsoft.CodeAnalysis.PortableExecutableReference"/>
            referenced from.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AddImport.AddImportFixData.PortableExecutableReferenceFilePathToAdd">
            <summary>
            If we want to add a <see cref="T:Microsoft.CodeAnalysis.PortableExecutableReference"/> metadata reference, this 
            is the <see cref="P:Microsoft.CodeAnalysis.PortableExecutableReference.FilePath"/> for it.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AddImport.AddImportFixKind.ProjectSymbol">
            <summary>
            Adding a project reference.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AddImport.AddImportFixKind.MetadataSymbol">
            <summary>
            Adding an assembly reference.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AddImport.AddImportFixKind.PackageSymbol">
            <summary>
            Adding a package reference.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AddImport.AddImportFixKind.ReferenceAssemblySymbol">
            <summary>
            Adding a framework reference assembly reference.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AddImport.AddImportCodeAction">
            <summary>
            Code action we use when just adding a using, possibly with a project or metadata reference.  We don't use the
            standard code action types because we want to do things like show a glyph if this will do more than just add an
            import.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AddImport.AddImportCodeAction.OriginalDocument">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.Document"/> we started the add-import analysis in.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AddImport.AddImportCodeAction._textChanges">
            <summary>
            The changes to make to <see cref="F:Microsoft.CodeAnalysis.AddImport.AddImportCodeAction.OriginalDocument"/> to add the import.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AddImport.InstallPackageAndAddImportCodeAction._installOperation">
            <summary>
            The operation that will actually install the nuget package.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.InstallPackageAndAddImportCodeAction.#ctor(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.AddImport.AddImportFixData,System.String,Microsoft.CodeAnalysis.AddPackage.InstallPackageDirectlyCodeActionOperation)">
            <summary>
            This code action only works by installing a package.  As such, it requires a non document change (and is
            thus restricted in which hosts it can run).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.InstallPackageAndAddImportCodeAction.ComputePreviewOperationsAsync(System.Threading.CancellationToken)">
            <summary>
            For preview purposes we return all the operations in a list.  This way the 
            preview system stiches things together in the UI to make a suitable display.
            i.e. if we have a SolutionChangedOperation and some other operation with a 
            Title, then the UI will show that nicely to the user.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.InstallPackageAndAddImportCodeAction.ComputeOperationsAsync(System.Threading.CancellationToken)">
            <summary>
            However, for application purposes, we end up returning a single operation
            that will then apply all our sub actions in order, stopping the moment
            one of them fails.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.IAddImportFeatureService.GetFixesAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.String,System.Int32,Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchService,Microsoft.CodeAnalysis.AddImport.AddImportOptions,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Packaging.PackageSource},System.Threading.CancellationToken)">
            <summary>
            Gets data for how to fix a particular <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> id within the specified Document. Useful when
            you do not have an instance of the diagnostic, such as when invoked as a remote service.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.IAddImportFeatureService.GetFixesForDiagnosticsAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic},System.Int32,Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchService,Microsoft.CodeAnalysis.AddImport.AddImportOptions,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Packaging.PackageSource},System.Threading.CancellationToken)">
            <summary>
            Gets data for how to fix a set of <see cref="T:Microsoft.CodeAnalysis.Diagnostic" />s within the specified Document. The fix data can be
            used to create code actions that apply the fixes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.IAddImportFeatureService.GetCodeActionsForFixes(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AddImport.AddImportFixData},Microsoft.CodeAnalysis.Packaging.IPackageInstallerService,System.Int32)">
            <summary>
            Gets code actions that, when applied, will fix the missing imports for the document using the information from
            the provided fixes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.IAddImportFeatureService.GetUniqueFixesAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Collections.Immutable.ImmutableArray{System.String},Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchService,Microsoft.CodeAnalysis.AddImport.AddImportOptions,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Packaging.PackageSource},System.Threading.CancellationToken)">
            <summary>
            Gets data for how to fix a particular <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> id within the specified Document. Similar to
            <see cref="M:Microsoft.CodeAnalysis.AddImport.IAddImportFeatureService.GetFixesAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.String,System.Int32,Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchService,Microsoft.CodeAnalysis.AddImport.AddImportOptions,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Packaging.PackageSource},System.Threading.CancellationToken)"/> except it only returns fix data when there is a single
            using fix for a given span
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AddImport.RemoteMissingImportDiscoveryServiceCallbackDispatcher">
            <summary>
            Used to supply the OOP server a callback that it can use to search for ReferenceAssemblies or nuget packages.  We
            can't necessarily do that search directly in the OOP server as our 'SymbolSearchEngine' may actually be running in a
            *different* process (there is no guarantee that all remote work happens in the same process).  
            
            This does mean, currently, that when we call over to OOP to do a search, it will bounce back to VS, which will then
            bounce back out to OOP to perform the Nuget/ReferenceAssembly portion of the search.  Ideally we could keep this all
            OOP.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.RemoteMissingImportDiscoveryServiceCallbackDispatcher.#ctor">
            <summary>
            Used to supply the OOP server a callback that it can use to search for ReferenceAssemblies or nuget packages.  We
            can't necessarily do that search directly in the OOP server as our 'SymbolSearchEngine' may actually be running in a
            *different* process (there is no guarantee that all remote work happens in the same process).  
            
            This does mean, currently, that when we call over to OOP to do a search, it will bounce back to VS, which will then
            bounce back out to OOP to perform the Nuget/ReferenceAssembly portion of the search.  Ideally we could keep this all
            OOP.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AddMissingReference.AddMissingReferenceCodeAction.Tags">
            <summary>
            This code action only works by adding references.  As such, it requires a non document change (and is
            thus restricted in which hosts it can run).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AddPackage.AbstractAddPackageCodeFixProvider">
            <summary>
            Values for parameters can be provided (during testing) for mocking purposes.
            </summary> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddPackage.AbstractAddSpecificPackageCodeFixProvider.#ctor">
            <summary>
            Values for these parameters can be provided (during testing) for mocking purposes.
            </summary> 
        </member>
        <member name="T:Microsoft.CodeAnalysis.AddPackage.InstallPackageDirectlyCodeActionOperation">
            <summary>
            Operation responsible purely for installing a nuget package with a specific 
            version, or a the latest version of a nuget package.  Is not responsible
            for adding an import to user code.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AddPackage.InstallPackageParentCodeAction">
            <summary>
            This is the top level 'Install Nuget Package' code action we show in 
            the lightbulb.  It will have children to 'Install Latest', 
            'Install Version 'X' ..., and 'Install with package manager'.
            </summary>
            <remarks>
            Even though we have child actions, we mark ourselves as explicitly non-inlinable.
            We want to the experience of having the top level item the user has to see and
            navigate through, and we don't want our child items confusingly being added to the
            top level light-bulb where it's not clear what effect they would have if invoked.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddPackage.InstallPackageParentCodeAction.#ctor(Microsoft.CodeAnalysis.Packaging.IPackageInstallerService,System.String,System.String,System.Boolean,Microsoft.CodeAnalysis.Document)">
            <summary>
            This is the top level 'Install Nuget Package' code action we show in 
            the lightbulb.  It will have children to 'Install Latest', 
            'Install Version 'X' ..., and 'Install with package manager'.
            </summary>
            <remarks>
            Even though we have child actions, we mark ourselves as explicitly non-inlinable.
            We want to the experience of having the top level item the user has to see and
            navigate through, and we don't want our child items confusingly being added to the
            top level light-bulb where it's not clear what effect they would have if invoked.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AddPackage.InstallPackageParentCodeAction.Tags">
            <summary>
            This code action only works by installing a package.  As such, it requires a non document change (and is
            thus restricted in which hosts it can run).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AddPackage.InstallPackageData">
            <summary>
            Data used to create the 'Install Nuget Package' top level code-action. It will have children to 'Install Latest',
            'Install Version 'X' ..., and 'Install with package manager'.
            </summary>
            <param name="packageSource">The nuget source to use.  Currently this is only <see
            cref="F:Microsoft.CodeAnalysis.AddImport.PackageSourceHelper.NugetOrg"/> ("nuget.org").  Can be <see langword="null"/> to use the users configured
            sources.</param>
            <param name="packageName">The name of the package to install.</param>
            <param name="packageVersionOpt">A optional preferred version if known. If not present, the user will be given the
            option to either install the latest version, or install any version installed locally in another project.</param>
            <param name="textChanges">Additional text changes to make to the <see cref="T:Microsoft.CodeAnalysis.Document"/>.  Generally, this would be
            the import to add if not present.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddPackage.InstallPackageData.#ctor(System.String,System.String,System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextChange})">
            <summary>
            Data used to create the 'Install Nuget Package' top level code-action. It will have children to 'Install Latest',
            'Install Version 'X' ..., and 'Install with package manager'.
            </summary>
            <param name="packageSource">The nuget source to use.  Currently this is only <see
            cref="F:Microsoft.CodeAnalysis.AddImport.PackageSourceHelper.NugetOrg"/> ("nuget.org").  Can be <see langword="null"/> to use the users configured
            sources.</param>
            <param name="packageName">The name of the package to install.</param>
            <param name="packageVersionOpt">A optional preferred version if known. If not present, the user will be given the
            option to either install the latest version, or install any version installed locally in another project.</param>
            <param name="textChanges">Additional text changes to make to the <see cref="T:Microsoft.CodeAnalysis.Document"/>.  Generally, this would be
            the import to add if not present.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AddPackage.ParentInstallPackageCodeAction">
            <summary>
            This is the top level 'Install Nuget Package' code action we show in 
            the lightbulb.  It will have children to 'Install Latest', 
            'Install Version 'X' ..., and 'Install with package manager'.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AddPackage.ParentInstallPackageCodeAction.Tags">
            <summary>
            This code action only works by installing a package.  As such, it requires a non document change (and is
            thus restricted in which hosts it can run).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddPackage.ParentInstallPackageCodeAction.#ctor(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.AddPackage.InstallPackageData,Microsoft.CodeAnalysis.Packaging.IPackageInstallerService)">
            <summary>
            Even though we have child actions, we mark ourselves as explicitly non-inlinable.
            We want to the experience of having the top level item the user has to see and
            navigate through, and we don't want our child items confusingly being added to the
            top level light-bulb where it's not clear what effect they would have if invoked.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.BraceCompletion.AbstractBraceCompletionService.NeedsSemantics">
            <summary>
            Whether or not this brace completion session actually needs semantics to work (and thus should get a semantic model).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BraceCompletion.AbstractBraceCompletionService.IsValidOpeningBraceToken(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Returns if the token is a valid opening token kind for this brace completion service.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BraceCompletion.AbstractBraceCompletionService.IsValidClosingBraceToken(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Returns if the token is a valid closing token kind for this brace completion service.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BraceCompletion.AbstractBraceCompletionService.IsValidOpenBraceTokenAtPositionAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxToken,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Only called if <see cref="P:Microsoft.CodeAnalysis.BraceCompletion.AbstractBraceCompletionService.NeedsSemantics"/> returns true;
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BraceCompletion.AbstractBraceCompletionService.IsValidOpenBraceTokenAtPosition(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.SyntaxToken,System.Int32)">
            <summary>
            Checks if the already inserted token is a valid opening token at the position in the document.
            By default checks that the opening token is a valid token at the position and not in skipped token trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BraceCompletion.AbstractBraceCompletionService.AllowOverTypeInUserCodeWithValidClosingToken(Microsoft.CodeAnalysis.BraceCompletion.BraceCompletionContext,System.Threading.CancellationToken)">
            <summary>
            Returns true when the current position is inside user code (e.g. not strings) and the closing token
            matches the expected closing token for this brace completion service.
            Helper method used by <see cref="M:Microsoft.CodeAnalysis.BraceCompletion.AbstractBraceCompletionService.AllowOverType(Microsoft.CodeAnalysis.BraceCompletion.BraceCompletionContext,System.Threading.CancellationToken)"/> implementations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BraceCompletion.AbstractBraceCompletionService.AllowOverTypeWithValidClosingToken(Microsoft.CodeAnalysis.BraceCompletion.BraceCompletionContext)">
            <summary>
            Returns true when the closing token matches the expected closing token for this brace completion service.
            Used by <see cref="M:Microsoft.CodeAnalysis.BraceCompletion.AbstractBraceCompletionService.AllowOverType(Microsoft.CodeAnalysis.BraceCompletion.BraceCompletionContext,System.Threading.CancellationToken)"/> implementations
            when the over type could be triggered from outside of user code (e.g. overtyping end quotes in a string).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BraceCompletion.AbstractBraceCompletionService.CheckClosingTokenKind(Microsoft.CodeAnalysis.ParsedDocument,System.Int32)">
            <summary>
            Checks that the token at the closing position is a valid closing token.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BraceCompletion.AbstractBraceCompletionService.CouldEscapePreviousOpenBrace(System.Char,System.Int32,Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Determines if inserting the opening brace at the location could be an attempt to
            escape a previously inserted opening brace.
            E.g. they are trying to type $"{{"
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BraceCompletion.IBraceCompletionService.CanProvideBraceCompletion(System.Char,System.Int32,Microsoft.CodeAnalysis.ParsedDocument,System.Threading.CancellationToken)">
            <summary>
            Checks if this brace completion service should be the service used to provide brace completions at
            the specified position with the specified opening brace.
            
            Only one implementation of <see cref="T:Microsoft.CodeAnalysis.BraceCompletion.IBraceCompletionService"/> should return true
            for a given brace, opening position, and document.  Only that service will be asked
            for brace completion results.
            </summary>
            <param name="brace">
            The opening brace character to be inserted at the opening position.</param>
            <param name="openingPosition">
            The opening position to insert the brace.
            Note that the brace is not yet inserted at this position in the document.
            </param>
            <param name="document">The document to insert the brace at the position.</param>
            <param name="cancellationToken">A cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BraceCompletion.IBraceCompletionService.HasBraceCompletionAsync(Microsoft.CodeAnalysis.BraceCompletion.BraceCompletionContext,Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            True if <see cref="T:Microsoft.CodeAnalysis.BraceCompletion.BraceCompletionResult"/> is available in the given <paramref name="context"/>.
            Completes synchronously unless the service needs Semantic Model to determine the brace completion result.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BraceCompletion.IBraceCompletionService.GetBraceCompletion(Microsoft.CodeAnalysis.BraceCompletion.BraceCompletionContext)">
            <summary>
            Returns the text change to add the closing brace given the context.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BraceCompletion.IBraceCompletionService.GetTextChangesAfterCompletion(Microsoft.CodeAnalysis.BraceCompletion.BraceCompletionContext,Microsoft.CodeAnalysis.Indentation.IndentationOptions,System.Threading.CancellationToken)">
            <summary>
            Returns any text changes that need to be made after adding the closing brace.
            </summary>
            <remarks>
            This cannot be merged with <see cref="M:Microsoft.CodeAnalysis.BraceCompletion.IBraceCompletionService.GetBraceCompletion(Microsoft.CodeAnalysis.BraceCompletion.BraceCompletionContext)"/>
            as we need to swap the editor tracking mode of the closing point from positive to negative
            in BraceCompletionSessionProvider.BraceCompletionSession.Start after completing the brace and before
            doing any kind of formatting on it.  So these must be two distinct steps until we fully move to LSP.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BraceCompletion.IBraceCompletionService.GetTextChangeAfterReturn(Microsoft.CodeAnalysis.BraceCompletion.BraceCompletionContext,Microsoft.CodeAnalysis.Indentation.IndentationOptions,System.Threading.CancellationToken)">
            <summary>
            Get any text changes that should be applied after the enter key is typed inside a brace completion context.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BraceCompletion.IBraceCompletionService.GetCompletedBraceContext(Microsoft.CodeAnalysis.ParsedDocument,Microsoft.CodeAnalysis.Diagnostics.StructuredAnalyzerConfigOptions,System.Int32)">
            <summary>
            Returns the brace completion context if the caret is located between an already completed
            set of braces with only whitespace in between.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BraceCompletion.IBraceCompletionService.AllowOverType(Microsoft.CodeAnalysis.BraceCompletion.BraceCompletionContext,System.Threading.CancellationToken)">
            <summary>
            Returns true if over typing should be allowed given the caret location and completed pair of braces.
            For example some providers allow over typing in non-user code and others do not.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.BraceCompletion.BraceCompletionResult.TextChanges">
            <summary>
            The set of text changes that should be applied to the input text to retrieve the
            brace completion result.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.BraceCompletion.BraceCompletionResult.CaretLocation">
            <summary>
            The caret location in the new text created by applying all <see cref="P:Microsoft.CodeAnalysis.BraceCompletion.BraceCompletionResult.TextChanges"/>
            to the input text.  Note the column in the line position can be virtual in that it points
            to a location in the line which does not actually contain whitespace.
            Hosts can determine how best to handle that virtual location.
            For example, placing the character in virtual space (when suppported)
            or inserting an appropriate number of spaces into the document".
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.BraceMatching.AbstractEmbeddedLanguageBraceMatcher">
            <summary>
            Brace matcher that analyzes string literals (for C#/VB) and then dispatches out to embedded brace matchers for
            particular embedded languages (like JSON/Regex).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.BraceMatching.ExportEmbeddedLanguageBraceMatcherAttribute">
            <summary>
            Use this attribute to export a <see cref="T:Microsoft.CodeAnalysis.BraceMatching.IEmbeddedLanguageBraceMatcher"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BraceMatching.ExportEmbeddedLanguageBraceMatcherAttribute.#ctor(System.String,System.String[],System.Boolean,System.String[])">
            <summary>
            Use this attribute to export a <see cref="T:Microsoft.CodeAnalysis.BraceMatching.IEmbeddedLanguageBraceMatcher"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BraceMatching.IBraceMatcher.FindBracesAsync(Microsoft.CodeAnalysis.Document,System.Int32,Microsoft.CodeAnalysis.BraceMatching.BraceMatchingOptions,System.Threading.CancellationToken)">
            <summary>
            Given a <paramref name="document"/> and a <paramref name="position"/> within that document, gets the <see
            cref="T:Microsoft.CodeAnalysis.BraceMatching.BraceMatchingResult"/> if the position is at the start or end character of a matching pair of braces.
            Importantly, the <paramref name="position"/> is the position of the actual character to examine.  For
            example, given: <c>Goo()$$[1, 2, 3]</c> (where <c>$$</c> is the position), this would only be considering
            the <c>[</c> brace, not the <c>)</c> brace that precedes it.  Similarly, for <c>Goo()[1, 2, 3$$]</c> this
            would be considering the <c>]</c> brace.  If <c>Goo()[1, 2, 3]$$</c> were passed, no braces should be
            reported, despite the position being at the end of a brace.
            <para>
            It is the job of the calling feature ("Brace Matching") to actually make multiple calls into these matchers
            to then determine what to do.  For example with <c>Goo(true)$$[1, 2, 3]</c> (where $$ is now the caret
            position of the user), the feature will make two calls in, one for <c>Goo(true$$)[1, 2, 3]</c> and one for
            <c>Goo(true)$$[1, 2, 3]</c>.  This will allow it to see that the caret is between two complete brace pairs,
            and it can highlight both.  The <see cref="T:Microsoft.CodeAnalysis.BraceMatching.IBraceMatcher"/> does not have to consider this, or try to pick
            which set of braces to return.
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService.GetInvocationSymbolAsync(Microsoft.CodeAnalysis.Document,System.Int32,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Determines the symbol on which we are invoking ReorderParameters
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService.FindNodeToUpdate(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Given a SyntaxNode for which we want to reorder parameters/arguments, find the 
            SyntaxNode of a kind where we know how to reorder parameters/arguments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService.CreateExplicitParamsArrayFromIndividualArguments``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},System.Int32,Microsoft.CodeAnalysis.IParameterSymbol)">
            <summary>
            For some Foo(int x, params int[] p), this helps convert the "1, 2, 3" in Foo(0, 1, 2, 3)
            to "new int[] { 1, 2, 3 }" in Foo(0, new int[] { 1, 2, 3 });
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService.SupportsOptionalAndParamsArrayParametersSimultaneously">
            <summary>
            Only some languages support:
              - Optional parameters and params arrays simultaneously in declarations
              - Passing the params array as a named argument
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService.GetParameters(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            A temporarily hack that should be removed once/if https://github.com/dotnet/roslyn/issues/53092 is fixed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService.GetChangeSignatureOptions(Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureAnalyzedContext)">
            <returns>Returns <c>null</c> if the operation is cancelled.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService.UpdateSignatureChangeToIncludeExtraParametersFromTheDeclarationSymbol(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ChangeSignature.SignatureChange)">
            <summary>
            Sometimes signature changes can cascade from a declaration with m parameters to one with n > m parameters, such as
            delegate Invoke methods (m) and delegate BeginInvoke methods (n = m + 2). This method adds on those extra parameters
            to the base <see cref="T:Microsoft.CodeAnalysis.ChangeSignature.SignatureChange"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService.GetParameterIndex``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},System.Int32)">
            <summary>
            Given the cursor position, find which parameter is selected.
            Returns 0 as the default value. Note that the ChangeSignature dialog adjusts the selection for
            the `this` parameter in extension methods (the selected index won't remain 0).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ChangeSignature.CallSiteKind.Value">
            <summary>
            Use an explicit value to populate call sites, without forcing
            the addition of a named argument.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ChangeSignature.CallSiteKind.ValueWithName">
            <summary>
            Use an explicit value to populate call sites, and convert 
            arguments to named arguments even if not required. Often
            useful for literal callsite values like "true" or "null".
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ChangeSignature.CallSiteKind.Todo">
            <summary>
            Indicates whether a "TODO" should be introduced at callsites
            to cause errors that the user can then go visit and fix up.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ChangeSignature.CallSiteKind.Omitted">
            <summary>
            When an optional parameter is added, passing an argument for
            it is not required. This indicates that the corresponding argument 
            should be omitted. This often results in subsequent arguments needing
            to become named arguments
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ChangeSignature.CallSiteKind.Inferred">
            <summary>
            Populate each call site with an available variable of a matching types.
            If no matching variable is found, this falls back to the 
            <see cref="F:Microsoft.CodeAnalysis.ChangeSignature.CallSiteKind.Todo"/> behavior.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureCodeAction.Tags">
            <summary>
            This code action currently pops up a confirmation dialog to the user.  As such, it does more than make
            document changes (and is thus restricted in which hosts it can run).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureCodeActionOperation">
            <summary>
            Defines the <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation"/> for the <see cref="T:Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureCodeAction"/>
            This is used instead of <see cref="T:Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation"/> as we need to show a confirmation
            dialog to the user before applying the change.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureCodeActionOperation.#ctor(Microsoft.CodeAnalysis.Solution,System.String)">
            <summary>
            Defines the <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation"/> for the <see cref="T:Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureCodeAction"/>
            This is used instead of <see cref="T:Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation"/> as we need to show a confirmation
            dialog to the user before applying the change.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureCodeActionOperation.TryApplyAsync(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Solution,System.IProgress{Microsoft.CodeAnalysis.CodeAnalysisProgress},System.Threading.CancellationToken)">
            <summary>
            Show the confirmation message, if available, before attempting to apply the changes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureOptionsResult">
            <summary>
            A value of null indicates that the operation has been cancelled.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureOptionsResult.#ctor(Microsoft.CodeAnalysis.ChangeSignature.SignatureChange,System.Boolean)">
            <summary>
            A value of null indicates that the operation has been cancelled.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureResult.Name">
            <summary>
            Name of the symbol. Needed here for the Preview Changes dialog.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ChangeSignature.DelegateInvokeMethodReferenceFinder">
            <summary>
            For ChangeSignature, FAR on a delegate invoke method must cascade to BeginInvoke, 
            cascade through method group conversions, and discover implicit invocations that do not
            mention the string "Invoke" or the delegate type itself. This implementation finds these
            symbols by binding most identifiers and invocation expressions in the solution. 
            </summary>
            <remarks>
            TODO: Rewrite this to track backward through references instead of binding everything
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeSignature.IChangeSignatureOptionsService.GetChangeSignatureOptions(Microsoft.CodeAnalysis.SemanticDocument,System.Int32,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ChangeSignature.ParameterConfiguration)">
            <summary>
            Gets options and produces a <see cref="T:Microsoft.CodeAnalysis.ChangeSignature.SignatureChange"/> if successful.
            </summary>
            <param name="document">the context document</param>
            <param name="positionForTypeBinding">the position in the document with 
            the signature of the method, used for binding types (e.g. for added
            parameters)</param>
            <param name="symbol">the symbol for changing the signature</param>
            <param name="parameters">existing parameters of the symbol</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ChangeSignature.Parameter">
            <summary>
            Base type for Parameter information, whether the parameter
            is preexisting or new.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ChangeSignature.AddedParameter.CallSiteValue">
            <summary>
            Display string for the Call Site column in the Change Signature dialog.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ChangeSignature.AddedParameter.IsRequired">
            <summary>
            True if required, false if optional with a default value.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ChangeSignature.AddedParameter.DefaultValue">
            <summary>
            Value to use in the declaration of an optional parameter.
            E.g. the "3" in M(int x = 3);
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Classification.AbstractEmbeddedLanguageClassificationService._fallbackClassifier">
            <summary>
            Finally classifier to run if there is no embedded language in a string.  It will just classify escape sequences.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Classification.EmbeddedLanguageClassificationContext._spanToClassify">
            <summary>
            The portion of the string or character token to classify.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Classification.EmbeddedLanguageClassificationContext.SyntaxToken">
            <summary>
            The string or character token to classify.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Classification.EmbeddedLanguageClassificationContext.SemanticModel">
            <summary>
            SemanticModel that <see cref="P:Microsoft.CodeAnalysis.Classification.EmbeddedLanguageClassificationContext.SyntaxToken"/> is contained in.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Classification.ExportEmbeddedLanguageClassifierAttribute">
            <summary>
            Use this attribute to export a <see cref="T:Microsoft.CodeAnalysis.Classification.IEmbeddedLanguageClassifier"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.ExportEmbeddedLanguageClassifierAttribute.#ctor(System.String,System.String[],System.Boolean,System.String[])">
            <summary>
            Use this attribute to export a <see cref="T:Microsoft.CodeAnalysis.Classification.IEmbeddedLanguageClassifier"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.IEmbeddedLanguageClassifier.RegisterClassifications(Microsoft.CodeAnalysis.Classification.EmbeddedLanguageClassificationContext)">
            <summary>
            This method will be called for all string and character tokens in a file to determine if there are special
            embedded language strings to classify.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.AbstractFixAllCodeAction">
            <summary>
            Fix all code action for a code action registered by
            a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/> or a <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.AbstractFixAllCodeAction.#ctor(Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllState,System.Boolean)">
            <summary>
            Fix all code action for a code action registered by
            a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/> or a <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.AbstractFixAllCodeAction.IsInternalProvider(Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllState)">
            <summary>
            Determine if the <see cref="P:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllState.Provider"/> is an internal first-party provider or not.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.AbstractFixAllCodeAction.CreateFixAllContext(Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllState,System.IProgress{Microsoft.CodeAnalysis.CodeAnalysisProgress},System.Threading.CancellationToken)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllContext"/> with the given parameters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.AbstractFixAllCodeAction.TestAccessor.ShowPreviewChangesDialog">
            <summary>
            Gets a reference to <see cref="F:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.AbstractFixAllCodeAction._showPreviewChangesDialog"/>, which can be read or written by test code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllGetFixesService.GetFixAllOperationsAsync(Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllContext,System.Boolean)">
            <summary>
            Computes the fix all occurrences code fix, brings up the preview changes dialog for the fix and
            returns the code action operations corresponding to the fix.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllGetFixesService.GetFixAllChangedSolutionAsync(Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllContext)">
            <summary>
            Computes the fix all occurrences code fix and returns the changed solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllGetFixesService.PreviewChanges(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.CodeFixesAndRefactorings.FixAllKind,System.String,System.String,System.String,System.Nullable{System.Int32},System.Threading.CancellationToken)">
            <summary>
            Previews the changes that would occur after a code fix and returns the updated solution with those changes.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeActions.ICodeActionRequestPriorityProvider.Priority">
            <summary>
            <see langword="null"/> represents no specified priority.  i.e. any priority should match this.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.ICodeActionRequestPriorityProvider.AddDeprioritizedAnalyzerWithLowPriority(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer)">
            <summary>
            Tracks the given <paramref name="analyzer"/> as a de-prioritized analyzer that should be moved to
            <see cref="F:Microsoft.CodeAnalysis.CodeActions.CodeActionRequestPriority.Low"/> bucket.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.ICodeActionRequestPriorityProvider.HasDeprioritizedAnalyzerSupportingDiagnosticId(System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
            Indicates whether any deprioritized analyzer supports one of the passed in diagnostic ids.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.ICodeActionRequestPriorityProviderExtensions.MatchesPriority(Microsoft.CodeAnalysis.CodeActions.ICodeActionRequestPriorityProvider,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer)">
            <summary>
            Returns true if the given <paramref name="analyzer"/> can report diagnostics that can have fixes from a code
            fix provider with <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider.RequestPriority"/> matching <see
            cref="P:Microsoft.CodeAnalysis.CodeActions.ICodeActionRequestPriorityProvider.Priority"/>. This method is useful for performing a performance
            optimization for lightbulb diagnostic computation, wherein we can reduce the set of analyzers to be executed
            when computing fixes for a specific <see cref="P:Microsoft.CodeAnalysis.CodeActions.ICodeActionRequestPriorityProvider.Priority"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.ICodeActionRequestPriorityProviderExtensions.MatchesPriority(Microsoft.CodeAnalysis.CodeActions.ICodeActionRequestPriorityProvider,Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider)">
            <summary>
            Returns true if the given <paramref name="codeFixProvider"/> should be considered a candidate when computing
            fixes for the given <see cref="P:Microsoft.CodeAnalysis.CodeActions.ICodeActionRequestPriorityProvider.Priority"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.DocumentNavigationOperation">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation"/> for navigating to a specific position in a document.
            When <see cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetOperationsAsync(System.Threading.CancellationToken)"/> is called an implementation
            of <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> can return an instance of this operation along with the other 
            operations they want to apply.  For example, an implementation could generate a new <see cref="T:Microsoft.CodeAnalysis.Document"/>
            in one <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation"/> and then have the host editor navigate to that
            <see cref="T:Microsoft.CodeAnalysis.Document"/> using this operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.DocumentNavigationOperation.#ctor(Microsoft.CodeAnalysis.DocumentId,System.Int32)">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation"/> for navigating to a specific position in a document.
            When <see cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetOperationsAsync(System.Threading.CancellationToken)"/> is called an implementation
            of <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> can return an instance of this operation along with the other 
            operations they want to apply.  For example, an implementation could generate a new <see cref="T:Microsoft.CodeAnalysis.Document"/>
            in one <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation"/> and then have the host editor navigate to that
            <see cref="T:Microsoft.CodeAnalysis.Document"/> using this operation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.StartInlineRenameSessionOperation">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation"/> for navigating to a specific position in a document and invoking inline rename.
            When <see cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetOperationsAsync(System.Threading.CancellationToken)"/> is called an implementation
            of <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> can return an instance of this operation along with the other 
            operations they want to apply. For example, an implementation could generate a new <see cref="T:Microsoft.CodeAnalysis.Document"/>
            in one <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation"/> and then have the host editor navigate to that
            <see cref="T:Microsoft.CodeAnalysis.Document"/> and invoke rename at a given position using this operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.StartInlineRenameSessionOperation.#ctor(Microsoft.CodeAnalysis.DocumentId,System.Int32)">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation"/> for navigating to a specific position in a document and invoking inline rename.
            When <see cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetOperationsAsync(System.Threading.CancellationToken)"/> is called an implementation
            of <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> can return an instance of this operation along with the other 
            operations they want to apply. For example, an implementation could generate a new <see cref="T:Microsoft.CodeAnalysis.Document"/>
            in one <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation"/> and then have the host editor navigate to that
            <see cref="T:Microsoft.CodeAnalysis.Document"/> and invoke rename at a given position using this operation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.AbstractConfigurationActionWithNestedActions">
            <summary>
            Represents a configuration code action with nested actions registered by individual <see cref="T:Microsoft.CodeAnalysis.CodeFixes.IConfigurationFixProvider"/>s.
            Note that the code fix/light bulb engine groups all such <see cref="T:Microsoft.CodeAnalysis.CodeFixes.AbstractConfigurationActionWithNestedActions"/> from different providers
            into another top level suggested action to avoid light bulb clutter. This topmost suggested action is *not* represented by this code action.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.AbstractConfigurationActionWithNestedActions.AdditionalPriority">
            <summary>
            Additional priority associated with all configuration and suppression code actions.
            This allows special code actions such as Bulk configuration to to be at the end of
            all suppression and configuration actions by having a lower additional priority.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixCollection">
            <summary>
            Represents a collection of <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFix"/>es supplied by a given fix provider
            (such as <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/> or <see cref="T:Microsoft.CodeAnalysis.CodeFixes.IConfigurationFixProvider"/>).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixCollection.#ctor(System.Object,Microsoft.CodeAnalysis.Text.TextSpan,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeFixes.CodeFix},Microsoft.CodeAnalysis.CodeFixes.FixAllState,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeFixes.FixAllScope},Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            Represents a collection of <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFix"/>es supplied by a given fix provider
            (such as <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/> or <see cref="T:Microsoft.CodeAnalysis.CodeFixes.IConfigurationFixProvider"/>).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixCollection.FixAllState">
            <summary>
            Optional fix all context, which is non-null if the given <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixCollection.Provider"/> supports fix all occurrences code fix.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.Configuration.ConfigurationUpdater">
            <summary>
            Helper class to configure diagnostic severity or code style option value based on .editorconfig file
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.Configuration.ConfigurationUpdater.ConfigureSeverityAsync(Microsoft.CodeAnalysis.ReportDiagnostic,Microsoft.CodeAnalysis.Diagnostic,Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)">
            <summary>
            Updates or adds an .editorconfig <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfigDocument"/> to the given <paramref name="project"/>
            so that the severity of the given <paramref name="diagnostic"/> is configured to be the given
            <paramref name="severity"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.Configuration.ConfigurationUpdater.ConfigureSeverityAsync(System.String,Microsoft.CodeAnalysis.Diagnostic,Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)">
            <summary>
            Updates or adds an .editorconfig <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfigDocument"/> to the given <paramref name="project"/>
            so that the severity of the given <paramref name="diagnostic"/> is configured to be the given
            <paramref name="editorConfigSeverity"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.Configuration.ConfigurationUpdater.BulkConfigureSeverityAsync(System.String,System.String,Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)">
            <summary>
            Updates or adds an .editorconfig <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfigDocument"/> to the given <paramref name="project"/>
            so that the default severity of the diagnostics with the given <paramref name="category"/> is configured to be the given
            <paramref name="editorConfigSeverity"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.Configuration.ConfigurationUpdater.BulkConfigureSeverityAsync(System.String,Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)">
            <summary>
            Updates or adds an .editorconfig <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfigDocument"/> to the given <paramref name="project"/>
            so that the default severity of all diagnostics is configured to be the given
            <paramref name="editorConfigSeverity"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.Configuration.ConfigurationUpdater.ConfigureCodeStyleOptionAsync(System.String,System.String,Microsoft.CodeAnalysis.Diagnostic,System.Boolean,Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)">
            <summary>
            Updates or adds an .editorconfig <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfigDocument"/> to the given <paramref name="project"/>
            so that the given <paramref name="optionName"/> is configured to have the given <paramref name="optionValue"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.AbstractFixAllCodeFixCodeAction">
            <summary>
            Fix all code action for a code action registered by a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.IFixMultipleOccurrencesService.GetFixAsync(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic}},Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider,Microsoft.CodeAnalysis.CodeFixes.FixAllProvider,System.String,System.String,System.String,System.IProgress{Microsoft.CodeAnalysis.CodeAnalysisProgress},System.Threading.CancellationToken)">
            <summary>
            Get the fix multiple occurrences code fix for the given diagnostics with source locations.
            NOTE: This method does not apply the fix to the workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.IFixMultipleOccurrencesService.GetFixAsync(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.Project,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic}},Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider,Microsoft.CodeAnalysis.CodeFixes.FixAllProvider,System.String,System.String,System.String,System.IProgress{Microsoft.CodeAnalysis.CodeAnalysisProgress},System.Threading.CancellationToken)">
            <summary>
            Get the fix multiple occurrences code fix for the given diagnostics with source locations.
            NOTE: This method does not apply the fix to the workspace.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.ICodeFixProviderFactory">
            <summary>
            CodeFixProvider factory. if an analyzer reference implements this, we call this to get CodeFixProviders
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixService.GetSuppressionFixer(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary> Looks explicitly for an <see cref="T:Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider"/>.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.ICodeFixService.GetMostSevereFixAsync(Microsoft.CodeAnalysis.TextDocument,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.CodeActions.ICodeActionRequestPriorityProvider,System.Threading.CancellationToken)">
            <summary>
            Similar to <see cref="M:Microsoft.CodeAnalysis.CodeFixes.ICodeFixService.StreamFixesAsync(Microsoft.CodeAnalysis.TextDocument,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.CodeActions.ICodeActionRequestPriorityProvider,System.Threading.CancellationToken)"/> except that instead of streaming all results, this ends with the
            first.  This will also attempt to return a fix for an error first, but will fall back to any fix if that
            does not succeed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionBatchFixAllProvider">
            <summary>
            Helper class for "Fix all occurrences" code fix providers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider.IPragmaBasedCodeAction">
            <summary>
            Suppression code action based on pragma add/remove/edit.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider.PragmaBatchFixHelpers">
            <summary>
            Helper methods for pragma suppression add/remove batch fixers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider.PragmaHelpers">
            <summary>
            Helper methods for pragma based suppression code actions.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider.PragmaWarningBatchFixAllProvider">
            <summary>
            Batch fixer for pragma suppress code action.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider.PragmaWarningBatchFixAllProvider.#ctor(Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider)">
            <summary>
            Batch fixer for pragma suppress code action.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider.RemoveSuppressionCodeAction">
            <summary>
            Base type for remove suppression code actions.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider.RemoveSuppressionCodeAction.RemoveSuppressionBatchFixAllProvider">
            <summary>
            Batch fixer for pragma suppression removal code action.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider.RemoveSuppressionCodeAction.RemoveSuppressionBatchFixAllProvider.#ctor(Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider)">
            <summary>
            Batch fixer for pragma suppression removal code action.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider.RemoveSuppressionCodeAction.AttributeRemoveAction">
            <summary>
            Code action to remove suppress message attributes for remove suppression.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider.RemoveSuppressionCodeAction.PragmaRemoveAction">
            <summary>
            Code action to edit/remove/add the pragma directives for removing diagnostic suppression.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.ExportConfigurationFixProviderAttribute">
            <summary>
            Use this attribute to declare a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.IConfigurationFixProvider"/> implementation so that it can be discovered by the host.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.ExportConfigurationFixProviderAttribute.Name">
            <summary>
            The name of the <see cref="T:Microsoft.CodeAnalysis.CodeFixes.IConfigurationFixProvider"/>.  
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.ExportConfigurationFixProviderAttribute.Languages">
            <summary>
            The source languages this provider can provide fixes for.  See <see cref="T:Microsoft.CodeAnalysis.LanguageNames"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeFixes.AddExplicitCast.AbstractAddExplicitCastCodeFixProvider`1.MaximumConversionOptions">
            <summary>
            Give a set of least specific types with a limit, and the part exceeding the limit doesn't show any code fix, but
            logs telemetry.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.AddExplicitCast.AbstractAddExplicitCastCodeFixProvider`1.GetPotentialTargetTypes(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.String,`0,System.Threading.CancellationToken)">
            <summary>
            Output the current type information of the target node and the conversion type(s) that the target node is going
            to be cast by. Implicit downcast can appear on Variable Declaration, Return Statement, Function Invocation,
            Attribute
            <para/>
            For example:
            Base b; Derived d = [||]b;
            "b" is the current node with type "Base", and the potential conversion types list which "b" can be cast by
            is {Derived}
            </summary>
            <param name="diagnosticId">The Id of diagnostic</param>
            <param name="spanNode">the innermost node that contains the span</param>
            <returns>
            Output (target expression, potential conversion type) pairs.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.AddExplicitCast.AbstractAddExplicitCastCodeFixProvider`1.Fixer`3.GetPotentialConversionTypes(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,`1,`2,`3,System.Threading.CancellationToken)">
            <summary>
            Collect all the available cast pairs, format is (target argument expression, potential conversion type)
            </summary>
            <param name="targetArgument"> The argument that need to be cast</param>
            <param name="argumentList"> The argument list that contains the target argument to be cast </param>
            <param name="invocationNode"> The invocation node that is the parent of "argumentList"</param>
            <returns>
            Return all the available cast pairs, format is (target argument expression, potential conversion type)
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.AddExplicitCast.AbstractAddExplicitCastCodeFixProvider`1.Fixer`3.CanArgumentTypesBeConvertedToParameterTypes(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,`2,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IParameterSymbol},`1,System.Threading.CancellationToken,Microsoft.CodeAnalysis.ITypeSymbol@)">
             <summary>
             Test if all argument types can be converted to corresponding parameter types.
             </summary>
             For example:
             class Base { }
             class Derived1 : Base { }
             class Derived2 : Base { }
             class Derived3 : Base { }
             void DoSomething(int i, Derived1 d) { }
             void DoSomething(string s, Derived2 d) { }
             void DoSomething(int i, Derived3 d) { }
             
             Base b;
             DoSomething(1, [||]b);
            
             *void DoSomething(string s, Derived2 d) { }* is not the perfect match candidate function for
             *DoSomething(1, [||]b)* because int and string are not ancestor-descendant relationship. Thus,
             Derived2 is not a potential conversion type.
             
             <param name="argumentList"> The argument list of invocation expression</param>
             <param name="parameters"> The parameters of function</param>
             <param name="targetArgument">The argument need to be cast.</param>
             <param name="targetArgumentConversionType"> Output the corresponding parameter type of
             "targetArgument" if function returns true</param>
             <returns>
             True, if arguments and parameters match perfectly.
             "targetArgumentConversionType" outputs the corresponding parameter type of "targetArgument"
             False, otherwise.
             </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.AddExplicitCast.AbstractAddExplicitCastCodeFixProvider`1.Fixer`3.IsInvocationExpressionWithNewArgumentsApplicable(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,`2,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{`1},Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Check whether the invocation expression with new arguments is applicable.
            </summary>
            <param name="oldArgumentList" >old argumentList node</param>
            <param name="newArguments"> new arguments that are cast by corresponding parameter types</param>
            <param name="targetNode"> The node needs to be cast.</param>
            <returns>
            Return true if the invocation expression with new arguments is applicable.
            Otherwise, return false
            </returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.AddExplicitCast.InheritanceDistanceComparer`1">
            <summary>
            The item is the pair of target argument expression and its conversion type
            <para/>
            Sort pairs using conversion types by inheritance distance from the base type in ascending order,
            i.e., less specific type has higher priority because it has less probability to make mistakes
            <para/>
            For example:
            class Base { }
            class Derived1 : Base { }
            class Derived2 : Derived1 { }
            
            void Foo(Derived1 d1) { }
            void Foo(Derived2 d2) { }
            
            Base b = new Derived1();
            Foo([||]b);
            
            operations:
            1. Convert type to 'Derived1'
            2. Convert type to 'Derived2'
            
            'Derived1' is less specific than 'Derived2' compared to 'Base'
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.AddExplicitCast.InheritanceDistanceComparer`1.#ctor(Microsoft.CodeAnalysis.SemanticModel)">
            <summary>
            The item is the pair of target argument expression and its conversion type
            <para/>
            Sort pairs using conversion types by inheritance distance from the base type in ascending order,
            i.e., less specific type has higher priority because it has less probability to make mistakes
            <para/>
            For example:
            class Base { }
            class Derived1 : Base { }
            class Derived2 : Derived1 { }
            
            void Foo(Derived1 d1) { }
            void Foo(Derived2 d2) { }
            
            Base b = new Derived1();
            Foo([||]b);
            
            operations:
            1. Convert type to 'Derived1'
            2. Convert type to 'Derived2'
            
            'Derived1' is less specific than 'Derived2' compared to 'Base'
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.AddExplicitCast.InheritanceDistanceComparer`1.GetInheritanceDistanceRecursive(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Calculate the inheritance distance between baseType and derivedType.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.AddExplicitCast.InheritanceDistanceComparer`1.GetInheritanceDistance(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Wrapper function of [GetInheritanceDistance], also consider the class with explicit conversion operator
            has the highest priority.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.MatchFolderAndNamespace.AbstractChangeNamespaceToMatchFolderCodeFixProvider">
            <summary>
            Custom fix all provider for namespace sync. Does fix all on per document level. Since
            multiple documents may be updated when changing a single namespace, it happens 
            on a sequential level instead of batch fixing and merging the changes. This prevents
            collisions that the batch fixer won't handle correctly but is slower.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.NamingStyles.NamingStyleCodeFixProvider.FixNameCodeAction.Tags">
            <summary>
            This code action does produce non-text-edit operations (like notifying 3rd parties about a rename).  But
            it doesn't require this.  As such, we can allow it to run in hosts that only allow document edits. Those
            hosts will simply ignore the operations they don't understand.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeLens.CodeLensFindReferencesProgress">
            <summary>
            Tracks incremental progress of a find references search, we use this to
            count the number of references up until a certain cap is reached and cancel the search
            or until the search completes, if such a cap is not reached.
            </summary>
            <remarks>
            All public methods of this type could be called from multiple threads.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeLens.CodeLensFindReferencesProgress.#ctor(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Tracks incremental progress of a find references search, we use this to
            count the number of references up until a certain cap is reached and cancel the search
            or until the search completes, if such a cap is not reached.
            </summary>
            <remarks>
            All public methods of this type could be called from multiple threads.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.CodeLensFindReferencesProgress.SearchCap">
            <remarks>
            If the cap is 0, then there is no cap.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.CodeLensFindReferencesProgress.CancellationToken">
            <summary>
            The cancellation token that aggregates the original cancellation token + this progress
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeLens.CodeLensFindReferencesProgress.FilterReference(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation)">
            <summary>
            Exclude the following kind of symbols:
             1. Implicitly declared symbols (such as implicit fields backing properties)
             2. Symbols that can't be referenced by name (such as property getters and setters).
             3. Metadata only symbols, i.e. symbols with no location in source.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeLens.CodeLensReferencesService.s_nonParallelSearch">
            <summary>
            Set ourselves as an implicit invocation of FindReferences.  This will cause the finding operation to operate
            in serial, not parallel.  We're running ephemerally in the BG and do not want to saturate the system with
            work that then slows the user down.  Also, only process the inheritance hierarchy unidirectionally.  We want
            to find references that could actually call into a particular, not references to other members that could
            never actually call into this member.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeLens.ICodeLensDisplayInfoService.GetDisplayNode(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the node used for display info
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeLens.ICodeLensDisplayInfoService.GetDisplayName(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the DisplayName for the given node
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeLens.ICodeLensMemberFinder.GetCodeLensMembersAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Returns members in the document that are valid code lens locations.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeLens.CodeLensMember">
            <summary>
            Holds the node (for later reference count computation) and the span associated with the code lens element.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeLens.CodeLensMember.#ctor(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Holds the node (for later reference count computation) and the span associated with the code lens element.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeLens.ICodeLensReferencesService.GetReferenceCountAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Given a document and syntax node, returns the number of locations where the located node is referenced.
            <para>
                Optionally, the service supports capping the reference count to a value specified by <paramref name="maxSearchResults"/>
                if <paramref name="maxSearchResults"/> is greater than 0.
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeLens.ICodeLensReferencesService.FindReferenceLocationsAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Given a document and syntax node, returns a collection of locations where the located node is referenced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeLens.ICodeLensReferencesService.FindReferenceMethodsAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Given a document and syntax node, returns a collection of locations of methods that refer to the located node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeLens.ICodeLensReferencesService.GetFullyQualifiedNameAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Given a document and syntax node, returns the fully qualified name of the located node's declaration.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeLens.ReferenceCount">
            <summary>
            Represents the result of a FindReferences Count operation.
            </summary>
            <param name="Count">Represents the number of references to a given symbol.</param>
            <param name="IsCapped">Represents if the count is capped by a certain maximum.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeLens.ReferenceCount.#ctor(System.Int32,System.Boolean,System.String)">
            <summary>
            Represents the result of a FindReferences Count operation.
            </summary>
            <param name="Count">Represents the number of references to a given symbol.</param>
            <param name="IsCapped">Represents if the count is capped by a certain maximum.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceCount.Count">
            <summary>Represents the number of references to a given symbol.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceCount.IsCapped">
            <summary>Represents if the count is capped by a certain maximum.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor">
            <summary>
            Holds information required to display and navigate to individual references
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor.#ctor(System.String,System.String,System.Nullable{Microsoft.CodeAnalysis.Glyph},System.Int32,System.Int32,System.Int32,System.Int32,System.Guid,System.Guid,System.String,System.String,System.Int32,System.Int32,System.String,System.String,System.String,System.String)">
            <summary>
            Holds information required to display and navigate to individual references
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor.LongDescription">
            <summary>
            Fully qualified name of the symbol containing the reference location
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor.Language">
            <summary>
            Language of the reference location
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor.Glyph">
            <summary>
            The kind of symbol containing the reference location (such as type, method, property, etc.)
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor.SpanStart">
            <summary>
            Reference's span start based on the document content
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor.SpanLength">
            <summary>
            Reference's span length based on the document content
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor.LineNumber">
            <summary>
            Reference's line based on the document content
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor.ColumnNumber">
            <summary>
            Reference's character based on the document content
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor.FilePath">
            <summary>
            Document's file path
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor.ReferenceLineText">
            <summary>
            the full line of source that contained the reference
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor.ReferenceStart">
            <summary>
            the beginning of the span within reference text that was the use of the reference
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor.ReferenceLength">
            <summary>
            the length of the span of the reference
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor.BeforeReferenceText1">
            <summary>
            Text above the line with the reference
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor.BeforeReferenceText2">
            <summary>
            Text above the line with the reference
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor.AfterReferenceText1">
            <summary>
            Text below the line with the reference
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor.AfterReferenceText2">
            <summary>
            Text below the line with the reference
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeLens.ReferenceMethodDescriptor">
            <summary>
            A caller method of a callee
            </summary>
            <remarks>
            Describe a caller method of a callee
            </remarks>
            <param name="fullName">Method's fully qualified name</param>
            <param name="filePath">Method full path</param>
            <remarks>
             Method full name is expected to be in the .NET full name type convention. That is,
             namespace/type is delimited by '.' and nested type is delimited by '+'
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeLens.ReferenceMethodDescriptor.#ctor(System.String,System.String,System.String)">
            <summary>
            A caller method of a callee
            </summary>
            <remarks>
            Describe a caller method of a callee
            </remarks>
            <param name="fullName">Method's fully qualified name</param>
            <param name="filePath">Method full path</param>
            <remarks>
             Method full name is expected to be in the .NET full name type convention. That is,
             namespace/type is delimited by '.' and nested type is delimited by '+'
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceMethodDescriptor.FullName">
            <summary>
             Returns method's fully quilified name without parameters
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceMethodDescriptor.FilePath">
            <summary>
            Returns method's file path.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeLens.ReferenceMethodDescriptor.OutputFilePath">
            <summary>
            Returns output file path for the project containing the method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeRefactorings.AddAwait.AbstractAddAwaitCodeRefactoringProvider`1">
             <summary>
             Refactor:
                 var x = GetAsync();
            
             Into:
                 var x = await GetAsync();
            
             Or:
                 var x = await GetAsync().ConfigureAwait(false);
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoring">
            <summary>
            Represents a set of transformations that can be applied to a piece of code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoring.CodeActions">
            <summary>
            List of tuples of possible actions that can be used to transform the code the TextSpan within the original document they're applicable to.
            </summary>
            <remarks>
            applicableToSpan should represent a logical section within the original document that the action is 
            applicable to. It doesn't have to precisely represent the exact <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> that will get changed.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeRefactorings.FixAllCodeRefactoringCodeAction">
            <summary>
            Fix all code action for a code action registered by a <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.FixAllCodeRefactoringCodeAction.#ctor(Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllState)">
            <summary>
            Fix all code action for a code action registered by a <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService.NamespaceScopeMovedAnnotation">
            <summary>
            Annotation to mark the namespace encapsulating the type that has been moved
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`4.MultipleTopLevelTypeDeclarationInSourceDocument(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            checks if there is a single top level type declaration in a document
            </summary>
            <remarks>
            optimized for perf, uses Skip(1).Any() instead of Count() > 1
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`4.TypeMatchesDocumentName(`1,System.String)">
            <summary>
            checks if type name matches its parent document name, per style rules.
            </summary>
            <remarks>
            Note: For a nested type, a matching document name could be just the type name or a
            dotted qualified name of its type hierarchy.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`4.Editor">
            <summary>
            An abstract class for different edits performed by the Move Type Code Action.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`4.Editor.#ctor(`0,Microsoft.CodeAnalysis.SemanticDocument,`1,System.String,System.Threading.CancellationToken)">
            <summary>
            An abstract class for different edits performed by the Move Type Code Action.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`4.Editor.GetOperationsAsync">
            <summary>
            Operations performed by CodeAction.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`4.Editor.GetModifiedSolutionAsync">
            <summary>
            Incremental solution edits that correlate to code operations
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`4.MoveTypeEditor.GetModifiedSolutionAsync">
            <summary>
            Given a document and a type contained in it, moves the type
            out to its own document. The new document's name typically
            is the type name, or is at least based on the type name.
            </summary>
            <remarks>
            The algorithm for this, is as follows:
            1. Fork the original document that contains the type to be moved.
            2. Keep the type, required namespace containers and using statements.
               remove everything else from the forked document.
            3. Add this forked document to the solution.
            4. Finally, update the original document and remove the type from it.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`4.MoveTypeEditor.AddNewDocumentWithSingleTypeDeclarationAsync(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Forks the source document, keeps required type, namespace containers
            and adds it the solution.
            </summary>
            <param name="newDocumentId">id for the new document to be added</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`4.MoveTypeEditor.AddFinalNewLineIfDesiredAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Add a trailing newline if we don't already have one if that's what the user's 
            preference is.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`4.MoveTypeEditor.RemoveTypeFromSourceDocumentAsync(Microsoft.CodeAnalysis.Document)">
            <summary>
            update the original document and remove the type that was moved.
            perform other fix ups as necessary.
            </summary>
            <returns>an updated solution with the original document fixed up as appropriate.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`4.MoveTypeEditor.GetMembersToRemove(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Traverses the syntax tree of the forked document and
            collects a list of nodes that are not being moved.
            This list of nodes are then removed from the forked copy.
            </summary>
            <param name="root">root, of the syntax tree of forked document</param>
            <returns>list of syntax nodes, to be removed from the forked copy.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`4.MoveTypeEditor.AddPartialModifiersToTypeChain(Microsoft.CodeAnalysis.Editing.DocumentEditor,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            if a nested type is being moved, this ensures its containing type is partial.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`4.MoveTypeNamespaceScopeEditor">
            <summary>
            Editor that takes a type in a scope and creates a scope beside it. For example, if the type is contained within a namespace 
            it will evaluate if the namespace scope needs to be closed and reopened to create a new scope. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`4.MoveTypeNamespaceScopeEditor.#ctor(`0,Microsoft.CodeAnalysis.SemanticDocument,`1,System.String,System.Threading.CancellationToken)">
            <summary>
            Editor that takes a type in a scope and creates a scope beside it. For example, if the type is contained within a namespace 
            it will evaluate if the namespace scope needs to be closed and reopened to create a new scope. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`4.RenameFileEditor">
            <summary>
            Renames the file to match the type contained in it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`4.RenameFileEditor.#ctor(`0,Microsoft.CodeAnalysis.SemanticDocument,`1,System.String,System.Threading.CancellationToken)">
            <summary>
            Renames the file to match the type contained in it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`4.RenameTypeEditor.GetModifiedSolutionAsync">
            <summary>
            Renames a type to match its containing file name.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.MoveTypeOperationKind.MoveType">
            <summary>
            Moves a type to it's own file
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.MoveTypeOperationKind.MoveTypeNamespaceScope">
            <summary>
            Functionally doesn't change the type symbol, but moves it to it's own
            namespace declaration scope. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.MoveTypeOperationKind.RenameType">
            <summary>
            Renames the target type
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeRefactorings.MoveType.MoveTypeOperationKind.RenameFile">
            <summary>
            Renames the file containing the target type
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.SyncNamespace.AbstractSyncNamespaceCodeRefactoringProvider`3.TryGetApplicableInvocationNodeAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
            <summary>
            Try to get the node that can be used to trigger the refactoring based on current cursor position. 
            </summary>
            <returns>
            (1) a node of type <typeparamref name="TNamespaceDeclarationSyntax"/> node, if cursor in the name and it's the 
            only namespace declaration in the document.
            (2) a node of type <typeparamref name="TCompilationUnitSyntax"/> node, if the cursor is in the name of first 
            declaration in global namespace and there's no namespace declaration in this document.
            (3) otherwise, null.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.SyncNamespace.AbstractSyncNamespaceCodeRefactoringProvider`3.MoveFileCodeAction.FindCandidateFolders(Microsoft.CodeAnalysis.CodeRefactorings.SyncNamespace.AbstractSyncNamespaceCodeRefactoringProvider{`0,`1,`2}.MoveFileCodeAction.FolderInfo,System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
            We try to provide additional "move file" options if we can find existing folders that matches target namespace.
            For example, if the target namespace is 'DefaultNamesapce.A.B.C', and there's a folder 'ProjectRoot\A.B\' already 
            exists, then will provide two actions, "move file to ProjectRoot\A.B\C\" and "move file to ProjectRoot\A\B\C\".
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.SyncNamespace.AbstractSyncNamespaceCodeRefactoringProvider`3.State.Document">
            <summary>
            The document in which the refactoring is triggered.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.SyncNamespace.AbstractSyncNamespaceCodeRefactoringProvider`3.State.Container">
            <summary>
            The applicable container node based on cursor location,
            which will be used to change namespace.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.SyncNamespace.AbstractSyncNamespaceCodeRefactoringProvider`3.State.TargetNamespace">
            <summary>
            This is the new name we want to change the namespace to.
            Empty string means global namespace, whereas null means change namespace action is not available.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.SyncNamespace.AbstractSyncNamespaceCodeRefactoringProvider`3.State.RelativeDeclaredNamespace">
            <summary>
            This is the part of the declared namespace that is contained in default namespace.
            We will use this to construct target folder to move the file to.
            For example, if default namespace is `A` and declared namespace is `A.B.C`, 
            this would be `B.C`.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.SyncNamespace.AbstractSyncNamespaceCodeRefactoringProvider`3.State.IsDocumentPathRootedInProjectFolder(Microsoft.CodeAnalysis.Document)">
            <summary>
            Determines if the actual file path matches its logical path in project 
            which is constructed as [project_root_path]\Logical\Folders\. The refactoring 
            is triggered only when the two match. The reason of doing this is we don't really know
            the user's intention of keeping the file path out-of-sync with its logical path.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.SyncNamespace.AbstractSyncNamespaceCodeRefactoringProvider`3.State.GetRelativeNamespace(System.String,System.String,Microsoft.CodeAnalysis.LanguageService.ISyntaxFactsService)">
            <summary>
            Try get the relative namespace for <paramref name="namespace"/> based on <paramref name="relativeTo"/>,
            if <paramref name="relativeTo"/> is the containing namespace of <paramref name="namespace"/>. Otherwise,
            Returns null.
            For example:
            - If <paramref name="relativeTo"/> is "A.B" and <paramref name="namespace"/> is "A.B.C.D", then
            the relative namespace is "C.D".
            - If <paramref name="relativeTo"/> is "A.B" and <paramref name="namespace"/> is also "A.B", then
            the relative namespace is "".
            - If <paramref name="relativeTo"/> is "" then the relative namespace us <paramref name="namespace"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeRefactorings.PullMemberUp.AbstractPullMemberUpRefactoringProvider.PullMemberUpWithDialogCodeAction._selectedMembers">
            <summary>
            Member which user initially selects. It will be selected initially when the dialog pops up.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeRefactorings.PullMemberUp.MembersPuller.s_removableImportAnnotation">
            <summary>
            Annotation used to mark imports that we move over, so that we can remove these imports if they are unnecessary
            (and so we don't remove any other unnecessary imports)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.PullMemberUp.MembersPuller.GetLeadingTriviaBeforeFirstMember(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.LanguageService.ISyntaxFactsService)">
            <summary>
            In the case where we have leading whitespace in front of the first member and there are no imports, adding imports
            moves that trivia to above the import (and sometimes removes it entirely if the import is later removed). 
            So, we want to cache the trivia before, delete it, then add it back in after the imports are added.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.PullMemberUp.MembersPuller.GetImports(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.LanguageService.ISyntaxFactsService)">
            <summary>
            Get all import statements in scope for this syntax by traversing up the tree and searching in containing namespaces and compilation units.
            </summary>
            <param name="start">The node to start traversing up from</param>
            <returns>All the import/using directives found along the traversal</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.PullMemberUp.MembersPuller.IsSelectedMemberDeclarationAlreadyInDestination(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
             This method is used to check whether the selected member overrides the member in destination.
             It just checks the members directly declared in the destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddMissingImports.IAddMissingImportsFeatureService.AnalyzeAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Analyzes the document inside the <paramref name="textSpan"/> to determine if imports can be added.
            </summary>
            <param name="cleanupDocument">Whether the document should be cleaned up after an import is added.
            For example, in VB this may then case correct previous unbound references based on the new names
            brought into scope.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddMissingImports.IAddMissingImportsFeatureService.AddMissingImportsAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AddImport.AddImportFixData},System.IProgress{Microsoft.CodeAnalysis.CodeAnalysisProgress},System.Threading.CancellationToken)">
            <summary>
            Performs the same action as <see cref="M:Microsoft.CodeAnalysis.AddMissingImports.IAddMissingImportsFeatureServiceExtensions.AddMissingImportsAsync(Microsoft.CodeAnalysis.AddMissingImports.IAddMissingImportsFeatureService,Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.IProgress{Microsoft.CodeAnalysis.CodeAnalysisProgress},System.Threading.CancellationToken)"/> but
            with a predetermined analysis of the input instead of recalculating it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddMissingImports.IAddMissingImportsFeatureServiceExtensions.AddMissingImportsAsync(Microsoft.CodeAnalysis.AddMissingImports.IAddMissingImportsFeatureService,Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.IProgress{Microsoft.CodeAnalysis.CodeAnalysisProgress},System.Threading.CancellationToken)">
            <summary>
            Attempts to add missing imports to the document within the provided <paramref name="textSpan"/>. The imports
            added will not add references to the project. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService">
            <summary>
            This intermediate class is used to hide method `TryGetReplacementReferenceSyntax` from <see cref="T:Microsoft.CodeAnalysis.ChangeNamespace.IChangeNamespaceService" />.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService.TryGetReplacementReferenceSyntax(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray{System.String},Microsoft.CodeAnalysis.LanguageService.ISyntaxFactsService,Microsoft.CodeAnalysis.SyntaxNode@,Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            Try to get a new node to replace given node, which is a reference to a top-level type declared inside the 
            namespace to be changed. If this reference is the right side of a qualified name, the new node returned would
            be the entire qualified name. Depends on whether <paramref name="newNamespaceParts"/> is provided, the name 
            in the new node might be qualified with this new namespace instead.
            </summary>
            <param name="reference">A reference to a type declared inside the namespace to be changed, which is calculated 
            based on results from `SymbolFinder.FindReferencesAsync`.</param>
            <param name="newNamespaceParts">If specified, the namespace of original reference will be replaced with given 
            namespace in the replacement node.</param>
            <param name="old">The node to be replaced. This might be an ancestor of original </param>
            <param name="new">The replacement node.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`6.ContainerAnnotation">
            <summary>
            The annotation used to track applicable container in each document to be fixed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`6.GetValidContainersFromAllLinkedDocumentsAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Decide if we can change the namespace for provided <paramref name="container"/> based on the criteria listed for 
            <see cref="M:Microsoft.CodeAnalysis.ChangeNamespace.IChangeNamespaceService.CanChangeNamespaceAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)"/>
            </summary>
            <returns>
            If namespace can be changed, returns a list of documents that linked to the provided document (including itself)
            and the corresponding container nodes in each document, which will later be used for annotation. Otherwise, a 
            default ImmutableArray is returned. Currently we only support linked document in multi-targeting project scenario.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`6.AnnotateContainersAsync(Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.ImmutableArray{System.ValueTuple{Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.SyntaxNode}},System.Threading.CancellationToken)">
            <summary>
            Mark container nodes with our annotation so we can keep track of them across syntax modifications.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`6.ChangeNamespaceInSingleDocumentAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.DocumentId,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Try to change the namespace declaration in the document (specified by <paramref name="id"/> in <paramref name="solution"/>).
            Returns a new solution after changing namespace, and a list of IDs for documents that also changed because they reference
            the types declared in the changed namespace (not include the document contains the declaration itself).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`6.FixReferencesAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.ChangeNamespace.IChangeNamespaceService,Microsoft.CodeAnalysis.AddImport.IAddImportsService,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService.LocationForAffectedSymbol},System.Collections.Immutable.ImmutableArray{System.String},System.Threading.CancellationToken)">
            <summary>
            Fix each reference and return a collection of proper containers (innermost container
            with imports) that new import should be added to based on reference locations.
            If <paramref name="newNamespaceParts"/> is specified (not default), the fix would be:
                1. qualify the reference with new namespace and mark it for simplification, or
                2. find and mark the qualified reference for simplification.
            Otherwise, there would be no namespace replacement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`6.AddImportsInContainersAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.AddImport.IAddImportsService,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Immutable.ImmutableArray{System.String},Microsoft.CodeAnalysis.AddImport.AddImportPlacementOptions,System.Threading.CancellationToken)">
            <summary>
            Add imports for the namespace specified by <paramref name="names"/>
            to the provided <paramref name="containers"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DelayTimeSpan.NearImmediate">
            <summary>
            50 milliseconds.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DelayTimeSpan.Short">
            <summary>
            250 milliseconds.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DelayTimeSpan.Medium">
            <summary>
            500 milliseconds.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DelayTimeSpan.Idle">
            <summary>
            1.5 seconds.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DelayTimeSpan.IdleWithLongDelay">
            <summary>
            10 seconds.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DelayTimeSpan.NonFocus">
            <summary>
            3 seconds.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TaggedText">
            <summary>
            A piece of text with a descriptive tag.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TaggedText.Tag">
            <summary>
            A descriptive tag from <see cref="T:Microsoft.CodeAnalysis.TextTags"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TaggedText.Text">
            <summary>
            The actual text to be displayed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TaggedText.Style">
            <summary>
            Gets the style(s) to apply to the text.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TaggedText.NavigationTarget">
            <summary>
            Gets the navigation target for the text, or <see langword="null"/> if the text does not have a navigation
            target.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TaggedText.NavigationHint">
            <summary>
            Gets the navigation hint for the text, or <see langword="null"/> if the text does not have a navigation
            hint.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TaggedText.#ctor(System.String,System.String)">
            <summary>
            Creates a new instance of <see cref="T:Microsoft.CodeAnalysis.TaggedText"/>
            </summary>
            <param name="tag">A descriptive tag from <see cref="T:Microsoft.CodeAnalysis.TextTags"/>.</param>
            <param name="text">The actual text to be displayed.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TaggedText.#ctor(System.String,System.String,Microsoft.CodeAnalysis.TaggedTextStyle,System.String,System.String)">
            <summary>
            Creates a new instance of <see cref="T:Microsoft.CodeAnalysis.TaggedText"/>
            </summary>
            <param name="tag">A descriptive tag from <see cref="T:Microsoft.CodeAnalysis.TextTags"/>.</param>
            <param name="text">The actual text to be displayed.</param>
            <param name="style">The style(s) to apply to the text.</param>
            <param name="navigationTarget">The navigation target for the text, or <see langword="null"/> if the text does not have a navigation target.</param>
            <param name="navigationHint">The navigation hint for the text, or <see langword="null"/> if the text does not have a navigation hint.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TextTags">
            <summary>
            The set of well known text tags used for the <see cref="P:Microsoft.CodeAnalysis.TaggedText.Tag"/> property.
            These tags influence the presentation of text.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TextTags.ContainerStart">
            <summary>
            Indicates the start of a text container. The elements after <see cref="F:Microsoft.CodeAnalysis.TextTags.ContainerStart"/> through (but not
            including) the matching <see cref="F:Microsoft.CodeAnalysis.TextTags.ContainerEnd"/> are rendered in a rectangular block which is positioned
            as an inline element relative to surrounding elements. The text of the <see cref="F:Microsoft.CodeAnalysis.TextTags.ContainerStart"/> element
            itself precedes the content of the container, and is typically a bullet or number header for an item in a
            list.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TextTags.ContainerEnd">
            <summary>
            Indicates the end of a text container. See <see cref="F:Microsoft.CodeAnalysis.TextTags.ContainerStart"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TextTags.CodeBlockStart">
            <summary>
            Indicates the start of a code block.  The elements after <see cref="F:Microsoft.CodeAnalysis.TextTags.CodeBlockStart"/>
            through (but not including) the matching <see cref="F:Microsoft.CodeAnalysis.TextTags.CodeBlockEnd"/> are rendered as
            a codeblock in LSP markup.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.ArgumentContext">
            <summary>
            Provides context information for argument completion.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.ArgumentContext.#ctor(Microsoft.CodeAnalysis.Completion.ArgumentProvider,Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.IParameterSymbol,System.String,System.Threading.CancellationToken)">
            <summary>
            Provides context information for argument completion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.ArgumentContext.SemanticModel">
            <summary>
            Gets the semantic model where argument completion is requested.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.ArgumentContext.Position">
            <summary>
            Gets the position within <see cref="P:Microsoft.CodeAnalysis.Completion.ArgumentContext.SemanticModel"/> where argument completion is requested.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.ArgumentContext.Parameter">
            <summary>
            Gets the symbol for the parameter for which an argument value is requested.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.ArgumentContext.PreviousValue">
            <summary>
            Gets the previously-provided argument value for this parameter.
            </summary>
            <value>
            The existing text of the argument value, if the argument is already in code; otherwise,
            <see langword="null"/> when requesting a new argument value.
            </value>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.ArgumentContext.CancellationToken">
            <summary>
            Gets a cancellation token that argument providers may observe.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.ArgumentContext.DefaultValue">
            <summary>
            Gets or sets the default argument value.
            </summary>
            <remarks>
            If this value is not set, the argument completion session will insert a language-specific default value for
            the argument.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.ArgumentProvider.ProvideArgumentAsync(Microsoft.CodeAnalysis.Completion.ArgumentContext)">
            <summary>
            Supports providing argument values for an argument completion session.
            </summary>
            <remarks>
            See <see cref="T:Microsoft.CodeAnalysis.Completion.ArgumentContext"/> for more information about argument values.
            </remarks>
            <param name="context">The argument context.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> representing the asynchronous operation.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.CharacterSetModificationKind">
            <summary>
            The kind of character set modification.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CharacterSetModificationKind.Add">
            <summary>
            The rule adds new characters onto the existing set of characters.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CharacterSetModificationKind.Remove">
            <summary>
            The rule removes characters from the existing set of characters.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CharacterSetModificationKind.Replace">
            <summary>
            The rule replaces the existing set of characters.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule">
            <summary>
            A rule that modifies a set of characters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule.Kind">
            <summary>
            The kind of modification.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule.Characters">
            <summary>
            One or more characters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule.Create(Microsoft.CodeAnalysis.Completion.CharacterSetModificationKind,System.Collections.Immutable.ImmutableArray{System.Char})">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule"/> instance.
            </summary>
            <param name="kind">The kind of rule.</param>
            <param name="characters">One or more characters. These are typically punctuation characters.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule.Create(Microsoft.CodeAnalysis.Completion.CharacterSetModificationKind,System.Char[])">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule"/> instance.
            </summary>
            <param name="kind">The kind of rule.</param>
            <param name="characters">One or more characters. These are typically punctuation characters.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CommonCompletionProvider.Language">
            <summary>
            Language used to retrieve <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionOptions"/> from <see cref="T:Microsoft.CodeAnalysis.Options.OptionSet"/>.
            Null for language agnostic values.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CommonCompletionProvider.ShouldTriggerCompletion(Microsoft.CodeAnalysis.Text.SourceText,System.Int32,Microsoft.CodeAnalysis.Completion.CompletionTrigger,Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
            For backwards API compat only, should not be called.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CommonCompletionProvider.GetDescriptionAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Completion.CompletionItem,System.Threading.CancellationToken)">
            <summary>
            For backwards API compat only, should not be called.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.CompletionChange">
            <summary>
            The change to be applied to the document when a <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> is committed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionChange.TextChange">
            <summary>
            The text change to be applied to the document.  This must always be supplied and is useful for hosts that
            can apply a large text change efficiently while only making minimal edits to a file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionChange.TextChanges">
            <summary>
            Individual smaller text changes that are more fine grained than the total <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionChange.TextChange"/> value.
            This can be useful for host that do not support diffing changes to find minimal edits.  Even if this is 
            provided, <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionChange.TextChange"/> must still be provided as well.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionChange.NewPosition">
            <summary>
            The new caret position after the change has been applied.
            If null then the new caret position will be determined by the completion host.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionChange.NewSelection">
            <summary>
            The new selection after the change has been applied.
            If null then the new caret position will be determined by the completion host.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionChange.IncludesCommitCharacter">
            <summary>
            True if the changes include the typed character that caused the <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/>
            to be committed.  If false the completion host will determine if and where the commit 
            character is inserted into the document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionChange.Create(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextChange},System.Nullable{System.Int32},System.Boolean)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionChange"/> instance.
            </summary>
            <param name="textChanges">The text changes to be applied to the document.</param>
            <param name="newPosition">The new caret position after the change has been applied. If null then the caret
            position is not specified and will be determined by the completion host.</param>
            <param name="includesCommitCharacter">True if the changes include the typed character that caused the <see
            cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> to be committed. If false, the completion host will determine if and where the
            commit character is inserted into the document.</param>
            <remarks>
            This factory method is only valid when <paramref name="textChanges"/> has a single entry in it.  If there
            are multiple entries, <see cref="M:Microsoft.CodeAnalysis.Completion.CompletionChange.Create(Microsoft.CodeAnalysis.Text.TextChange,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextChange},System.Nullable{System.Int32},System.Boolean)"/> must be called instead,
            with both the individual text changes, and an aggregated text change for hosts that only support that.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionChange.WithTextChange(Microsoft.CodeAnalysis.Text.TextChange)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionChange"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionChange.TextChange"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionChange.WithTextChanges(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextChange})">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionChange"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionChange.TextChanges"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionChange.WithNewPosition(System.Nullable{System.Int32})">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionChange"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionChange.NewPosition"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionChange.WithIncludesCommitCharacter(System.Boolean)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionChange"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionChange.IncludesCommitCharacter"/> property changed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.CompletionContext">
            <summary>
            The context presented to a <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionProvider"/> when providing completions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionContext.Document">
            <summary>
            The document that completion was invoked within.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionContext.Position">
            <summary>
            The caret position when completion was triggered.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionContext.SharedSyntaxContextsWithSpeculativeModel">
            <summary>
            By providing this object, we have an opportunity to share requested SyntaxContext among all CompletionProviders
            during a completion session to reduce repeat computation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionContext.DefaultItemSpan">
            <summary>
            The span of the syntax element at the caret position.
            
            This is the most common value used for <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.Span"/> and will
            be automatically assigned to any <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> that has no <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.Span"/> specified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionContext.CompletionListSpan">
            <summary>
            The span of the document the completion list corresponds to.  It will be set initially to
            the result of <see cref="M:Microsoft.CodeAnalysis.Completion.CompletionService.GetDefaultCompletionListSpan(Microsoft.CodeAnalysis.Text.SourceText,System.Int32)"/>, but it can
            be overwritten during <see cref="M:Microsoft.CodeAnalysis.Completion.CompletionService.GetCompletionsAsync(Microsoft.CodeAnalysis.Document,System.Int32,Microsoft.CodeAnalysis.Completion.CompletionTrigger,System.Collections.Immutable.ImmutableHashSet{System.String},Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)"/>.
            The purpose of the span is to:
                1. Signify where the completions should be presented.
                2. Designate any existing text in the document that should be used for filtering.
                3. Specify, by default, what portion of the text should be replaced when a completion 
                   item is committed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionContext.Trigger">
            <summary>
            The triggering action that caused completion to be started.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionContext.CompletionOptions">
            <summary>
            The options that completion was started with.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionContext.CancellationToken">
            <summary>
            The cancellation token to use for this operation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionContext.IsExclusive">
            <summary>
            Set to true if the items added here should be the only items presented to the user.
            Expand items should never be exclusive.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionContext.Options">
            <summary>
            The options that completion was started with.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionContext.#ctor(Microsoft.CodeAnalysis.Completion.CompletionProvider,Microsoft.CodeAnalysis.Document,System.Int32,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Completion.CompletionTrigger,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionContext"/> instance.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionContext.#ctor(Microsoft.CodeAnalysis.Completion.CompletionProvider,Microsoft.CodeAnalysis.Document,System.Int32,Microsoft.CodeAnalysis.Completion.SharedSyntaxContextsWithSpeculativeModel,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Completion.CompletionTrigger,Microsoft.CodeAnalysis.Completion.CompletionOptions@,System.Threading.CancellationToken)">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionContext"/> instance.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionContext.SuggestionModeItem">
            <summary>
            An optional <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> that appears selected in the list presented to the user during suggestion mode.
            
            Suggestion mode disables auto-selection of items in the list, giving preference to the text typed by the user unless a specific item is selected manually.
            
            Specifying a <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionContext.SuggestionModeItem"/> is a request that the completion host operate in suggestion mode.
            The item specified determines the text displayed and the description associated with it unless a different item is manually selected.
            
            No text is ever inserted when this item is completed, leaving the text the user typed instead.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.CompletionDescription">
            <summary>
            The description of a <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionDescription.Empty">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionDescription"/> used when there is no description.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionDescription.TaggedParts">
            <summary>
            The individual tagged parts of the description.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionDescription.Create(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.TaggedText})">
            <summary>
            Creates a new instance of <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionDescription"/> with the specified <see cref="T:Microsoft.CodeAnalysis.TaggedText"/> parts.
            </summary>
            <param name="taggedParts">The individual tagged parts of the description.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionDescription.FromText(System.String)">
            <summary>
            Creates a new instance of <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionDescription"/> from untagged text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionDescription.WithTaggedParts(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.TaggedText})">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionDescription"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionDescription.TaggedParts"/> property changed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionDescription.Text">
            <summary>
            The text of the description without tags.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionHelper.ComparePreselection(Microsoft.CodeAnalysis.Completion.CompletionItem,Microsoft.CodeAnalysis.Completion.CompletionItem)">
            <summary>
             If 2 items differ on preselection, then item1 is better if it is preselected, otherwise it is worse.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionHelper.CompareDeprioritization(Microsoft.CodeAnalysis.Completion.CompletionItem,Microsoft.CodeAnalysis.Completion.CompletionItem)">
            <summary>
            If 2 items differ on depriorization, then item1 is worse if it is depriozritized, otherwise it is better.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.CompletionItem">
            <summary>
            One of many possible completions used to form the completion list presented to the user.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItem.DisplayText">
            <summary>
            The text that is displayed to the user.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItem.DisplayTextPrefix">
            <summary>
            An optional prefix to be displayed prepended to <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.DisplayText"/>. Can be null.
            Pattern-matching of user input will not be performed against this, but only against <see
            cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.DisplayText"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItem.DisplayTextSuffix">
            <summary>
            An optional suffix to be displayed appended to <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.DisplayText"/>. Can be null.
            Pattern-matching of user input will not be performed against this, but only against <see
            cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.DisplayText"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItem.FilterText">
            <summary>
            The text used to determine if the item matches the filter and is show in the list.
            This is often the same as <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.DisplayText"/> but may be different in certain circumstances.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItem.AdditionalFilterTexts">
            <summary>
            If provided, each additional string would be used in the same way as <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.FilterText"/> for item matching.
            However, there's a key difference: matches of <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.AdditionalFilterTexts"/> is considered inferior than matches
            of <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.FilterText"/> when they have identical pattern matching result.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItem.HasDifferentFilterText">
            <summary>
            Returns <see langword="true"/> if <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.DisplayText"/> is identical to  <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.FilterText"/>. 
            Otherwise returns <see langword="false"/>.
            Be aware that this value is independent from <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.HasAdditionalFilterTexts"/> and could return <see langword="false"/> 
            even if <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.HasAdditionalFilterTexts"/> is <see langword="true"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItem.SortText">
            <summary>
            The text used to determine the order that the item appears in the list.
            This is often the same as the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.DisplayText"/> but may be different in certain circumstances.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItem.InlineDescription">
            <summary>
            Descriptive text to place after <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.DisplayText"/> in the display layer.  Should
            be short as it will show up in the UI.  Display will present this in a way to distinguish
            this from the normal text (for example, by fading out and right-aligning).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItem.Span">
            <summary>
            The span of the syntax element associated with this item.
            
            The span identifies the text in the document that is used to filter the initial list presented to the user,
            and typically represents the region of the document that will be changed if this item is committed.
            The latter is not always true because individual provider is free to make more complex changes to the document.
            If this is the case, the provider should set <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.IsComplexTextEdit"/> to true.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItem.Properties">
            <summary>
            Additional information attached to a completion item by it creator.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItem.Tags">
            <summary>
            Descriptive tags from <see cref="T:Microsoft.CodeAnalysis.Tags.WellKnownTags"/>.
            These tags may influence how the item is displayed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItem.Rules">
            <summary>
            Rules that declare how this item should behave.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItem.IsComplexTextEdit">
            <summary>
            Returns true if this item's text edit requires complex resolution.
            An edit is considered complex if the span of the change is different from
            specified by <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.Span"/>.
            
            Example of an item type requiring complex resolution is C#/VB override completion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItem.ProviderName">
            <summary>
            The name of the <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionProvider"/> that created this 
            <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/>. Not available to clients. Only used by 
            the Completion subsystem itself for things like getting description text
            and making additional change during commit.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItem.AutomationText">
            <summary>
            The automation text to use when narrating the completion item. If set to
            null, narration will use the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.DisplayText"/> instead.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItem.Create(System.String,System.String,System.String,Microsoft.CodeAnalysis.Text.TextSpan,System.Collections.Immutable.ImmutableDictionary{System.String,System.String},System.Collections.Immutable.ImmutableArray{System.String},Microsoft.CodeAnalysis.Completion.CompletionItemRules)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/>
            </summary>
            <param name="displayText">The text that is displayed to the user.</param>
            <param name="filterText">The text used to determine if the item matches the filter and is show in the list.</param>
            <param name="sortText">The text used to determine the order that the item appears in the list.</param>
            <param name="span">The span of the syntax element in the document associated with this item.</param>
            <param name="properties">Additional information.</param>
            <param name="tags">Descriptive tags that may influence how the item is displayed.</param>
            <param name="rules">The rules that declare how this item should behave.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItem.WithSpan(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.Span"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItem.WithDisplayText(System.String)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.DisplayText"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItem.WithDisplayTextPrefix(System.String)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.DisplayTextPrefix"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItem.WithDisplayTextSuffix(System.String)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.DisplayTextSuffix"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItem.WithFilterText(System.String)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.FilterText"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItem.WithSortText(System.String)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.SortText"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItem.WithProperties(System.Collections.Immutable.ImmutableDictionary{System.String,System.String})">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> with the specified property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItem.AddProperty(System.String,System.String)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> with the specified property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItem.WithTags(System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.Tags"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItem.AddTag(System.String)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> with a tag added to the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.Tags"/> collection.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItem.WithRules(Microsoft.CodeAnalysis.Completion.CompletionItemRules)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.Rules"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItem.WithIsComplexTextEdit(System.Boolean)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.IsComplexTextEdit"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItem.WithAdditionalFilterTexts(System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.AdditionalFilterTexts"/> property changed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionItemFlags.Cached">
             <summary>
             Indicates this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> is cached and reused across completion sessions. 
             This might be used by completion system for things like deciding whether it can safely cache and reuse
             other data corresponding to this item.
            
             TODO: Revisit the approach we used for caching VS items.
                   https://github.com/dotnet/roslyn/issues/35160
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionItemFlags.Expanded">
            <summary>
            Indicates this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> should be shown only when expanded items is requested.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionItemSelectionBehavior.SoftSelection">
            <summary>
            If no text has been typed, the item should be soft selected. This is appropriate for 
            completion providers that want to provide suggestions that shouldn't interfere with 
            typing.  For example a provider that comes up on space might offer items that are soft
            selected so that an additional space (or other puntuation character) will not then 
            commit that item.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionItemSelectionBehavior.HardSelection">
            <summary>
            If no text has been typed, the item should be hard selected.  This is appropriate for
            completion providers that are providing suggestions the user is nearly certain to 
            select.  Because the item is hard selected, any commit characters typed after it will
            cause it to be committed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.CompletionItemRules">
            <summary>
            Rules for how the individual items are handled.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionItemRules.Default">
            <summary>
            The rule used when no rule is specified when constructing a <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItemRules.FilterCharacterRules">
            <summary>
            Rules that modify the set of characters that can be typed to filter the list of completion items.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItemRules.CommitCharacterRules">
            <summary>
            Rules that modify the set of characters that can be typed to cause the selected item to be committed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItemRules.EnterKeyRule">
            <summary>
            A rule about whether the enter key is passed through to the editor after the selected item has been committed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItemRules.FormatOnCommit">
            <summary>
            True if the modified text should be formatted automatically.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItemRules.MatchPriority">
            <summary>
            True if the related completion item should be initially selected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionItemRules.SelectionBehavior">
            <summary>
            How this item should be selected when the completion list first appears and
            before the user has typed any characters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItemRules.Create(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule},Microsoft.CodeAnalysis.Completion.EnterKeyRule,System.Boolean,System.Nullable{System.Int32})">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItemRules"/> instance.
            </summary>
            <param name="filterCharacterRules">Rules about which keys typed are used to filter the list of completion items.</param>
            <param name="commitCharacterRules">Rules about which keys typed caused the completion item to be committed.</param>
            <param name="enterKeyRule">Rule about whether the enter key is passed through to the editor after the selected item has been committed.</param>
            <param name="formatOnCommit">True if the modified text should be formatted automatically.</param>
            <param name="matchPriority">True if the related completion item should be initially selected.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItemRules.Create(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule},Microsoft.CodeAnalysis.Completion.EnterKeyRule,System.Boolean,System.Nullable{System.Int32},Microsoft.CodeAnalysis.Completion.CompletionItemSelectionBehavior)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItemRules"/> instance.
            </summary>
            <param name="filterCharacterRules">Rules about which keys typed are used to filter the list of completion items.</param>
            <param name="commitCharacterRules">Rules about which keys typed caused the completion item to be committed.</param>
            <param name="enterKeyRule">Rule about whether the enter key is passed through to the editor after the selected item has been committed.</param>
            <param name="formatOnCommit">True if the modified text should be formatted automatically.</param>
            <param name="matchPriority">True if the related completion item should be initially selected.</param>
            <param name="selectionBehavior">How this item should be selected if no text has been typed after the completion list is brought up.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItemRules.Create(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule},Microsoft.CodeAnalysis.Completion.EnterKeyRule,System.Boolean,System.Boolean)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItemRules"/> instance--internal for TypeScript.
            </summary>
            <param name="filterCharacterRules">Rules about which keys typed are used to filter the list of completion items.</param>
            <param name="commitCharacterRules">Rules about which keys typed caused the completion item to be committed.</param>
            <param name="enterKeyRule">Rule about whether the enter key is passed through to the editor after the selected item has been committed.</param>
            <param name="formatOnCommit">True if the modified text should be formatted automatically.</param>
            <param name="preselect">True if the related completion item should be initially selected.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItemRules.WithFilterCharacterRules(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule})">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItemRules"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItemRules.FilterCharacterRules"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItemRules.WithCommitCharacterRules(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule})">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItemRules"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItemRules.CommitCharacterRules"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItemRules.WithEnterKeyRule(Microsoft.CodeAnalysis.Completion.EnterKeyRule)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItemRules"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItemRules.EnterKeyRule"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItemRules.WithFormatOnCommit(System.Boolean)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItemRules"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItemRules.FormatOnCommit"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItemRules.WithMatchPriority(System.Int32)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItemRules"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItemRules.MatchPriority"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionItemRules.WithSelectionBehavior(Microsoft.CodeAnalysis.Completion.CompletionItemSelectionBehavior)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItemRules"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItemRules.SelectionBehavior"/> property changed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.CompletionList">
            <summary>
            The set of completions to present to the user.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionList.Items">
            <summary>
            The completion items to present to the user.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionList.ItemsList">
            <summary>
            The completion items to present to the user.
            This property is preferred over `Items` because of the flexibility it provides. 
            For example, the list can be backed by types like SegmentedList to avoid LOH allocations.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionList.DefaultSpan">
            <summary>
            The span of the syntax element at the caret position when the <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionList"/> was created.
            Individual <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> spans may vary.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionList.Span">
            <summary>
            The span of the syntax element at the caret position when the <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionList"/> 
            was created.
            
            The span identifies the text in the document that is used to filter the initial list 
            presented to the user, and typically represents the region of the document that will 
            be changed if this item is committed.
            The latter is not always the case because each provider is free to make more complex changes 
            to the document. If this is the case, <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.IsComplexTextEdit"/> must be
            set to <see langword="true"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionList.Rules">
            <summary>
            The rules used to control behavior of the completion list shown to the user during typing.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionList.SuggestionModeItem">
            <summary>
            An optional <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> that appears selected in the list presented to the user during suggestion mode.
            Suggestion mode disables auto-selection of items in the list, giving preference to the text typed by the user unless a specific item is selected manually.
            Specifying a <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionList.SuggestionModeItem"/> is a request that the completion host operate in suggestion mode.
            The item specified determines the text displayed and the description associated with it unless a different item is manually selected.
            No text is ever inserted when this item is completed, leaving the text the user typed instead.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionList.IsExclusive">
            <summary>
            Whether the items in this list should be the only items presented to the user.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionList.Create(Microsoft.CodeAnalysis.Text.TextSpan,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Completion.CompletionItem},Microsoft.CodeAnalysis.Completion.CompletionRules,Microsoft.CodeAnalysis.Completion.CompletionItem)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionList"/> instance.
            </summary>
            <param name="defaultSpan">The span of the syntax element at the caret position when the <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionList"/> was created.</param>
            <param name="items">The completion items to present to the user.</param>
            <param name="rules">The rules used to control behavior of the completion list shown to the user during typing.</param>
            <param name="suggestionModeItem">An optional <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/> that appears selected in the list presented to the user during suggestion mode.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionList.WithDefaultSpan(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionList"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionList.DefaultSpan"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionList.WithItems(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Completion.CompletionItem})">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionList"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionList.Items"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionList.WithItemsList(System.Collections.Generic.IReadOnlyList{Microsoft.CodeAnalysis.Completion.CompletionItem})">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionList"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionList.ItemsList"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionList.WithRules(Microsoft.CodeAnalysis.Completion.CompletionRules)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionList"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionList.Rules"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionList.WithSuggestionModeItem(Microsoft.CodeAnalysis.Completion.CompletionItem)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionList"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionList.SuggestionModeItem"/> property changed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionList.Empty">
            <summary>
            The default <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionList"/> returned when no items are found to populate the list.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionOptions.ForceExpandedCompletionIndexCreation">
            <summary>
            Force completion APIs to produce complete results, even in cases where caches have not been pre-populated.
            This is typically used for testing scenarios, and by public APIs where consumers do not have access to
            other internal APIs used to control cache creation and/or wait for caches to be populated before examining
            completion results.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionOptions.UpdateImportCompletionCacheInBackground">
            <summary>
            Set to true to update import completion cache in background if the provider isn't supposed to be triggered in the context.
            (cache will always be refreshed when provider is triggered)
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionOptions.CanAddImportStatement">
            <summary>
            Whether completion can add import statement as part of committed change.
            For example, adding import is not allowed in debugger view.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionOptions.ShouldShowItemsFromUnimportedNamespaces">
            <summary>
            Whether items from unimported namespaces should be included in the completion list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionOptions.ShouldShowNewSnippetExperience(Microsoft.CodeAnalysis.Document)">
            <summary>
            Whether items from new snippet experience should be included in the completion list.
            This takes into consideration the experiment we are running in addition to the value
            from user facing options.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.CompletionProvider">
            <summary>
            Implement a subtype of this class and export it to provide completions during typing in an editor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionProvider.ProvideCompletionsAsync(Microsoft.CodeAnalysis.Completion.CompletionContext)">
            <summary>
            Implement to contribute <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/>'s and other details to a <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionList"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionProvider.ShouldTriggerCompletion(Microsoft.CodeAnalysis.Text.SourceText,System.Int32,Microsoft.CodeAnalysis.Completion.CompletionTrigger,Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
            Returns true if the character recently inserted or deleted in the text should trigger completion.
            </summary>
            <param name="text">The text that completion is occurring within.</param>
            <param name="caretPosition">The position of the caret after the triggering action.</param>
            <param name="trigger">The triggering action.</param>
            <param name="options">The set of options in effect.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionProvider.ShouldTriggerCompletion(Microsoft.CodeAnalysis.Host.LanguageServices,Microsoft.CodeAnalysis.Text.SourceText,System.Int32,Microsoft.CodeAnalysis.Completion.CompletionTrigger,Microsoft.CodeAnalysis.Completion.CompletionOptions,Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
            Returns true if the character recently inserted or deleted in the text should trigger completion.
            </summary>
            <param name="languageServices">The language services available on the text document.</param>
            <param name="text">The text that completion is occurring within.</param>
            <param name="caretPosition">The position of the caret after the triggering action.</param>
            <param name="trigger">The triggering action.</param>
            <param name="options">The set of options in effect.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionProvider.IsSyntacticTriggerCharacterAsync(Microsoft.CodeAnalysis.Document,System.Int32,Microsoft.CodeAnalysis.Completion.CompletionTrigger,Microsoft.CodeAnalysis.Completion.CompletionOptions,System.Threading.CancellationToken)">
            <summary>
            This allows Completion Providers that indicated they were triggered textually to use syntax to
            confirm they are really triggered, or decide they are not actually triggered and should become 
            an augmenting provider instead.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionProvider.GetDescriptionAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Completion.CompletionItem,System.Threading.CancellationToken)">
            <summary>
            Gets the description of the specified item.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionProvider.GetChangeAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Completion.CompletionItem,System.Nullable{System.Char},System.Threading.CancellationToken)">
            <summary>
            Gets the change to be applied when the specified item is committed.
            </summary>
            <param name="document">The current document.</param>
            <param name="item">The item to be committed.</param>
            <param name="commitKey">The optional key character that caused the commit.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionProvider.IsSnippetProvider">
            <summary>
            True if the provider produces snippet items.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionProvider.IsExpandItemProvider">
            <summary>
            True if the provider produces items show be shown in expanded list only.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.Providers.AbstractAggregateEmbeddedLanguageCompletionProvider">
            <summary>
            The singular completion provider that will hook into completion and will
            provide all completions across all embedded languages.
            
            Completions for an individual language are provided by
            <see cref="P:Microsoft.CodeAnalysis.EmbeddedLanguages.IEmbeddedLanguage.CompletionProvider"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.Providers.AbstractAwaitCompletionProvider">
            <summary>
            A completion provider for offering <see langword="await"/> keyword.
            This is implemented separately, not as a keyword recommender as it contains extra logic for making container method async.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.Providers.AbstractAwaitCompletionProvider.AddAwaitAtCurrentPosition">
            <summary>
            If 'await' should be placed at the current position.  If not present, it means to add 'await' prior 
            to the preceding expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.Providers.AbstractAwaitCompletionProvider.GetDotAwaitKeywordContext(Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.SyntaxContext,System.Threading.CancellationToken)">
            <summary>
            Should <see langword="await"/> be offered, if left of the dot at position is an awaitable expression?
            <code>
              someTask.$$ // Suggest await completion
              await someTask.$$ // Don't suggest await completion
            </code>
            </summary>
            <returns>
                <see cref="F:Microsoft.CodeAnalysis.Completion.Providers.AbstractAwaitCompletionProvider.DotAwaitContext.None"/>, if await can not be suggested for the expression left of the dot.
                <see cref="F:Microsoft.CodeAnalysis.Completion.Providers.AbstractAwaitCompletionProvider.DotAwaitContext.AwaitOnly"/>, if await should be suggested for the expression left of the dot, but ConfigureAwait(false) not.
                <see cref="F:Microsoft.CodeAnalysis.Completion.Providers.AbstractAwaitCompletionProvider.DotAwaitContext.AwaitAndConfigureAwait"/>, if await should be suggested for the expression left of the dot and ConfigureAwait(false).
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.Providers.AbstractDocCommentCompletionProvider`1.GetParameters(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            A temporarily hack that should be removed once/if https://github.com/dotnet/roslyn/issues/53092 is fixed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.Providers.AbstractObjectCreationCompletionProvider`1.GetObjectCreationNewExpression(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Return null if not in object creation type context.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.Providers.AbstractSymbolCompletionProvider`1.ShouldIncludeInTargetTypedCompletionList(Microsoft.CodeAnalysis.ISymbol,`0,System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean})">
            <param name="typeConvertibilityCache">A cache to use for repeated lookups. This should be created with <see cref="F:Microsoft.CodeAnalysis.SymbolEqualityComparer.Default"/>
            because we ignore nullability.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.Providers.AbstractSymbolCompletionProvider`1.CreateItems(Microsoft.CodeAnalysis.Completion.CompletionContext,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Completion.Providers.AbstractSymbolCompletionProvider{`0}.SymbolAndSelectionInfo},System.Func{Microsoft.CodeAnalysis.Completion.Providers.AbstractSymbolCompletionProvider{`0}.SymbolAndSelectionInfo,`0},System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.ProjectId}},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ProjectId})">
            <summary>
            Given a list of symbols, and a mapping from each symbol to its original SemanticModel, 
            creates the list of completion items for them.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.Providers.AbstractSymbolCompletionProvider`1.SymbolReferenceEquivalenceComparer">
            <summary>
            Alternative comparer to SymbolAndSelectionInfo's default which considers both the full symbol and preselect.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.Providers.AbstractSymbolCompletionProvider`1.TryGetSymbolsForContextAsync(Microsoft.CodeAnalysis.Completion.CompletionContext,`0,Microsoft.CodeAnalysis.Completion.CompletionOptions,System.Threading.CancellationToken)">
            <summary>
            If current context is in active region, returns available symbols. Otherwise, returns null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.Providers.AbstractSymbolCompletionProvider`1.FindSymbolsMissingInLinkedContexts(System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.Completion.Providers.AbstractSymbolCompletionProvider{`0}.SymbolAndSelectionInfo,`0},System.Collections.Immutable.ImmutableArray{System.ValueTuple{Microsoft.CodeAnalysis.DocumentId,`0,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Completion.Providers.AbstractSymbolCompletionProvider{`0}.SymbolAndSelectionInfo}}})">
            <summary>
            Given a list of symbols, determine which are not recommended at the same position in linked documents.
            </summary>
            <param name="symbolToContext">The symbols recommended in the active context.</param>
            <param name="linkedContextSymbolLists">The symbols recommended in linked documents</param>
            <returns>The list of projects each recommended symbol did NOT appear in.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.Providers.AbstractSymbolCompletionProvider`1.GetInsertionText(Microsoft.CodeAnalysis.Completion.CompletionItem,System.Char)">
            <summary>
            Override this if you want to provide customized insertion based on the character typed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.Providers.AbstractTypeImportCompletionProvider`1.GetAliasTypeDictionary(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.SyntaxContext,System.Threading.CancellationToken)">
            <summary>
            Get a multi-Dictionary stores the information about the target of all alias Symbol in the syntax tree.
            Multiple aliases might live under same namespace.
            Key is the namespace of the symbol, value is the name of the symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.Providers.AbstractTypeImportCompletionService.GetUpToDateCacheForProjectAsync(Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)">
            <summary>
            Get appropriate completion items for all the visible top level types from given project. 
            This method is intended to be used for getting types from source only, so the project must support compilation. 
            For getting types from PE, use <see cref="M:Microsoft.CodeAnalysis.Completion.Providers.AbstractTypeImportCompletionService.TryGetUpToDateCacheForPEReference(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Shared.Utilities.EditorBrowsableHelpers.EditorBrowsableInfo,Microsoft.CodeAnalysis.PortableExecutableReference,System.Threading.CancellationToken,Microsoft.CodeAnalysis.Completion.Providers.TypeImportCompletionCacheEntry@)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.Providers.AbstractTypeImportCompletionService.TryGetUpToDateCacheForPEReference(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Shared.Utilities.EditorBrowsableHelpers.EditorBrowsableInfo,Microsoft.CodeAnalysis.PortableExecutableReference,System.Threading.CancellationToken,Microsoft.CodeAnalysis.Completion.Providers.TypeImportCompletionCacheEntry@)">
            <summary>
            Get appropriate completion items for all the visible top level types from given PE reference.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.Providers.DefaultExtensionMethodImportCompletionCacheServiceFactory">
            <summary>
            We don't use PE cache from the service, so just pass in type `object` for PE entries.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.Providers.DefaultExtensionMethodImportCompletionCacheServiceFactory.#ctor(Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListenerProvider)">
            <summary>
            We don't use PE cache from the service, so just pass in type `object` for PE entries.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.Providers.ExtensionMethodImportCompletionCacheEntry.ReceiverTypeNameToExtensionMethodMap">
            <summary>
            Mapping from the name of receiver type to extension method symbol infos.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.Providers.ExtensionMethodImportCompletionHelper">
            <summary>
            Provides completion items for extension methods from unimported namespace.
            </summary>
            <remarks>It runs out-of-proc if it's enabled</remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.Providers.ExtensionMethodImportCompletionHelper.s_projectItemsCache">
            <summary>
            Technically never gets cleared out.  However, as we're only really storing information about extension
            methods in a project, this should not be too bad.  It's only really a leak if the project is truly 
            unloaded, and not too bad in that case.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.Providers.ExtensionMethodImportCompletionHelper.SymbolComputer._originatingSemanticModel">
            <summary>
            The semantic model provided for <see cref="F:Microsoft.CodeAnalysis.Completion.Providers.ExtensionMethodImportCompletionHelper.SymbolComputer._originatingDocument"/>. This may be a speculative semantic
            model with limited validity based on the context surrounding <see cref="F:Microsoft.CodeAnalysis.Completion.Providers.ExtensionMethodImportCompletionHelper.SymbolComputer._position"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.Providers.ExtensionMethodImportCompletionHelper.SymbolComputer.QueueCacheWarmUpTask(Microsoft.CodeAnalysis.Project)">
            <summary>
            Force create/update all relevant indices
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.Providers.ExtensionMethodImportCompletionHelper.SymbolComputer.CreateAggregatedFilter(Microsoft.CodeAnalysis.Completion.Providers.ExtensionMethodImportCompletionCacheEntry)">
            <summary>
            Create a filter for extension methods from source.
            The filter is a map from fully qualified type name to info of extension methods it contains.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.Providers.ExtensionMethodImportCompletionHelper.SymbolComputer.CreateAggregatedFilter(Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo)">
            <summary>
            Create filter for extension methods from metadata
            The filter is a map from fully qualified type name to info of extension methods it contains.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.Providers.ExtensionMethodImportCompletionHelper.SymbolComputer.GetReceiverTypeNames(Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Get the metadata name of all the base types and interfaces this type derived from.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.Providers.ExtensionMethodImportCompletionHelper.SymbolComputer.AddComplexTypes(System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
            Add strings represent complex types (i.e. "" for non-array types and "[]" for array types) to the receiver type, 
            so we would include in the filter info about extension methods with complex receiver type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.Providers.ImportCompletionProviderHelpers.GetAddImportTextChangesAsync(Microsoft.CodeAnalysis.Document,System.Int32,System.String,System.Threading.CancellationToken)">
            <summary>
            Gets the changes needed to add a particular import for <paramref name="namespaceName"/> to the supplied document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.Providers.ITypeImportCompletionService.GetAllTopLevelTypesAsync(Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.SyntaxContext,System.Boolean,Microsoft.CodeAnalysis.Completion.CompletionOptions,System.Threading.CancellationToken)">
            <summary>
            Get completion items for all the accessible top level types from the given project and all its references. 
            Each array returned contains all items from one of the reachable entities (i.e. projects and PE references.)
            Returns null if we don't have all the items cached and <paramref name="forceCacheCreation"/> is false.
            </summary>
            <remarks>
            Because items from each entity are cached as a separate array, we simply return them as is instead of an 
            aggregated array to avoid unnecessary allocations.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.Providers.TypeImportCompletionCacheEntry.PublicItemCount">
            <summary>
            The number of items in this entry for types declared as public.
            This is used to minimize memory allocation in case non-public items aren't needed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.Providers.TypeImportCompletionCacheEntry.HasEnumBaseTypes">
            <summary>
            Only 1 entry (which corresponds to `System` namespace) can have items,
            suitable for enum's base list. This flag allows to fast-skip other entries
            without need to enumerate their items
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.Providers.AbstractDirectivePathCompletionProvider.DirectiveName">
            <summary>
            <code>r</code> for metadata reference directive, <code>load</code> for source file directive.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.Providers.AbstractDirectivePathCompletionProvider.AfterLastSlashIndex(System.String,System.Int32)">
            <summary>
            Returns the index right after the last slash that precedes 'position'.  If there is no
            slash in the string, -1 is returned.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.Providers.SmallNumberFormatter.s_smallNumberCache">
            <summary>
            Lazily-populated cache of strings for values in the range [0, <see cref="T:Microsoft.CodeAnalysis.Completion.Providers.SmallNumberFormatter"/>).
            Inspired by corresponding field in core runtime's Number class. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.Providers.Snippets.AbstractSnippetCompletionProvider.GetDocumentWithoutInvokingTextAsync(Microsoft.CodeAnalysis.Document,System.Int32,System.Threading.CancellationToken)">
            Gets the document without whatever text was used to invoke the completion.
            Also gets the new position the cursor will be on.
            Returns the original document and position if completion was invoked using Ctrl-Space.
            
            public void Method()
            {
                $$               //invoked by typing Ctrl-Space
            }
            Example invoking when span is not empty:
            public void Method()
            {
                Wr$$             //invoked by typing out the completion 
            }
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.CompletionRules">
            <summary>
            Presentation and behavior rules for completion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionRules.DismissIfEmpty">
            <summary>
            True if the completion list should be dismissed if the user's typing causes it to filter
            and display no items.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionRules.DismissIfLastCharacterDeleted">
            <summary>
            True if the list should be dismissed when the user deletes the last character in the span.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionRules.DefaultCommitCharacters">
            <summary>
            The default set of typed characters that cause the selected item to be committed.
            Individual <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/>s can override this.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionRules.DefaultEnterKeyRule">
            <summary>
            The default rule that determines if the enter key is passed through to the editor after the selected item has been committed.
            Individual <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionItem"/>s can override this.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionRules.SnippetsRule">
            <summary>
            The rule determining how snippets work.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionRules.Create(System.Boolean,System.Boolean,System.Collections.Immutable.ImmutableArray{System.Char},Microsoft.CodeAnalysis.Completion.EnterKeyRule)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionRules"/> instance.
            </summary>
            <param name="dismissIfEmpty">True if the completion list should be dismissed if the user's typing causes it to filter and display no items.</param>
            <param name="dismissIfLastCharacterDeleted">True if the list should be dismissed when the user deletes the last character in the span.</param>
            <param name="defaultCommitCharacters">The default set of typed characters that cause the selected item to be committed.</param>
            <param name="defaultEnterKeyRule">The default rule that determines if the enter key is passed through to the editor after the selected item has been committed.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionRules.Create(System.Boolean,System.Boolean,System.Collections.Immutable.ImmutableArray{System.Char},Microsoft.CodeAnalysis.Completion.EnterKeyRule,Microsoft.CodeAnalysis.Completion.SnippetsRule)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionRules"/> instance.
            </summary>
            <param name="dismissIfEmpty">True if the completion list should be dismissed if the user's typing causes it to filter and display no items.</param>
            <param name="dismissIfLastCharacterDeleted">True if the list should be dismissed when the user deletes the last character in the span.</param>
            <param name="defaultCommitCharacters">The default set of typed characters that cause the selected item to be committed.</param>
            <param name="defaultEnterKeyRule">The default rule that determines if the enter key is passed through to the editor after the selected item has been committed.</param>
            <param name="snippetsRule">The rule that controls snippets behavior.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionRules.WithDismissIfEmpty(System.Boolean)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionRules"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionRules.DismissIfEmpty"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionRules.WithDismissIfLastCharacterDeleted(System.Boolean)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionRules"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionRules.DismissIfLastCharacterDeleted"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionRules.WithDefaultCommitCharacters(System.Collections.Immutable.ImmutableArray{System.Char})">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionRules"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionRules.DefaultCommitCharacters"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionRules.WithDefaultEnterKeyRule(Microsoft.CodeAnalysis.Completion.EnterKeyRule)">
            <summary>
            Creates a copy of this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionRules"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionRules.DefaultEnterKeyRule"/> property changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionRules.WithSnippetsRule(Microsoft.CodeAnalysis.Completion.SnippetsRule)">
            <summary>
            Creates a copy of the this <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionRules"/> with the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionRules.SnippetsRule"/> property changed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionRules.Default">
            <summary>
            The default <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionRules"/> if none is otherwise specified.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.CompletionService">
            <summary>
            A per language service for constructing context dependent list of completions that 
            can be presented to a user during typing in an editor. It aggregates completions from
            one or more <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionProvider"/>s.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionService._suppressPartialSemantics">
            <summary>
            Test-only switch.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionService.GetService(Microsoft.CodeAnalysis.Document)">
            <summary>
            Gets the service corresponding to the specified document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionService.GetBuiltInProviders">
            <summary>
            Returns the providers always available to the service.
            This does not included providers imported via MEF composition.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionService.Language">
            <summary>
            The language from <see cref="T:Microsoft.CodeAnalysis.LanguageNames"/> this service corresponds to.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionService.GetRules">
            <summary>
            Gets the current presentation and behavior rules.
            </summary>
            <remarks>
            Backward compatibility only.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionService.ShouldTriggerCompletion(Microsoft.CodeAnalysis.Text.SourceText,System.Int32,Microsoft.CodeAnalysis.Completion.CompletionTrigger,System.Collections.Immutable.ImmutableHashSet{System.String},Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
            Returns true if the character recently inserted or deleted in the text should trigger completion.
            </summary>
            <param name="text">The document text to trigger completion within </param>
            <param name="caretPosition">The position of the caret after the triggering action.</param>
            <param name="trigger">The potential triggering action.</param>
            <param name="roles">Optional set of roles associated with the editor state.</param>
            <param name="options">Optional options that override the default options.</param>
            <remarks>
            This API uses SourceText instead of Document so implementations can only be based on text, not syntax or semantics.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionService.ShouldTriggerCompletion(Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.Host.LanguageServices,Microsoft.CodeAnalysis.Text.SourceText,System.Int32,Microsoft.CodeAnalysis.Completion.CompletionTrigger,Microsoft.CodeAnalysis.Completion.CompletionOptions,Microsoft.CodeAnalysis.Options.OptionSet,System.Collections.Immutable.ImmutableHashSet{System.String})">
            <summary>
            Returns true if the character recently inserted or deleted in the text should trigger completion.
            </summary>
            <param name="project">The project containing the document and text</param>
            <param name="languageServices">Language services</param>
            <param name="text">The document text to trigger completion within </param>
            <param name="caretPosition">The position of the caret after the triggering action.</param>
            <param name="trigger">The potential triggering action.</param>
            <param name="options">Options.</param>
            <param name="passThroughOptions">Options originating either from external caller of the <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionService"/> or set externally to <see cref="P:Microsoft.CodeAnalysis.Solution.Options"/>.</param>
            <param name="roles">Optional set of roles associated with the editor state.</param>
            <remarks>
            We pass the project here to retrieve information about the <see cref="P:Microsoft.CodeAnalysis.Project.AnalyzerReferences"/>,
            <see cref="T:Microsoft.CodeAnalysis.WorkspaceKind"/> and <see cref="P:Microsoft.CodeAnalysis.Project.Language"/> which are fast operations.
            It should not be used for syntactic or semantic operations.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionService.GetDefaultItemSpan(Microsoft.CodeAnalysis.Text.SourceText,System.Int32)">
            <summary>
            Gets the span of the syntax element at the caret position.
            This is the most common value used for <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.Span"/>.
            </summary>
            <param name="text">The document text that completion is occurring within.</param>
            <param name="caretPosition">The position of the caret within the text.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionService.GetDescriptionAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Completion.CompletionItem,System.Threading.CancellationToken)">
            <summary>
            Gets the description of the item.
            </summary>
            <param name="document">This will be the  original document that
            <paramref name="item"/> was created against.</param>
            <param name="item">The item to get the description for.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionService.GetDescriptionAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Completion.CompletionItem,Microsoft.CodeAnalysis.Completion.CompletionOptions,Microsoft.CodeAnalysis.LanguageService.SymbolDescriptionOptions,System.Threading.CancellationToken)">
            <summary>
            Gets the description of the item.
            </summary>
            <param name="document">This will be the  original document that
            <paramref name="item"/> was created against.</param>
            <param name="item">The item to get the description for.</param>
            <param name="options">Completion options</param>
            <param name="displayOptions">Display options</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionService.GetChangeAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Completion.CompletionItem,System.Nullable{System.Char},System.Threading.CancellationToken)">
            <summary>
            Gets the change to be applied when the item is committed.
            </summary>
            <param name="document">The document that completion is occurring within.</param>
            <param name="item">The item to get the change for.</param>
            <param name="commitCharacter">The typed character that caused the item to be committed. 
            This character may be used as part of the change. 
            This value is null when the commit was caused by the [TAB] or [ENTER] keys.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionService.FilterItems(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Completion.CompletionItem},System.String)">
            <summary>
            Given a list of completion items that match the current code typed by the user,
            returns the item that is considered the best match, and whether or not that
            item should be selected or not.
            
            itemToFilterText provides the values that each individual completion item should
            be filtered against.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionService.FilterItems(Microsoft.CodeAnalysis.Completion.CompletionHelper,System.Collections.Generic.IReadOnlyList{Microsoft.CodeAnalysis.Completion.MatchResult},System.String,System.Collections.Generic.IList{Microsoft.CodeAnalysis.Completion.MatchResult})">
            <summary>
            Determine among the provided items the best match w.r.t. the given filter text, 
            those returned would be considered equally good candidates for selection by controller.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionService.LoadImportedProviders">
            <summary>
            Don't call. Used for pre-populating MEF providers only.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionService.TriggerLoadProjectProviders(Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.Completion.CompletionOptions)">
            <summary>
            Don't call. Used for pre-load project providers only.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionService.GetCompletionsAsync(Microsoft.CodeAnalysis.Document,System.Int32,Microsoft.CodeAnalysis.Completion.CompletionTrigger,System.Collections.Immutable.ImmutableHashSet{System.String},Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Gets the completions available at the caret position.
            </summary>
            <param name="document">The document that completion is occurring within.</param>
            <param name="caretPosition">The position of the caret after the triggering action.</param>
            <param name="trigger">The triggering action.</param>
            <param name="roles">Optional set of roles associated with the editor state.</param>
            <param name="options">Optional options that override the default options.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionService.GetCompletionsAsync(Microsoft.CodeAnalysis.Document,System.Int32,Microsoft.CodeAnalysis.Completion.CompletionOptions,Microsoft.CodeAnalysis.Options.OptionSet,Microsoft.CodeAnalysis.Completion.CompletionTrigger,System.Collections.Immutable.ImmutableHashSet{System.String},System.Threading.CancellationToken)">
            <summary>
            Gets the completions available at the caret position.
            </summary>
            <param name="document">The document that completion is occurring within.</param>
            <param name="caretPosition">The position of the caret after the triggering action.</param>
            <param name="options">The CompletionOptions that override the default options.</param>
            <param name="trigger">The triggering action.</param>
            <param name="roles">Optional set of roles associated with the editor state.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionService.GetDocumentWithFrozenPartialSemantics(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Returns a document with frozen partial semantic unless we already have a complete compilation available.
            Getting full semantic could be costly in certain scenarios and would cause significant delay in completion. 
            In most cases we'd still end up with complete document, but we'd consider it an acceptable trade-off even when 
            we get into this transient state.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionService.ItemsMatch(Microsoft.CodeAnalysis.Completion.CompletionItem,Microsoft.CodeAnalysis.Completion.CompletionItem)">
            <summary>
            Determines if the items are similar enough they should be represented by a single item in the list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionService.GetBetterItem(Microsoft.CodeAnalysis.Completion.CompletionItem,Microsoft.CodeAnalysis.Completion.CompletionItem)">
            <summary>
            Determines which of two items should represent the matching pair.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.CompletionTags">
            <summary>
            The set of well known tags used for the <see cref="P:Microsoft.CodeAnalysis.Completion.CompletionItem.Tags"/> property.
            These tags influence the presentation of items in the list.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.CompletionTrigger">
            <summary>
            The action that triggered completion to start.
            </summary>
            <remarks>
            NOTE: Roslyn's LSP completion implementation uses this struct. If a new property is added, either:
                1: The property's type must be serializable
                OR
                2. LSP will need to be updated to not use CompletionTrigger - see
                   Features\LanguageServer\Protocol\Handler\Completion\CompletionResolveData.cs
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionTrigger.Kind">
            <summary>
            The reason that completion was started.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.CompletionTrigger.Character">
            <summary>
            The character associated with the triggering action.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionTrigger.Default">
            <summary>
            Do not use.  Use <see cref="F:Microsoft.CodeAnalysis.Completion.CompletionTrigger.Invoke"/> instead.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionTrigger.Invoke">
            <summary>
            The default <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionTrigger"/> when none is specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionTrigger.CreateInsertionTrigger(System.Char)">
            <summary>
            Creates a new instance of a <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionTrigger"/> association with the insertion of a typed character into the document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.CompletionTrigger.CreateDeletionTrigger(System.Char)">
            <summary>
            Creates a new instance of a <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionTrigger"/> association with the deletion of a character from the document.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.CompletionTriggerKind">
            <summary>
            The kind of action that triggered completion to start.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionTriggerKind.Other">
            <summary>
            Completion was triggered via some other mechanism.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionTriggerKind.Invoke">
            <summary>
            Completion was trigger by a direct invocation of the completion feature 
            (ctrl-j in Visual Studio).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionTriggerKind.Insertion">
            <summary>
            Completion was triggered via an action inserting a character into the document.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionTriggerKind.Deletion">
            <summary>
            Completion was triggered via an action deleting a character from the document.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionTriggerKind.Snippets">
            <summary>
            Completion was triggered for snippets only.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.CompletionTriggerKind.InvokeAndCommitIfUnique">
            <summary>
            Completion was triggered with a request to commit if a unique item would be selected 
            (ctrl-space in Visual Studio).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.EnterKeyRule">
            <summary>
            Determines whether the enter key is passed through to the editor after it has been used to commit a completion item.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.EnterKeyRule.Never">
            <summary>
            The enter key is never passed through to the editor after it has been used to commit the completion item.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.EnterKeyRule.Always">
            <summary>
            The enter key is always passed through to the editor after it has been used to commit the completion item.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.EnterKeyRule.AfterFullyTypedWord">
            <summary>
            The enter is key only passed through to the editor if the completion item has been fully typed out.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.ExportCompletionProviderAttribute">
            <summary>
            Use this attribute to export a <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionProvider"/> so that it will
            be found and used by the per language associated <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionService"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.ExportCompletionProviderAttribute.#ctor(System.String,System.String)">
            <summary>
            Use this attribute to export a <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionProvider"/> so that it will
            be found and used by the per language associated <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionService"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.INotifyCommittingItemCompletionProvider">
            <summary>
            Interface to implement if the provider want to sign up for notification when one of the items it provided
            is being committed by the host, since calling <see cref="M:Microsoft.CodeAnalysis.Completion.CompletionProvider.GetChangeAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Completion.CompletionItem,System.Nullable{System.Char},System.Threading.CancellationToken)"/> doesn't necessarily
            lead to commission.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.INotifyCommittingItemCompletionProvider.NotifyCommittingItemAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Completion.CompletionItem,System.Nullable{System.Char},System.Threading.CancellationToken)">
            <summary>
            This is invoked when one of the items provided by this provider is being committed.
            </summary>
            <remarks>
            Host provides no guarantee when will this be called (i.e. pre or post document change), nor the text 
            change will actually happen at all (e.g. the commit operation might be cancelled due to cancellation/exception/etc.)
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Completion.LSPCompletionProvider.TriggerCharacters">
            <summary>
            Defines the set of possible non-identifier trigger characters for this completion provider.
            Used by the LSP server to determine the trigger character set for completion.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.MatchPriority">
            <summary>
            An additional hint to the matching algorithm that can
            augment or override the existing text-based matching.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.MatchPriority.Deprioritize">
            <summary>
            The matching algorithm should not select this item unless it's a dramatically 
            better text-based match than other items.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.MatchPriority.Default">
            <summary>
            The matching algorithm should give this item no special treatment.
            
            Ordinary <see cref="T:Microsoft.CodeAnalysis.Completion.CompletionProvider"/>s typically specify this.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.MatchPriority.Preselect">
             <summary>
             The matching algorithm will tend to prefer this item unless
             a dramatically better text-based match is available.
             
             With no filter text, this item (or the first item alphabetically 
             with this priority) should always be selected.
            
             This is used for specific IDE scenarios like "Object creation preselection"
             or "Enum preselection" or "Completion list tag preselection".
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.MatchResult.CompletionItem">
            <summary>
            The CompletionItem used to create this MatchResult.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.MatchResult.MatchedAdditionalFilterText">
            <summary>
            If `CompletionItem.AdditionalFilterTexts` was used to create this MatchResult, then this is set to the one that was used.
            Otherwise this is set to null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.PatternMatchHelper">
            <summary>
            This type is not thread safe due to the restriction of underlying PatternMatcher. 
            Must be disposed after use.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.PatternMatchHelper.#ctor(System.String)">
            <summary>
            This type is not thread safe due to the restriction of underlying PatternMatcher. 
            Must be disposed after use.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Completion.PatternMatchHelper.MatchesPattern(Microsoft.CodeAnalysis.Completion.CompletionItem,System.Globalization.CultureInfo)">
            <summary>
            Returns true if the completion item matches the pattern so far.  Returns 'true'
            if and only if the completion item matches and should be included in the filtered completion
            results, or false if it should not be.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Completion.AbstractContextVariableArgumentProvider">
            <summary>
            This <see cref="T:Microsoft.CodeAnalysis.Completion.ArgumentProvider"/> attempts to locate a matching value in the context of a method invocation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.SnippetsRule.Default">
            <summary>
            Snippet triggering follows the default rules of the language.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.SnippetsRule.NeverInclude">
            <summary>
            Snippets are never included in the completion list
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.SnippetsRule.AlwaysInclude">
            <summary>
            Snippets are always included in the completion list.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Completion.SnippetsRule.IncludeAfterTypingIdentifierQuestionTab">
            <summary>
            Snippets are included if the user types: id?&lt;tab&gt;
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ActiveStatementFlags">
            <summary>
            Flags regarding active statements information.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ActiveStatementFlags.LeafFrame">
            <summary>
            At least one of the threads whom this active statement belongs to is in a leaf frame.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ActiveStatementFlags.PartiallyExecuted">
            <summary>
            The statement is partially executed.
            </summary>
            <remarks>
            An active statement is partially executed if the thread is stopped in between two sequence points.
            This may happen when the users steps through the code in disassembly window (stepping over machine instructions),
            when the compiler emits a call to Debugger.Break (VB Stop statement), etc.
            
            Partially executed active statement can't be edited.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ActiveStatementFlags.NonUserCode">
            <summary>
            The statement IL is not in user code.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ActiveStatementFlags.MethodUpToDate">
            <summary>
            Indicates that the active statement instruction belongs to the latest version of the containing method.
            If not set, the containing method was updated but the active statement was not remapped yet because the thread 
            has not returned to that instruction yet and was not remapped to the new version.
            </summary>
            <remarks>
            When the debugger asks the CLR for the active statement information it compares ICorDebugFunction.GetVersionNumber()
            and ICorDebugFunction.GetCurrentVersionNumber() to determine the value of this flag.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ActiveStatementFlags.NonLeafFrame">
            <summary>
            At least one of the threads whom this active statement belongs to is in a non-leaf frame.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ActiveStatementFlags.Stale">
            <summary>
            When applying updates while the code is executing, we will not attempt any remap for methods which are on the
            executing stack. This is done so we can avoid blocking an edit due an executing active statement. 
            Language services needs to acknowledge such active statements when emitting further remap information.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.DebugSessionFlags.None">
            <summary>
            No flags.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.DebugSessionFlags.EditAndContinueDisabled">
            <summary>
            Edit and Continue has been disabled by the client.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Contracts.EditAndContinue.HotReloadResult">
            <summary>
            Result for a hot reload apply operation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.HotReloadResult.Applied">
            <summary>
            Successfully applied the changes.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.HotReloadResult.NoChanges">
            <summary>
            No changes were found.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.HotReloadResult.RestartRequired">
            <summary>
            Rude edits were found. 
            Changes can be applied by restarting the session.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.HotReloadResult.ErrorEdits">
            <summary>
            Edits with a compiler error were found.
            This assumes that the agents do not support restart and any rude edits were treated as errors.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.HotReloadResult.ApplyUpdateFailure">
            <summary>
            An internal error was found while applying code updates. This will generally be propagated through an exception.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Contracts.EditAndContinue.IManagedHotReloadService">
            <summary>
            Service for providing helper functionality to a language service regarding hot reload and Edit and Continue operations.
            This is currently exported through MEF.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Contracts.EditAndContinue.IManagedHotReloadService.GetActiveStatementsAsync(System.Threading.CancellationToken)">
            <summary>
            Retrieves a list of active statements for the debugging session.
            Shall only be called while the debugger is stopped (break mode).
            Returns empty array if no debugger is present.
            </summary>
            <param name="cancellation">Cancellation token.</param>
            <returns>
            Returns all the active statements in the session. Each <see cref="T:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedActiveStatementDebugInfo"/> has an unique <see cref="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedActiveStatementDebugInfo.ActiveInstruction"/>.
            For example, if an instruction is active in two different threads, only one active statement will be reported for it.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Contracts.EditAndContinue.IManagedHotReloadService.GetAvailabilityAsync(System.Guid,System.Threading.CancellationToken)">
            <summary>
            Check for Edit and Continue availability on all instances with specified <paramref name="module"/>.
            If no debugger is present, this will check if there are any agents available for hot reload or whether
            the user has disabled Edit and Continue or hot reload.
            </summary>
            <param name="module">Target module version identifier. This is only used when under a debugging session.</param>
            <param name="cancellation">Cancellation token.</param>
            <returns>
            Returns first status that's not <see cref="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadAvailabilityStatus.Available"/>, if any.
            Otherwise, if there is at least one instance of the module loaded in a debugging session or there are active hot reload agents, returns <see cref="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadAvailabilityStatus.Available"/>.
            Otherwise, returns <see cref="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadAvailabilityStatus.ModuleNotLoaded"/>.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Contracts.EditAndContinue.IManagedHotReloadService.PrepareModuleForUpdateAsync(System.Guid,System.Threading.CancellationToken)">
            <summary>
            Notifies the debugger that a document has changed, which may affect the given module when that change is applied.
            Calls ISymUnmanagedEncUpdate.InitializeForEnc on SymReader for the given module.
            No-op if no debugger is present.
            </summary>
            <param name="module">Module version identifier.</param>
            <param name="cancellation">Cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Contracts.EditAndContinue.IManagedHotReloadService.GetCapabilitiesAsync(System.Threading.CancellationToken)">
            <summary>
            Get capabilities string for the set of hot reload edits supported by the runtime.
            </summary>
            <param name="cancellation">Cancellation token.</param>
            <returns>
            Returns an array of identifiers. If different agents have different capabilities, it's up to the manager 
            to merge them and present unified set of capabilities to the language service.
            The merging policy is entirely dependent on how the manager applies changes to multiple runtimes.
            </returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedActiveStatementDebugInfo">
            <summary>
            Active statement debug information retrieved from the runtime and the PDB.
            </summary>
            <remarks>
            Creates a ManagedActiveStatementDebugInfo.
            </remarks>
            <param name="activeInstruction">Instruction of the active statement that is being executed.</param>
            <param name="documentName">Document name as found in the PDB, if the active statement location was determined.</param>
            <param name="sourceSpan">Location of the closest non-hidden sequence point from the active statement.</param>
            <param name="flags">Active statement flags shared across all threads that own the active statement.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedActiveStatementDebugInfo.#ctor(Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedInstructionId,System.String,Microsoft.CodeAnalysis.Contracts.EditAndContinue.SourceSpan,Microsoft.CodeAnalysis.Contracts.EditAndContinue.ActiveStatementFlags)">
            <summary>
            Active statement debug information retrieved from the runtime and the PDB.
            </summary>
            <remarks>
            Creates a ManagedActiveStatementDebugInfo.
            </remarks>
            <param name="activeInstruction">Instruction of the active statement that is being executed.</param>
            <param name="documentName">Document name as found in the PDB, if the active statement location was determined.</param>
            <param name="sourceSpan">Location of the closest non-hidden sequence point from the active statement.</param>
            <param name="flags">Active statement flags shared across all threads that own the active statement.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedActiveStatementDebugInfo.ActiveInstruction">
            <summary>
            The instruction of the active statement that is being executed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedActiveStatementDebugInfo.DocumentName">
            <summary>
            Document name as found in the PDB, or null if the debugger can't determine the location of the active statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedActiveStatementDebugInfo.SourceSpan">
            <summary>
            Location of the closest non-hidden sequence point retrieved from the PDB, 
            or default(<see cref="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedActiveStatementDebugInfo.SourceSpan"/>) if the debugger can't determine the location of the active statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedActiveStatementDebugInfo.Flags">
            <summary>
            Aggregated across any threads that own the active instruction.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedActiveStatementUpdate">
            <summary>
            Active statement affected by a managed update.
            This is used when remapping the instruction pointer to the appropriate location.
            </summary>
            <remarks>
            Creates a ManagedActiveStatementUpdate.
            </remarks>
            <param name="method">Method information before the change was made.</param>
            <param name="ilOffset">Old IL offset of the active statement.</param>
            <param name="newSpan">Updated text span for the active statement.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedActiveStatementUpdate.#ctor(Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedModuleMethodId,System.Int32,Microsoft.CodeAnalysis.Contracts.EditAndContinue.SourceSpan)">
            <summary>
            Active statement affected by a managed update.
            This is used when remapping the instruction pointer to the appropriate location.
            </summary>
            <remarks>
            Creates a ManagedActiveStatementUpdate.
            </remarks>
            <param name="method">Method information before the change was made.</param>
            <param name="ilOffset">Old IL offset of the active statement.</param>
            <param name="newSpan">Updated text span for the active statement.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedActiveStatementUpdate.Method">
            <summary>
            Method ID. It has the token for the method that contains the active statement
            and the version when the change was made.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedActiveStatementUpdate.ILOffset">
            <summary>
            Old IL offset for the active statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedActiveStatementUpdate.NewSpan">
            <summary>
            Updated text span for the active statement after the edit was made.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedEditAndContinueEngineCapabilities">
            <summary>
            Flags regarding Edit and Continue engine capabilities.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedEditAndContinueEngineCapabilities.None">
            <summary>
            No flags.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedEditAndContinueEngineCapabilities.CanReplaceMethodsWhileStopped">
            <summary>
            Whether we can replace methods while stopped.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedEditAndContinueEngineCapabilities.SupportsInMethodReplacements">
            <summary>
            Whether the engine supports changes made in the current method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedEditAndContinueEngineCapabilities.SupportsEditAndContinueOnModuleLoad">
            <summary>
            Whether it supports applying changes once a module has been loaded.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedExceptionRegionUpdate">
            <summary>
            Exception region affected by a managed update.
            </summary>
            <remarks>
            Creates an ExceptionRegionUpdate.
            </remarks>
            <param name="method">Method information before the change was made.</param>
            <param name="delta">Total of lines modified after the update.</param>
            <param name="newSpan">Updated text span for the active statement.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedExceptionRegionUpdate.#ctor(Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedModuleMethodId,System.Int32,Microsoft.CodeAnalysis.Contracts.EditAndContinue.SourceSpan)">
            <summary>
            Exception region affected by a managed update.
            </summary>
            <remarks>
            Creates an ExceptionRegionUpdate.
            </remarks>
            <param name="method">Method information before the change was made.</param>
            <param name="delta">Total of lines modified after the update.</param>
            <param name="newSpan">Updated text span for the active statement.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedExceptionRegionUpdate.Method">
            <summary>
            Method ID. It has the token for the method that contains the exception region
            and the version when the change was made.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedExceptionRegionUpdate.Delta">
             <summary>
             The delta is the total of lines modified after the update. This value is inverse:
             
               OldSpan = NewSpan + Delta
               NewSpan = OldSpan - Delta
            
             For example, if 2 new lines were added preceding the exception region, this value will be -2.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedExceptionRegionUpdate.NewSpan">
            <summary>
            Specifies where the exception region starts and ends after the update. This value is 0-based.
            An exception region value generally corresponds to a catch { } block source span before any update is made.
            </summary>
            <remarks>
            This value will take into account any lines affected by the update, so we can correctly track the new exception regions
            when remapping the instruction pointer.
            The new span is expected to be: [PreviousExceptionRegionSpan] + [Delta of updated lines].
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadAvailability">
            <summary>
            Managed hot reload availability information.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadAvailability.#ctor(Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadAvailabilityStatus,System.String)">
            <summary>
            Managed hot reload availability information.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadAvailability.Status">
            <summary>
            Status for the managed hot reload session.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadAvailability.LocalizedMessage">
            <summary>
            [Optional] Localized message for <see cref="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadAvailability.Status"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadAvailabilityStatus">
            <summary>
            Availability status for applying changes under a session.
            </summary>
            <remarks>
            Do not change the value for any of the preexisting status, as this is the value 
            used when reporting telemetry.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadAvailabilityStatus.Available">
            <summary>
            Applying changes is available to the current session.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadAvailabilityStatus.Interop">
            <summary>
            Edit and Continue not supported due to interop debugging.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadAvailabilityStatus.SqlClr">
            <summary>
            Unable to edit code running in SQL server.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadAvailabilityStatus.Minidump">
            <summary>
            Edit and Continue not supported in minidump debugging.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadAvailabilityStatus.Attach">
            <summary>
            Edit and Continue not supported since debugger was attached to a process that
            does not support EnC on attach.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadAvailabilityStatus.ModuleNotLoaded">
            <summary>
            Edit and Continue not supported if the assembly has not been loaded.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadAvailabilityStatus.ModuleReloaded">
            <summary>
            Edit and Continue not supported if the assembly that has been modified during
            debugging is reloaded.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadAvailabilityStatus.NotBuilt">
            <summary>
            Edit and Continue not supported if the source code on disk does not match the
            code running in the process.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadAvailabilityStatus.UnsupportedEngine">
            <summary>
            Edit and Continue not supported for the current engine.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadAvailabilityStatus.NotSupportedForClr64Version">
            <summary>
            Edit and Continue in a 64-bit process requires .NET Framework version 4.5.1 or
            higher.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadAvailabilityStatus.NotAllowedForModule">
            <summary>
            Edit and Continue not supported on the current module. This is a fallback
            scenario in case we fail to determine the exact reason the module does not
            support EnC.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadAvailabilityStatus.Optimized">
            <summary>
            Edit and Continue not supported if code was optimized.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadAvailabilityStatus.DomainNeutralAssembly">
            <summary>
            Edit and Continue not supported if assembly was loaded as domain-neutral.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadAvailabilityStatus.ReflectionAssembly">
            <summary>
            Edit and Continue not supported if assembly was loaded through reflection.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadAvailabilityStatus.IntelliTrace">
            <summary>
            Edit and Continue not supported if IntelliTrace events and call information is
            enabled.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadAvailabilityStatus.NotAllowedForRuntime">
            <summary>
            Edit and Continue not supported on the .NET Runtime the program is running.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadAvailabilityStatus.InternalError">
            <summary>
            Edit and Continue not supported due to an internal error in the debugger.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadAvailabilityStatus.Unavailable">
            <summary>
            Edit and Continue is unavailable, e.g. no suitable engine providers were found.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadAvailabilityStatus.Disabled">
            <summary>
            Applying changes has been disabled by the client.
            If debugging, this means Edit and Continue has been disabled.
            If not debugging, this means hot reload has been disabled.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadDiagnostic">
            <summary>
            Diagnostic information about a particular edit made through hot reload.
            </summary>
            <remarks>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadDiagnostic"/> for an edit made by the user.
            </remarks>
            <param name="id">Diagnostic information identifier.</param>
            <param name="message">User message.</param>
            <param name="severity">Severity of the edit, whether it's an error or a warning.</param>
            <param name="filePath">File path for the target edit.</param>
            <param name="span">Source span of the edit.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadDiagnostic.#ctor(System.String,System.String,Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadDiagnosticSeverity,System.String,Microsoft.CodeAnalysis.Contracts.EditAndContinue.SourceSpan)">
            <summary>
            Diagnostic information about a particular edit made through hot reload.
            </summary>
            <remarks>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadDiagnostic"/> for an edit made by the user.
            </remarks>
            <param name="id">Diagnostic information identifier.</param>
            <param name="message">User message.</param>
            <param name="severity">Severity of the edit, whether it's an error or a warning.</param>
            <param name="filePath">File path for the target edit.</param>
            <param name="span">Source span of the edit.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadDiagnostic.Id">
            <summary>
            Diagnostic information identifier.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadDiagnostic.Message">
            <summary>
            User message which will be displayed for the edit.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadDiagnostic.Severity">
            <summary>
            Severity of the diagnostic information.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadDiagnostic.FilePath">
            <summary>
            File path where the edit was made.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadDiagnostic.Span">
            <summary>
            Source span for the edit.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadDiagnosticSeverity">
            <summary>
            Severity of a rude edit made by the user.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadDiagnosticSeverity.Warning">
            <summary>
            Diagnostic for a warning.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadDiagnosticSeverity.RestartRequired">
            <summary>
            Diagnostic for a rude edit. 
            This is a less severe diagnostic and can be generally addressed by restarting the application.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadDiagnosticSeverity.Error">
            <summary>
            Diagnostic for a compiler error.
            This means we can't do anything until the error is fixed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedInstructionId">
            <summary>
            Active instruction identifier.
            It has the information necessary to track an active instruction within the debug session.
            </summary>
            <remarks>
            Creates an ActiveInstructionId.
            </remarks>
            <param name="method">Method which the instruction is scoped to.</param>
            <param name="ilOffset">IL offset for the instruction.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedInstructionId.#ctor(Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedMethodId,System.Int32)">
            <summary>
            Active instruction identifier.
            It has the information necessary to track an active instruction within the debug session.
            </summary>
            <remarks>
            Creates an ActiveInstructionId.
            </remarks>
            <param name="method">Method which the instruction is scoped to.</param>
            <param name="ilOffset">IL offset for the instruction.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedInstructionId.Method">
            <summary>
            Method which the instruction is scoped to.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedInstructionId.ILOffset">
            <summary>
            The IL offset for the instruction.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedMethodId">
            <summary>
            ManagedMethodId is a module/method pair which is used to uniquely identify the
            symbol store's understanding of a particular CLR method.
            </summary>
            <remarks>
            Creates a ManagedMethodId.
            </remarks>
            <param name="module">Module version ID in which the method exists.</param>
            <param name="method">Method ID.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedMethodId.#ctor(System.Guid,Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedModuleMethodId)">
            <summary>
            ManagedMethodId is a module/method pair which is used to uniquely identify the
            symbol store's understanding of a particular CLR method.
            </summary>
            <remarks>
            Creates a ManagedMethodId.
            </remarks>
            <param name="module">Module version ID in which the method exists.</param>
            <param name="method">Method ID.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedMethodId.Module">
            <summary>
            The module version ID in which the method exists.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedMethodId.Method">
            <summary>
            The unique identifier for the method within <see cref="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedMethodId.Module"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedModuleMethodId">
            <summary>
            ManagedModuleMethodId is a token/version pair which is used to uniquely identify the
            symbol store's understanding of a particular CLR method within a module context.
            See <see cref="T:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedMethodId"/> for more details.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedModuleMethodId.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a ManagedModuleMethodId.
            </summary>
            <param name="token">Method token.</param>
            <param name="version">Method version.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="token"/> is less or equals 0x06000000 or <paramref name="version"/> is less or equals zero. 
            </exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedModuleMethodId.Token">
            <summary>
            The method definition metadata token of the method that contains this symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedModuleMethodId.Version">
             <summary>
             MethodVersion is a 1-based index. This will be '1' for methods that have not
             been edited through Edit-and-continue. For edited methods, the version indicates
             the EnC apply of this method.
             Thus, if the user does 5 EnC applies and a particular method is only edited in the 5th apply, 
             then there are two method ids for this method, and they have Version = 1 and Version = 5.
            
             The debugger needs to deal with old versions of the method because they will
             continue to be on the call stack until control is unwound.The debugger can also hit
             breakpoints or stop for exceptions within exception handling regions of old
             methods. In other words, if the user sets a breakpoint within the catch block of a
             non-leaf method, the debugger needs to set that breakpoint within the old version
             of the method.
             
             In scenarios such as function breakpoint binding, the value '0' may used to
             indicate the current version of the method.
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Contracts.EditAndContinue.SequencePointUpdates">
            <summary>
            Sequence points affected by an update on a specified file.
            </summary>
            <remarks>
            Creates a SequencePointsUpdate.
            </remarks>
            <param name="fileName">Name of the file which was modified.</param>
            <param name="lineUpdates">Collection of the file lines affected by the update.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Contracts.EditAndContinue.SequencePointUpdates.#ctor(System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Contracts.EditAndContinue.SourceLineUpdate})">
            <summary>
            Sequence points affected by an update on a specified file.
            </summary>
            <remarks>
            Creates a SequencePointsUpdate.
            </remarks>
            <param name="fileName">Name of the file which was modified.</param>
            <param name="lineUpdates">Collection of the file lines affected by the update.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.SequencePointUpdates.FileName">
            <summary>
            Name of the modified file as stored in PDB.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.SequencePointUpdates.LineUpdates">
            <summary>
            Collection of the file lines affected by the update.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Contracts.EditAndContinue.SourceLineUpdate">
            <summary>
            Maps source lines affected by an update.
            Zero-based line number.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Contracts.EditAndContinue.SourceLineUpdate.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a SourceLineUpdate. 
            </summary>
            <param name="oldLine">Line number before the update was made.</param>
            <param name="newLine">Line number after the update was made.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="oldLine"/> or <paramref name="newLine"/> is less than 0.
            </exception>
            <remarks>
            We expect that <paramref name="oldLine"/> and <paramref name="newLine"/> have the same value
            when the line delta is zero.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.SourceLineUpdate.OldLine">
            <summary>
            Line number before the update was made, must be zero-based.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.SourceLineUpdate.NewLine">
            <summary>
            Line number after the update was made, must be zero-based.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Contracts.EditAndContinue.SourceSpan">
            <summary>
            The start/end line/column ranges for a contiguous span of text. These should be all zero-indexed.
            This is an alias for TextSpan structures.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Contracts.EditAndContinue.SourceSpan.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a TextSpan.
            </summary>
            <param name="startLine">Start line.</param>
            <param name="startColumn">Start column. -1 if column information is missing.</param>
            <param name="endLine">End line.</param>
            <param name="endColumn">End column. -1 if column information is missing.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="startLine"/> or <paramref name="endLine"/> is less than zero.
            If <paramref name="startColumn"/> or <paramref name="endColumn"/> is less than -1.
            If only <paramref name="startColumn"/> or <paramref name="endColumn"/> is -1.
            </exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.SourceSpan.StartLine">
            <summary>
            Zero-based integer for the starting source line.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.SourceSpan.StartColumn">
            <summary>
            Zero-based integer for the starting source column. If column information is missing (e.g. language service doesn't support it), 
            this value should be treated as -1.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.SourceSpan.EndLine">
            <summary>
            Zero-based integer for the ending source line.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.SourceSpan.EndColumn">
            <summary>
            Zero-based integer for the ending source column. If column information is missing (e.g. language service doesn't support it), 
            this value should be treated as -1.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ConvertCast.AbstractConvertCastCodeRefactoringProvider`3">
             <summary>
             Refactor:
                 var o = (object)1;
            
             Into:
                 var o = 1 as object;
            
             Or vice versa.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ConvertForEachToFor.AbstractConvertForEachToForCodeRefactoringProvider`2.IsSupported(Microsoft.CodeAnalysis.ILocalSymbol,Microsoft.CodeAnalysis.Operations.IForEachLoopOperation,`1)">
            <summary>
            Perform language specific checks if the conversion is supported.
            C#: Currently nothing blocking a conversion
            VB: Nested foreach loops sharing a single Next statement, Next statements with multiple variables and next statements
            not using the loop variable are not supported.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.AnalyzedSwitchSection">
            <summary>
            Represents a switch-section constructed from a series of
            if-conditions, possibly combined with logical-or operator
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.AnalyzedSwitchSection.#ctor(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider{`0,`1,`2,`3}.AnalyzedSwitchLabel},Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Represents a switch-section constructed from a series of
            if-conditions, possibly combined with logical-or operator
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.AnalyzedSwitchLabel">
            <summary>
            Represents a switch-label constructed from a series of
            if-conditions, possibly combined by logical-and operator
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.AnalyzedSwitchLabel.#ctor(Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider{`0,`1,`2,`3}.AnalyzedPattern,System.Collections.Immutable.ImmutableArray{`1})">
            <summary>
            Represents a switch-label constructed from a series of
            if-conditions, possibly combined by logical-and operator
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.AnalyzedPattern">
            <summary>
            Base class to represents a case clause (pattern) constructed from various checks
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.AnalyzedPattern.Type">
            <summary>
            Represents a type-pattern, constructed from is-expression
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.AnalyzedPattern.Type.#ctor(`2)">
            <summary>
            Represents a type-pattern, constructed from is-expression
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.AnalyzedPattern.Source">
            <summary>
            Represents a source-pattern constructed from C# patterns
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.AnalyzedPattern.Source.#ctor(`3)">
            <summary>
            Represents a source-pattern constructed from C# patterns
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.AnalyzedPattern.Constant">
            <summary>
            Represents a constant-pattern constructed from an equality check
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.AnalyzedPattern.Constant.#ctor(`1)">
            <summary>
            Represents a constant-pattern constructed from an equality check
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.AnalyzedPattern.Relational">
            <summary>
            Represents a relational-pattern constructed from comparison operators
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.AnalyzedPattern.Relational.#ctor(Microsoft.CodeAnalysis.Operations.BinaryOperatorKind,`1)">
            <summary>
            Represents a relational-pattern constructed from comparison operators
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.AnalyzedPattern.Range">
            <summary>
            Represents a range-pattern constructed from a couple of comparison operators
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.AnalyzedPattern.Range.#ctor(`1,`1)">
            <summary>
            Represents a range-pattern constructed from a couple of comparison operators
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.AnalyzedPattern.And">
            <summary>
            Represents an and-pattern, constructed from two other patterns.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.AnalyzedPattern.And.#ctor(Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider{`0,`1,`2,`3}.AnalyzedPattern,Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider{`0,`1,`2,`3}.AnalyzedPattern)">
            <summary>
            Represents an and-pattern, constructed from two other patterns.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.Analyzer._switchTargetExpression">
            <summary>
            Holds the expression determined to be used as the target expression of the switch
            </summary>
            <remarks>
            Note that this is initially unset until we find a non-constant expression.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.Analyzer._switchTargetType">
            <summary>
            Holds the type of the <see cref="F:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.Analyzer._switchTargetExpression"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.Analyzer.ConstantResult.None">
            <summary>
            None of operands were constant.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.Analyzer.ConstantResult.Left">
            <summary>
            Signifies that the left operand is the constant.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.Analyzer.ConstantResult.Right">
            <summary>
            Signifies that the right operand is the constant.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.Analyzer.BoundKind.None">
            <summary>
            Not a range bound.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.Analyzer.BoundKind.Lower">
            <summary>
            Signifies that the lower-bound of a range pattern
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.Analyzer.BoundKind.Higher">
            <summary>
            Signifies that the higher-bound of a range pattern
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4.Analyzer.Flip(Microsoft.CodeAnalysis.Operations.BinaryOperatorKind)">
            <summary>
            Changes the direction the operator is pointing
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ConvertLinq.AbstractConvertLinqQueryToForEachProvider`2.DocumentUpdateInfo">
            <summary>
            Handles information about updating the document with the refactoring.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ConvertLinq.AbstractConvertLinqQueryToForEachProvider`2.DocumentUpdateInfo.#ctor(`1,System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Handles information about updating the document with the refactoring.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ConvertLinq.AbstractConvertLinqQueryToForEachProvider`2.DocumentUpdateInfo.UpdateRoot(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Updates the root of the document with the document update.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.AbstractConvertForEachToLinqQueryProvider`2.CreateForEachInfo(`0,Microsoft.CodeAnalysis.SemanticModel,System.Boolean)">
            <summary>
            Parses the forEachStatement until a child node cannot be converted into a query clause.
            </summary>
            <param name="forEachStatement"></param>
            <returns>
            1) extended nodes that can be converted into clauses
            2) identifiers introduced in nodes that can be converted
            3) statements that cannot be converted into clauses
            4) trailing comments to be added to the end
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.AbstractConvertForEachToLinqQueryProvider`2.TryBuildSpecificConverter(Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.ForEachInfo{`0,`1},Microsoft.CodeAnalysis.SemanticModel,`1,System.Threading.CancellationToken,Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.IConverter{`0,`1}@)">
            <summary>
            Tries to build a specific converter that covers e.g. Count, ToList, yield return or other similar cases.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.AbstractConvertForEachToLinqQueryProvider`2.CreateDefaultConverter(Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.ForEachInfo{`0,`1})">
            <summary>
            Creates a default converter where foreach is joined with some children statements but other children statements are kept unmodified.
            Example:
            foreach(...)
            {
                if (condition)
                {
                   doSomething();
                }
            }
            is converted to
            foreach(... where condition)
            {
                   doSomething(); 
            }
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.AbstractConvertForEachToLinqQueryProvider`2.TryBuildConverter(`0,Microsoft.CodeAnalysis.SemanticModel,System.Boolean,System.Threading.CancellationToken,Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.IConverter{`0,`1}@)">
            <summary>
            Tries to build either a specific or a default converter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ConvertNumericLiteral.AbstractConvertNumericLiteralCodeRefactoringProvider`1.ComputeRequestPriority">
            <summary>
            Converting numbers is a fairly uncommon task.  Put these at the end of the list after more relevant
            refactorings.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ConvertToInterpolatedString.AbstractConvertConcatenationToInterpolatedStringRefactoringProvider`1">
            <summary>
            Code refactoring that converts expressions of the form:  a + b + " str " + d + e
            into:
                $"{a + b} str {d}{e}".
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ConvertToInterpolatedString.ConvertRegularStringToInterpolatedStringRefactoringProvider">
            <summary>
            Code refactoring that converts a regular string containing braces to an interpolated string
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ConvertTupleToStruct.DocumentToUpdate.Document">
            <summary>
            The document to update.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ConvertTupleToStruct.DocumentToUpdate.NodesToUpdate">
            <summary>
            The subnodes in this document to walk and update.  If empty, the entire document
            should be walked.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Copilot.CopilotChangeAnalysis">
            <param name="TotalAnalysisTime">Total time to do all analysis (including diagnostics, code fixes, and application).</param>
            <param name="TotalDiagnosticComputationTime">Total time to do all diagnostic computation over all diagnostic kinds.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Copilot.CopilotChangeAnalysis.#ctor(System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.TimeSpan,System.TimeSpan,System.TimeSpan,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Copilot.CopilotDiagnosticAnalysis},Microsoft.CodeAnalysis.Copilot.CopilotCodeFixAnalysis)">
            <param name="TotalAnalysisTime">Total time to do all analysis (including diagnostics, code fixes, and application).</param>
            <param name="TotalDiagnosticComputationTime">Total time to do all diagnostic computation over all diagnostic kinds.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Copilot.CopilotChangeAnalysis.TotalAnalysisTime">
            <summary>Total time to do all analysis (including diagnostics, code fixes, and application).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Copilot.CopilotChangeAnalysis.TotalDiagnosticComputationTime">
            <summary>Total time to do all diagnostic computation over all diagnostic kinds.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Copilot.CopilotDiagnosticAnalysis">
            <param name="Kind">What diagnostic kind this is analysis data for.</param>
            <param name="ComputationTime">How long it took to produce the diagnostics for this diagnostic kind.</param>
            <param name="IdToCount">Mapping from <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Id"/> to the number of diagnostics produced for that id.</param>
            <param name="CategoryToCount">Mapping from <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Category"/> to the number of diagnostics produced for that category.</param>
            <param name="SeverityToCount">Mapping from <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Severity"/> to the number of diagnostics produced for that severity.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Copilot.CopilotDiagnosticAnalysis.#ctor(Microsoft.CodeAnalysis.Diagnostics.DiagnosticKind,System.TimeSpan,System.Collections.Generic.Dictionary{System.String,System.Int32},System.Collections.Generic.Dictionary{System.String,System.Int32},System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.DiagnosticSeverity,System.Int32})">
            <param name="Kind">What diagnostic kind this is analysis data for.</param>
            <param name="ComputationTime">How long it took to produce the diagnostics for this diagnostic kind.</param>
            <param name="IdToCount">Mapping from <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Id"/> to the number of diagnostics produced for that id.</param>
            <param name="CategoryToCount">Mapping from <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Category"/> to the number of diagnostics produced for that category.</param>
            <param name="SeverityToCount">Mapping from <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Severity"/> to the number of diagnostics produced for that severity.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Copilot.CopilotDiagnosticAnalysis.Kind">
            <summary>What diagnostic kind this is analysis data for.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Copilot.CopilotDiagnosticAnalysis.ComputationTime">
            <summary>How long it took to produce the diagnostics for this diagnostic kind.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Copilot.CopilotDiagnosticAnalysis.IdToCount">
            <summary>Mapping from <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Id"/> to the number of diagnostics produced for that id.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Copilot.CopilotDiagnosticAnalysis.CategoryToCount">
            <summary>Mapping from <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Category"/> to the number of diagnostics produced for that category.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Copilot.CopilotDiagnosticAnalysis.SeverityToCount">
            <summary>Mapping from <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Severity"/> to the number of diagnostics produced for that severity.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Copilot.CopilotCodeFixAnalysis">
            <param name="TotalComputationTime">Total time to compute code fixes for the changed regions.</param>
            <param name="TotalApplicationTime">Total time to apply code fixes for the changed regions.</param>
            <param name="DiagnosticIdToCount">Mapping from diagnostic id to to how many diagnostics with that id had fixes.</param>
            <param name="DiagnosticIdToApplicationTime">Mapping from diagnostic id to the total time taken to fix diagnostics with that id.</param>
            <param name="DiagnosticIdToProviderName">Mapping from diagnostic id to the name of the provider that provided the fix.</param>
            <param name="ProviderNameToApplicationTime">Mapping from provider name to the total time taken to fix diagnostics with that provider.</param>
            <param name="ProviderNameToHasConflict">Mapping from provider name to whether or not that provider conflicted with another provider in producing a fix.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Copilot.CopilotCodeFixAnalysis.#ctor(System.TimeSpan,System.TimeSpan,System.Collections.Generic.Dictionary{System.String,System.Int32},System.Collections.Generic.Dictionary{System.String,System.TimeSpan},System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.HashSet{System.String}},System.Collections.Generic.Dictionary{System.String,System.TimeSpan},System.Collections.Generic.Dictionary{System.String,System.Boolean},System.Collections.Generic.Dictionary{System.String,System.Int32},System.Collections.Generic.Dictionary{System.String,System.Int32})">
            <param name="TotalComputationTime">Total time to compute code fixes for the changed regions.</param>
            <param name="TotalApplicationTime">Total time to apply code fixes for the changed regions.</param>
            <param name="DiagnosticIdToCount">Mapping from diagnostic id to to how many diagnostics with that id had fixes.</param>
            <param name="DiagnosticIdToApplicationTime">Mapping from diagnostic id to the total time taken to fix diagnostics with that id.</param>
            <param name="DiagnosticIdToProviderName">Mapping from diagnostic id to the name of the provider that provided the fix.</param>
            <param name="ProviderNameToApplicationTime">Mapping from provider name to the total time taken to fix diagnostics with that provider.</param>
            <param name="ProviderNameToHasConflict">Mapping from provider name to whether or not that provider conflicted with another provider in producing a fix.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Copilot.CopilotCodeFixAnalysis.TotalComputationTime">
            <summary>Total time to compute code fixes for the changed regions.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Copilot.CopilotCodeFixAnalysis.TotalApplicationTime">
            <summary>Total time to apply code fixes for the changed regions.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Copilot.CopilotCodeFixAnalysis.DiagnosticIdToCount">
            <summary>Mapping from diagnostic id to to how many diagnostics with that id had fixes.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Copilot.CopilotCodeFixAnalysis.DiagnosticIdToApplicationTime">
            <summary>Mapping from diagnostic id to the total time taken to fix diagnostics with that id.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Copilot.CopilotCodeFixAnalysis.DiagnosticIdToProviderName">
            <summary>Mapping from diagnostic id to the name of the provider that provided the fix.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Copilot.CopilotCodeFixAnalysis.ProviderNameToApplicationTime">
            <summary>Mapping from provider name to the total time taken to fix diagnostics with that provider.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Copilot.CopilotCodeFixAnalysis.ProviderNameToHasConflict">
            <summary>Mapping from provider name to whether or not that provider conflicted with another provider in producing a fix.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Copilot.CopilotChangeAnalysisUtilities.AnalyzeCopilotChangeAsync(Microsoft.CodeAnalysis.Document,System.Boolean,System.String,System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextChange},System.Threading.CancellationToken)">
            <summary>
            Analyzes and collects interesting data about an edit made by some copilot feature, and reports that back as
            telemetry to help inform what automatic fixing features we should invest in.
            </summary>
            <param name="document">The document being edited.  The document should represent the contents of hte file
            prior to the <paramref name="textChanges"/> being applied.</param>
            <param name="accepted">Whether or not the user accepted the copilot suggestion, or rejected it.  Used to
            determine if there are interesting issues occurring that might be leading to the user rejecting the change
            (for example, excessive syntax errors).</param>
            <param name="featureId">The name of the feature making the text change.  For example 'Completion'.  Used
            to bucket information by feature area in case certain feature produce different sets of diagnostics or 
            fixes commonly.</param>
            <param name="proposalId">Copilot proposal id (generally a stringified <see cref="T:System.Guid"/>).  Used to be able
            to map from one of these proposed edits to any additional telemetry stored in other tables about this copilot
            interaction.</param>
            <param name="textChanges">The actual text changes to make.  The text changes do not have to be normalized.
            Though they should not overlap.  If they overlap, this request will be ignored.  These would be the changes
            passed to <see cref="M:Microsoft.CodeAnalysis.Text.SourceText.WithChanges(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextChange})"/> for the text snapshot corresponding to
            <paramref name="document"/>.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Copilot.CopilotUtilities.GetNewTextAndChangedSpans(Microsoft.CodeAnalysis.Text.SourceText,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextChange})">
            <summary>
            Returns a new <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> that represents the text after applying the specified changes to
            <paramref name="oldText"/>. <c>'newSpans'</c> contains the spans of the <paramref name="changes"/>
            mapped to the new text.  The spans are in the same order as the changes, are guaranteed to be non-overlapping.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Copilot.CopilotUtilities.TryNormalizeCopilotTextChanges(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextChange})">
            <summary>
            Returns the provided <paramref name="textChanges"/> in normalized form.  Normalized means that the
            changes are in order, and no change overlaps with another change.  If changes do overlap, then this
            returns <see langword="default"/>.  Note: abutting changes are not merged.  This allows consumers
            to maintain a 1:1 mapping between the changes applied to the original document and the spans in the
            new document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Copilot.ICopilotChangeAnalysisService.AnalyzeChangeAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextChange},System.Threading.CancellationToken)">
            <summary>
            Kicks of work to analyze a change that copilot suggested making to a document. <paramref name="document"/> is
            the state of the document prior to the edits, and <paramref name="normalizedChanges"/> are the changes Copilot wants to
            make to it.  <paramref name="normalizedChanges"/> must be sorted and normalized before calling this.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Copilot.ICopilotCodeAnalysisService">
            <summary>
            Service to compute and cache Copilot code analysis suggestions, and also acts as an
            entry point for other Copilot code analysis features.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Copilot.ICopilotCodeAnalysisService.IsAvailableAsync(System.Threading.CancellationToken)">
            <summary>
            Returns true if the Copilot service is available for making Copilot code analysis requests.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Copilot.ICopilotCodeAnalysisService.GetAvailablePromptTitlesAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Returns one or more prompt titles for Copilot code analysis.
            First prompt title is for built-in Copilot code analysis prompt.
            Copilot analyzer may support additional prompts for different kinds of code analysis.
            </summary>
            <remarks>
            A prompt's title serves as the ID of the prompt, which can be used to selectively trigger analysis and retrive cached results.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Copilot.ICopilotCodeAnalysisService.AnalyzeDocumentAsync(Microsoft.CodeAnalysis.Document,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.String,System.Threading.CancellationToken)">
            <summary>
            Method to trigger Copilot code analysis on the given <paramref name="document"/>,
            which may be scoped to a specific <paramref name="span"/> within the document.
            <paramref name="promptTitle"/> indicates the kind of Copilot analysis to execute.
            </summary>
            <remarks>
            A prompt's title serves as the ID of the prompt, which can be used to selectively trigger analysis and retrive cached results.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Copilot.ICopilotCodeAnalysisService.GetCachedDocumentDiagnosticsAsync(Microsoft.CodeAnalysis.Document,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Collections.Immutable.ImmutableArray{System.String},System.Threading.CancellationToken)">
            <summary>
            Method to fetch already computed and cached Copilot code analysis diagnostics for the
            given <paramref name="document"/> and <paramref name="promptTitles"/>.
            This method does not invoke any Copilot code analysis requests, and hence is
            relatively cheap.
            </summary>
            <remarks>
            A prompt's title serves as the ID of the prompt, which can be used to selectively trigger analysis and retrive cached results.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Copilot.ICopilotCodeAnalysisService.StartRefinementSessionAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Diagnostic,System.Threading.CancellationToken)">
            <summary>
            Method to start a Copilot refinement session on top of the changes between the given
            <paramref name="oldDocument"/> and <paramref name="newDocument"/>.
            <paramref name="primaryDiagnostic"/> represents an optional diagnostic where the change is originated,
            which might be used to provide additional context to Copilot for the refinement session.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Copilot.ICopilotCodeAnalysisService.GetOnTheFlyDocsPromptAsync(Microsoft.CodeAnalysis.QuickInfo.OnTheFlyDocsInfo,System.Threading.CancellationToken)">
            <summary>
            Retrieves the prompt 
            </summary>
            <param name="onTheFlyDocsInfo">Type containing code and other context about the symbol being examined.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Copilot.ICopilotCodeAnalysisService.GetOnTheFlyDocsResponseAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Retrieves the response from Copilot summarizing what a symbol is being used for and whether or not the quota has exceeded.
            </summary>
            <param name="prompt">The input text used to generate the response.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Copilot.ICopilotCodeAnalysisService.IsFileExcludedAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Determines if the given <paramref name="filePath"/> is excluded in the workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Copilot.ICopilotCodeAnalysisService.GetDocumentationCommentAsync(Microsoft.CodeAnalysis.DocumentationComments.DocumentationCommentProposal,System.Threading.CancellationToken)">
            <summary>
            Method to retrieve the documentation comment for a given <paramref name="proposal"/>
            </summary>
            <param name="proposal">The documentation comment that has been broken down into its individual pieces.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Copilot.ICopilotCodeAnalysisService.IsImplementNotImplementedExceptionsAvailableAsync(System.Threading.CancellationToken)">
            <summary>
            Checks if the feature for implementing <see cref="T:System.NotImplementedException"/> is available.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Copilot.ICopilotCodeAnalysisService.ImplementNotImplementedExceptionsAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.FindSymbols.ReferencedSymbol}},System.Threading.CancellationToken)">
            <summary>
            Implements methods or properties containing <see cref="T:System.NotImplementedException"/> throws in the given <paramref name="document"/>.
            </summary>
            <returns>A dictionary mapping the original syntax nodes to their implementation details.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Copilot.ICopilotOptionsService">
            <summary>
            Provides options for Copilot features.
            Created seperately from ICopilotCodeAnalysisService to avoid additiona; assembly load just for checking option values.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Copilot.ICopilotOptionsService.IsRefineOptionEnabledAsync">
            <summary>
            Returns true if we should show 'Refine using Copilot' hyperlink in the lightbulb
            preview for code actions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Copilot.ICopilotOptionsService.IsCodeAnalysisOptionEnabledAsync">
            <summary>
            Returns true if Copilot background code analysis feature is enabled.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Copilot.ICopilotOptionsService.IsOnTheFlyDocsOptionEnabledAsync">
            <summary>
            Returns true if Copilot on-the-fly docs feature is enabled.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Copilot.ICopilotOptionsService.IsGenerateDocumentationCommentOptionEnabledAsync">
            <summary>
            Returns true if Copilot generate documentation comment feature is enabled.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Copilot.ICopilotOptionsService.IsImplementNotImplementedExceptionEnabledAsync">
            <summary>
            Returns true if Copilot generate method implementation feature is enabled.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Copilot.ImplementationDetails">
            <summary>
            Holds details about a replacement node, providing either a message explaining the absence of a replacement or the
            replacement syntax node itself. One of <see cref="P:Microsoft.CodeAnalysis.Copilot.ImplementationDetails.Message"/> or <see cref="P:Microsoft.CodeAnalysis.Copilot.ImplementationDetails.ReplacementNode"/> must always be set.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Copilot.ImplementationDetails.Message">
            <summary>
            Gets the message explaining why a replacement node is not provided. Either this property or <see cref="P:Microsoft.CodeAnalysis.Copilot.ImplementationDetails.ReplacementNode"/> must be set.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Copilot.ImplementationDetails.ReplacementNode">
            <summary>
            Gets the replacement syntax node. Either this property or <see cref="P:Microsoft.CodeAnalysis.Copilot.ImplementationDetails.Message"/> must be set.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Copilot.ICopilotProposalAdjusterService.TryAdjustProposalAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextChange},System.Threading.CancellationToken)">
            <returns><c>default</c> if the proposal was not adjusted</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Copilot.IRemoteCopilotProposalAdjusterService.TryAdjustProposalAsync(Microsoft.CodeAnalysis.Checksum,Microsoft.CodeAnalysis.DocumentId,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextChange},System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Copilot.ICopilotProposalAdjusterService.TryAdjustProposalAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextChange},System.Threading.CancellationToken)"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Copilot.IRemoteCopilotChangeAnalysisService">
            <summary>Remote version of <see cref="T:Microsoft.CodeAnalysis.Copilot.ICopilotChangeAnalysisService"/></summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Copilot.IRemoteCopilotChangeAnalysisService.AnalyzeChangeAsync(Microsoft.CodeAnalysis.Checksum,Microsoft.CodeAnalysis.DocumentId,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextChange},System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Copilot.ICopilotChangeAnalysisService.AnalyzeChangeAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextChange},System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.AbstractBreakpointResolver.IsApplicable(Microsoft.CodeAnalysis.ISymbol,System.Nullable{System.Int32},System.Threading.CancellationToken)">
            <summary>
            Is this method or property a valid place to set a breakpoint and does it match the expected parameter count?
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Debugging.DebugInformationReaderProvider">
            <summary>
            An abstraction of a symbol reader that provides a reader of Edit and Continue debug information.
            Owns the underlying PDB reader.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.DebugInformationReaderProvider.CreateEditAndContinueMethodDebugInfoReader">
            <summary>
            Creates EnC debug information reader.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.DebugInformationReaderProvider.CreateFromStream(System.IO.Stream)">
            <summary>
            Creates <see cref="T:Microsoft.CodeAnalysis.Debugging.DebugInformationReaderProvider"/> from a stream of Portable or Windows PDB.
            </summary>
            <returns>
            Provider instance, which keeps the <paramref name="stream"/> open until disposed.
            </returns>
            <remarks>
            Requires Microsoft.DiaSymReader.Native.{platform}.dll to be available for reading Windows PDB.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="stream"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="stream"/> does not support read and seek operations.</exception>
            <exception cref="T:System.Exception">Error reading debug information from <paramref name="stream"/>.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.DebugInformationReaderProvider.CreateFromMetadataReader(System.Reflection.Metadata.MetadataReaderProvider)">
            <summary>
            Creates <see cref="T:Microsoft.CodeAnalysis.Debugging.DebugInformationReaderProvider"/> from a Portable PDB metadata reader provider.
            </summary>
            <returns>
            Provider instance, which takes ownership of the <paramref name="metadataProvider"/> until disposed.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="metadataProvider"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.ILanguageDebugInfoService.GetDataTipInfoAsync(Microsoft.CodeAnalysis.Document,System.Int32,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Find an appropriate span to pass the debugger given a point in a snapshot.  Optionally pass back a string to
            pass to the debugger instead if no good span can be found.  For example, if the user hovers on "var" then we
            actually want to pass the fully qualified name of the type that 'var' binds to, to the debugger.
            </summary>
            <param name="includeKind">Whether or not the <see cref="P:Microsoft.CodeAnalysis.Debugging.DebugDataTipInfo.Kind"/> should be computed or not. Can
            be avoided from performance sensitive callers who do not need that information.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoConstants">
            <summary>
            Constants for producing and consuming streams of binary custom debug info.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoEncoder.ToArray">
            <exception cref="T:System.InvalidOperationException">More than <see cref="F:System.Byte.MaxValue"/> records added.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind">
            <summary>
            The kinds of custom debug info in Windows PDBs that we know how to interpret.
            The values correspond to possible values of the "kind" byte
            in the record header.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind.UsingGroups">
            <summary>
            C# only. Encodes the sizes of using groups that are applicable to the method.
            The actual import strings are stored separately trhu ISymUnmanagedWriter.UsingNamespace.
            </summary>
            <remarks>
            Represented by <code>using</code> XML node in PDB tests.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind.ForwardMethodInfo">
            <summary>
            C# only. Indicates that per-method debug information (import strings) is stored on another method, 
            whose token is specified.
            </summary>
            <remarks>
            Represented by <code>forward</code> XML node in PDB tests.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind.ForwardModuleInfo">
            <summary>
            C# only. Indicates that per-module debug information (assembly reference aliases) is stored on another method, 
            whose token is specified.
            </summary>
            <remarks>
            Represented by <code>forwardToModule</code> XML node in PDB tests.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind.StateMachineHoistedLocalScopes">
            <summary>
            C# only. Specifies local scopes for state machine hoisted local variables.
            </summary>
            <remarks>
            Represented by <code>hoistedLocalScopes</code> XML node in PDB tests.
            Equivalent to <see cref="F:Microsoft.CodeAnalysis.Debugging.PortableCustomDebugInfoKinds.StateMachineHoistedLocalScopes"/> in Portable PDB.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind.StateMachineTypeName">
            <summary>
            C# and VB. The name of the state machine type. Emitted for async and iterator kick-off methods.
            </summary>
            <remarks>
            Represented by <code>forwardIterator</code> XML node in PDB tests.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind.DynamicLocals">
            <summary>
            C# only. Dynamic flags for local variables and constants.
            </summary>
            <remarks>
            Represented by <code>dynamicLocals</code> XML node in PDB tests.
            Equivalent to <see cref="F:Microsoft.CodeAnalysis.Debugging.PortableCustomDebugInfoKinds.DynamicLocalVariables"/> in Portable PDB.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind.EditAndContinueLocalSlotMap">
            <summary>
            C# and VB. Encodes EnC local variable slot map.
            See https://github.com/dotnet/corefx/blob/main/src/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#EditAndContinueLocalSlotMap.
            </summary>
            <remarks>
            Represented by <code>encLocalSlotMap</code> XML node in PDB tests.
            Equivalent to <see cref="F:Microsoft.CodeAnalysis.Debugging.PortableCustomDebugInfoKinds.EncLocalSlotMap"/> in Portable PDB.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind.EditAndContinueLambdaMap">
            <summary>
            C# and VB. Encodes EnC lambda map.
            See https://github.com/dotnet/corefx/blob/main/src/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#EditAndContinueLambdaAndClosureMap.
            </summary>
            <remarks>
            Represented by <code>encLambdaMap</code> XML node in PDB tests.
            Equivalent to <see cref="F:Microsoft.CodeAnalysis.Debugging.PortableCustomDebugInfoKinds.EncLambdaAndClosureMap"/> in Portable PDB.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind.TupleElementNames">
            <summary>
            C# and VB. Tuple element names for local variables and constants.
            </summary>
            <remarks>
            Represented by <code>tupleElementNames</code> XML node in PDB tests.
            Equivalent to <see cref="F:Microsoft.CodeAnalysis.Debugging.PortableCustomDebugInfoKinds.TupleElementNames"/> in Portable PDB.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind.EditAndContinueStateMachineStateMap">
            <summary>
            C# and VB. Syntax offsets of nodes associated with state machine states in an async/iterator method and their corresponding state numbers.
            </summary>
            <remarks>
            Represented by <code>encStateMachineStateMap</code> XML node in PDB tests.
            Equivalent to <see cref="F:Microsoft.CodeAnalysis.Debugging.PortableCustomDebugInfoKinds.EncStateMachineStateMap"/> in Portable PDB.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader">
            <summary>
            A collection of utility method for consuming custom debug info from a PDB.
            </summary>
            <remarks>
            This is not a public API, so we're just going to let bad offsets fail on their own.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.ReadGlobalHeader(System.Byte[],System.Int32@,System.Byte@,System.Byte@)">
            <summary>
            This is the first header in the custom debug info blob.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.ReadRecordHeader(System.Byte[],System.Int32@,System.Byte@,Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind@,System.Int32@,System.Int32@)">
            <summary>
            After the global header (see <see cref="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.ReadGlobalHeader(System.Byte[],System.Int32@,System.Byte@,System.Byte@)"/> comes list of custom debug info record.
            Each record begins with a standard header.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.TryGetCustomDebugInfoRecord(System.Byte[],Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind)">
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.GetCustomDebugInfoRecords(System.Byte[])">
            <remarks>
            Exposed for <see cref="T:Roslyn.Test.PdbUtilities.PdbToXmlConverter"/>.
            </remarks>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.DecodeUsingRecord(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            For each namespace declaration enclosing a method (innermost-to-outermost), there is a count
            of the number of imports in that declaration.
            </summary>
            <remarks>
            There's always at least one entry (for the global namespace).
            Exposed for <see cref="T:Roslyn.Test.PdbUtilities.PdbToXmlConverter"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.DecodeForwardRecord(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            This indicates that further information can be obtained by looking at the custom debug
            info of another method (specified by token).
            </summary>
            <remarks>
            Appears when multiple method would otherwise have identical using records (see <see cref="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.DecodeUsingRecord(System.Collections.Immutable.ImmutableArray{System.Byte})"/>).
            Exposed for <see cref="T:Roslyn.Test.PdbUtilities.PdbToXmlConverter"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.DecodeForwardToModuleRecord(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            This indicates that further information can be obtained by looking at the custom debug
            info of another method (specified by token).
            </summary>
            <remarks>
            Appears when there are extern aliases and edit-and-continue is disabled.
            Exposed for <see cref="T:Roslyn.Test.PdbUtilities.PdbToXmlConverter"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.DecodeStateMachineHoistedLocalScopesRecord(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Scopes of state machine hoisted local variables.
            </summary>
            <remarks>
            Exposed for <see cref="T:Roslyn.Test.PdbUtilities.PdbToXmlConverter"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.DecodeForwardIteratorRecord(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Indicates that this method is the iterator state machine for the method named in the record.
            </summary>
            <remarks>
            Appears on kick-off methods of a state machine.
            Exposed for <see cref="T:Roslyn.Test.PdbUtilities.PdbToXmlConverter"/>.
            
            Encodes NULL-terminated UTF16 name of the state machine type.
            The ending NULL character might not be present if the PDB was generated by an older compiler.
            </remarks>
            <exception cref="T:System.InvalidOperationException">Bad data.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.DecodeDynamicLocalsRecord(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Does for locals what System.Runtime.CompilerServices.DynamicAttribute does for parameters, return types, and fields.
            In particular, indicates which occurrences of <see cref="T:System.Object"/> in the signature are really dynamic.
            </summary>
            <remarks>
            Appears when there are dynamic locals.
            Exposed for <see cref="T:Roslyn.Test.PdbUtilities.PdbToXmlConverter"/>.
            </remarks>
            <exception cref="T:System.InvalidOperationException">Bad data.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.DecodeTupleElementNamesRecord(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Tuple element names for locals.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.GetCSharpGroupedImportStrings``1(System.Int32,``0,System.Func{System.Int32,``0,System.Byte[]},System.Func{System.Int32,``0,System.Collections.Immutable.ImmutableArray{System.String}},System.Collections.Immutable.ImmutableArray{System.String}@)">
            <summary>
            Get the import strings for a given method, following forward pointers as necessary.
            </summary>
            <returns>
            For each namespace enclosing the method, a list of import strings, innermost to outermost.
            There should always be at least one entry, for the global namespace.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.GetVisualBasicImportStrings``1(System.Int32,``0,System.Func{System.Int32,``0,System.Collections.Immutable.ImmutableArray{System.String}})">
            <summary>
            Get the import strings for a given method, following forward pointers as necessary.
            </summary>
            <returns>
            A list of import strings.  There should always be at least one entry, for the global namespace.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.TryParseCSharpImportString(System.String,System.String@,System.String@,System.String@,Microsoft.CodeAnalysis.Debugging.ImportTargetKind@)">
            <summary>
            Parse a string representing a C# using (or extern alias) directive.
            </summary>
            <remarks>
            <![CDATA[
            For C#:
             "USystem" -> <namespace name="System" />
             "AS USystem" -> <alias name="S" target="System" kind="namespace" />
             "AC TSystem.Console" -> <alias name="C" target="System.Console" kind="type" />
             "AS ESystem alias" -> <alias name="S" qualifier="alias" target="System" kind="type" />
             "XOldLib" -> <extern alias="OldLib" />
             "ZOldLib assembly" -> <externinfo name="OldLib" assembly="assembly" />
             "ESystem alias" -> <namespace qualifier="alias" name="System" />
             "TSystem.Math" -> <type name="System.Math" />
            ]]>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.TryParseVisualBasicImportString(System.String,System.String@,System.String@,Microsoft.CodeAnalysis.Debugging.ImportTargetKind@,Microsoft.CodeAnalysis.Debugging.VBImportScopeKind@)">
            <summary>
            Parse a string representing a VB import statement.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="import"/> is null.</exception>
            <exception cref="T:System.ArgumentException">Format of <paramref name="import"/> is not valid.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.ReadUtf8String(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32@)">
            <summary>
            Read UTF-8 string with null terminator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.ImportTargetKind.Namespace">
            <summary>
            C# or VB namespace import.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.ImportTargetKind.Type">
            <summary>
            C# or VB type import.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.ImportTargetKind.NamespaceOrType">
            <summary>
            VB namespace or type alias target (not specified).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.ImportTargetKind.Assembly">
            <summary>
            C# extern alias.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.ImportTargetKind.XmlNamespace">
            <summary>
            VB XML import.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.ImportTargetKind.MethodToken">
            <summary>
            VB forwarding information (i.e. another method has the imports for this one).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.ImportTargetKind.CurrentNamespace">
            <summary>
            VB containing namespace (not an import).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.ImportTargetKind.DefaultNamespace">
            <summary>
            VB root namespace (not an import).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.ImportTargetKind.Defunct">
            <summary>
            A kind that is no longer used.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.StateMachineHoistedLocalScope.StartOffset">
            <summary>
            The offset of the first operation in the scope.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Debugging.StateMachineHoistedLocalScope.EndOffset">
            <summary>
            The offset of the first operation outside of the scope, or the method body length.
            If zero then <see cref="F:Microsoft.CodeAnalysis.Debugging.StateMachineHoistedLocalScope.StartOffset"/> is also zero and the slot represents a synthesized local.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DecompiledSource.IDecompilationService">
            <summary>
            Abstraction over the actual decompilation libraries so we can avoid shipping them in source built assemblies.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DecompiledSource.IDecompiledSourceService.AddSourceToAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.MetadataReference,System.String,Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptions,System.Threading.CancellationToken)">
            <summary>
            Generates formatted source code containing general information about the symbol's
            containing assembly and the decompiled source code which the given ISymbol is or is a part of
            into the given document
            </summary>
            <param name="document">The document to generate source into</param>
            <param name="symbolCompilation">The <see cref="T:Microsoft.CodeAnalysis.Compilation"/> in which symbol is resolved.</param>
            <param name="symbol">The symbol to generate source for</param>
            <param name="metadataReference">The reference that contains the symbol</param>
            <param name="assemblyLocation">The location of the implementation assembly to decompile</param>
            <param name="formattingOptions">Options to use to format the generated document, or null to use the default formatting options of the <paramref name="document"/>.</param>
            <param name="cancellationToken">To cancel document operations</param>
            <returns>The updated document, or null if the decompilation could not be performed</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DesignerAttribute.DesignerAttributeData">
            <summary>
            Serialization typed used to pass information to/from OOP and VS.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DesignerAttribute.DesignerAttributeData.Category">
            <summary>
            The category specified in a <c>[DesignerCategory("...")]</c> attribute.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DesignerAttribute.DesignerAttributeData.DocumentId">
            <summary>
            The document this <see cref="F:Microsoft.CodeAnalysis.DesignerAttribute.DesignerAttributeData.Category"/> applies to.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DesignerAttribute.DesignerAttributeData.FilePath">
            <summary>
            Path for this <see cref="F:Microsoft.CodeAnalysis.DesignerAttribute.DesignerAttributeData.DocumentId"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DesignerAttribute.DesignerAttributeDiscoveryService.s_wellKnownDesignerNamespaces">
            <summary>
            Ugly, but sufficient hack.  During times where we're missing global usings (which may not always be available
            while the sdk is regenerating/restoring on things like a tfm switch), we hardcode in knowledge we have about
            which namespaces the core designable types are in.  That way we can still make a solid guess about what the base
            type is, even if we can't resolve it at this moment.
            </summary> 
        </member>
        <member name="F:Microsoft.CodeAnalysis.DesignerAttribute.DesignerAttributeDiscoveryService.s_metadataIdToDesignerAttributeInfo">
            <summary>
            Cache from the individual references a project has, to a boolean specifying if reference knows about the
            System.ComponentModel.DesignerCategoryAttribute attribute.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DesignerAttribute.DesignerAttributeDiscoveryService._gate">
            <summary>
            Protects mutable state in this type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DesignerAttribute.DesignerAttributeDiscoveryService._documentToLastReportedInformation">
            <summary>
            Keep track of the last information we reported.  We will avoid notifying the host if we recompute and these
            don't change.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DesignerAttribute.IDesignerAttributeDiscoveryService.ProcessSolutionAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.DesignerAttribute.IDesignerAttributeDiscoveryService.ICallback,System.Threading.CancellationToken)">
            <summary>
            Called to process the entire solution.  May take a while.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DesignerAttribute.IDesignerAttributeDiscoveryService.ProcessPriorityDocumentAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.DesignerAttribute.IDesignerAttributeDiscoveryService.ICallback,System.Threading.CancellationToken)">
            <summary>
            Called to process a single document.  Should be used to quickly process the document a user is editing.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DesignerAttribute.IRemoteDesignerAttributeDiscoveryService">
            <summary>
            Interface to allow host (VS) to inform the OOP service to start incrementally analyzing and
            reporting results back to the host.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AddImport.UnboundIdentifiersDiagnosticAnalyzerBase`4">
            <summary>
            See https://github.com/dotnet/roslyn/issues/7536.  IDE should not be analyzing and reporting
            compiler diagnostics for normal constructs.  However, the compiler does not report issues
            for incomplete members.  That means that if you just have `public DateTime` that that is counted 
            as an incomplete member where no binding happens at all.  This means that features like 'add import'
            won't work here to offer to add `using System;` if that is all that is written.  
            <para>
            This definitely needs to be fixed at the compiler layer.  However, until that happens, this is 
            only alternative at our disposal.
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.CodeAnalysisDiagnosticAnalyzerServiceFactory.CodeAnalysisDiagnosticAnalyzerService._analyzedProjectToDiagnostics">
            <summary>
            Mapping of projects to the diagnostics for the projects that we've finished running "run code analysis" on.
            Cached results can now be returned for these through <see cref="M:Microsoft.CodeAnalysis.Diagnostics.CodeAnalysisDiagnosticAnalyzerServiceFactory.CodeAnalysisDiagnosticAnalyzerService.GetLastComputedDocumentDiagnostics(Microsoft.CodeAnalysis.DocumentId)"/>
            and <see cref="M:Microsoft.CodeAnalysis.Diagnostics.CodeAnalysisDiagnosticAnalyzerServiceFactory.CodeAnalysisDiagnosticAnalyzerService.GetLastComputedProjectDiagnostics(Microsoft.CodeAnalysis.ProjectId)"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.CodeAnalysisDiagnosticAnalyzerServiceFactory.CodeAnalysisDiagnosticAnalyzerService._clearedProjectIds">
            <summary>
            Previously analyzed projects that we no longer want to report results for.  This happens when an explicit
            build is kicked off.  At that point, we want the build results to win out for a particular project.  We mark
            this project (as opposed to removing from <see cref="F:Microsoft.CodeAnalysis.Diagnostics.CodeAnalysisDiagnosticAnalyzerServiceFactory.CodeAnalysisDiagnosticAnalyzerService._analyzedProjectToDiagnostics"/>) as we want our LSP
            handler to still think it should process it, as that will the cause the diagnostics to be removed when they
            now transition to an empty list returned from this type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CodeAnalysisDiagnosticAnalyzerServiceFactory.CodeAnalysisDiagnosticAnalyzerService.GetLastComputedDocumentDiagnostics(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Running code analysis on the project force computes and caches the diagnostics in <see
            cref="F:Microsoft.CodeAnalysis.Diagnostics.CodeAnalysisDiagnosticAnalyzerServiceFactory.CodeAnalysisDiagnosticAnalyzerService._analyzedProjectToDiagnostics"/>. We return these cached document diagnostics here, including both
            local and non-local document diagnostics.
            </summary>
            <remarks>
            Only returns non-suppressed diagnostics.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.CodeAnalysisDiagnosticAnalyzerServiceFactory.CodeAnalysisDiagnosticAnalyzerService.GetLastComputedProjectDiagnostics(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Running code analysis on the project force computes and caches the diagnostics in <see
            cref="F:Microsoft.CodeAnalysis.Diagnostics.CodeAnalysisDiagnosticAnalyzerServiceFactory.CodeAnalysisDiagnosticAnalyzerService._analyzedProjectToDiagnostics"/>. We return these cached project diagnostics here, i.e. diagnostics
            with no location, by excluding all local and non-local document diagnostics.
            </summary>
            <remarks>
            Only returns non-suppressed diagnostics.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticsUpdatedArgs.ProjectId">
            <summary>
            <see cref="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticsUpdatedArgs.ProjectId"/> this update is associated with, or <see langword="null"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticsUpdatedArgs.DocumentId">
            <summary>
            <see cref="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticsUpdatedArgs.DocumentId"/> this update is associated with, or <see langword="null"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticsUpdatedKind.DiagnosticsRemoved">
            <summary>
            Called when the diagnostic analyzer engine decides to remove existing diagnostics.
            For example, this can happen when a document is removed from a solution.  In that
            case the analyzer engine will delete all diagnostics associated with that document.
            Any layers caching diagnostics should listen for these events to know when to 
            delete their cached items entirely.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticsUpdatedKind.DiagnosticsCreated">
            <summary>
            Called when a new set of (possibly empty) diagnostics have been produced.  This
            happens through normal editing and processing of files as diagnostic analyzers
            produce new diagnostics for documents and projects.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IAnalyzerDriverService.ComputeDeclarationsInSpan(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
            <summary>
            Computes the <see cref="T:Microsoft.CodeAnalysis.DeclarationInfo"/> for all the declarations whose span overlaps with the given <paramref name="span"/>.
            </summary>
            <param name="model">The semantic model for the document.</param>
            <param name="span">Span to get declarations.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.ICodeAnalysisDiagnosticAnalyzerService">
            <summary>
            Service to compute and fetch analyzer diagnostics from explicit invocation of code analysis on a project or a solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.ICodeAnalysisDiagnosticAnalyzerService.RunAnalysisAsync(Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)">
            <summary>
            Runs all the applicable analyzers on the given project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.ICodeAnalysisDiagnosticAnalyzerService.HasProjectBeenAnalyzed(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Returns true if <see cref="M:Microsoft.CodeAnalysis.Diagnostics.ICodeAnalysisDiagnosticAnalyzerService.RunAnalysisAsync(Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)"/> was invoked on either the current or
            a prior snapshot of the project or containing solution for the given <paramref name="projectId"/>. This method
            will keep returning true for a given project ID once any given snapshot of the project has been analyzed. This
            changes once the solution is closed/reloaded, at which point all the projects are returned back to not analyzed
            state and this method will return false.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.ICodeAnalysisDiagnosticAnalyzerService.GetLastComputedDocumentDiagnostics(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Returns analyzer diagnostics reported on the given <paramref name="documentId"/>> from the last <see
            cref="M:Microsoft.CodeAnalysis.Diagnostics.ICodeAnalysisDiagnosticAnalyzerService.RunAnalysisAsync(Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)"/> invocation on the containing project or solution. The
            caller is expected to check <see cref="M:Microsoft.CodeAnalysis.Diagnostics.ICodeAnalysisDiagnosticAnalyzerService.HasProjectBeenAnalyzed(Microsoft.CodeAnalysis.ProjectId)"/> prior to calling this method.
            </summary>
            <remarks>
            Note that the returned diagnostics may not be from the latest document snapshot.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.ICodeAnalysisDiagnosticAnalyzerService.GetLastComputedProjectDiagnostics(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Returns analyzer diagnostics without any document location reported on the given <paramref name="projectId"/>>
            from the last <see cref="M:Microsoft.CodeAnalysis.Diagnostics.ICodeAnalysisDiagnosticAnalyzerService.RunAnalysisAsync(Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)"/> invocation on the given project or
            solution. The caller is expected to check <see cref="M:Microsoft.CodeAnalysis.Diagnostics.ICodeAnalysisDiagnosticAnalyzerService.HasProjectBeenAnalyzed(Microsoft.CodeAnalysis.ProjectId)"/> prior to calling this
            method.
            </summary>
            <remarks>
            Note that the returned diagnostics may not be from the latest project snapshot.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerService.AnalyzerInfoCache">
            <summary>
            Provides and caches analyzer information.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerService.RequestDiagnosticRefresh">
            <summary>
            Re-analyze all projects and documents.  This will cause an LSP diagnostic refresh request to be sent.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerService.ForceAnalyzeProjectAsync(Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)">
            <summary>
            Force analyzes the given project by running all applicable analyzers on the project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerService.GetDiagnosticsForIdsAsync(Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.DocumentId,System.Collections.Immutable.ImmutableHashSet{System.String},System.Func{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Boolean},System.Boolean,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Get diagnostics of the given diagnostic ids and/or analyzers from the given solution. all diagnostics returned
            should be up-to-date with respect to the given solution. Note that for project case, this method returns
            diagnostics from all project documents as well. Use <see cref="M:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerService.GetProjectDiagnosticsForIdsAsync(Microsoft.CodeAnalysis.Project,System.Collections.Immutable.ImmutableHashSet{System.String},System.Func{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Boolean},System.Boolean,System.Threading.CancellationToken)"/> if you want
            to fetch only project diagnostics without source locations.
            </summary>
            <param name="project">Project to fetch the diagnostics for.</param>
            <param name="documentId">Optional document to scope the returned diagnostics.</param>
            <param name="diagnosticIds">Optional set of diagnostic IDs to scope the returned diagnostics.</param>
            <param name="shouldIncludeAnalyzer">Option callback to filter out analyzers to execute for computing diagnostics.</param>
            <param name="includeLocalDocumentDiagnostics">
            Indicates if local document diagnostics must be returned.
            Local diagnostics are the ones that are reported by analyzers on the same file for which the callback was received
            and hence can be computed by analyzing a single file in isolation.
            </param>
            <param name="includeNonLocalDocumentDiagnostics">
            Indicates if non-local document diagnostics must be returned. Non-local diagnostics are the ones reported by
            analyzers either at compilation end callback OR in a different file from which the callback was made. Entire
            project must be analyzed to get the complete set of non-local document diagnostics.
            </param>
            <param name="cancellationToken">Cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerService.GetProjectDiagnosticsForIdsAsync(Microsoft.CodeAnalysis.Project,System.Collections.Immutable.ImmutableHashSet{System.String},System.Func{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Boolean},System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Get project diagnostics (diagnostics with no source location) of the given diagnostic ids and/or analyzers from
            the given solution. all diagnostics returned should be up-to-date with respect to the given solution. Note that
            this method doesn't return any document diagnostics. Use <see cref="M:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerService.GetDiagnosticsForIdsAsync(Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.DocumentId,System.Collections.Immutable.ImmutableHashSet{System.String},System.Func{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Boolean},System.Boolean,System.Boolean,System.Threading.CancellationToken)"/> to also fetch
            those.
            </summary>
            <param name="project">Project to fetch the diagnostics for.</param>
            <param name="diagnosticIds">Optional set of diagnostic IDs to scope the returned diagnostics.</param>
            <param name="shouldIncludeAnalyzer">Option callback to filter out analyzers to execute for computing diagnostics.</param>
            <param name="includeNonLocalDocumentDiagnostics">
            Indicates if non-local document diagnostics must be returned.
            Non-local diagnostics are the ones reported by analyzers either at compilation end callback.
            Entire project must be analyzed to get the complete set of non-local diagnostics.
            </param>
            <param name="cancellationToken">Cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerService.GetDiagnosticsForSpanAsync(Microsoft.CodeAnalysis.TextDocument,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Func{System.String,System.Boolean},Microsoft.CodeAnalysis.CodeActions.ICodeActionRequestPriorityProvider,Microsoft.CodeAnalysis.Diagnostics.DiagnosticKind,System.Threading.CancellationToken)">
            <summary>
            Return up to date diagnostics for the given span for the document
            <para>
            This can be expensive since it is force analyzing diagnostics if it doesn't have up-to-date one yet.
            Predicate <paramref name="shouldIncludeDiagnostic"/> filters out analyzers from execution if 
            none of its reported diagnostics should be included in the result.
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerServiceExtensions.GetDiagnosticsForSpanAsync(Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerService,Microsoft.CodeAnalysis.TextDocument,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Diagnostics.DiagnosticKind,System.Threading.CancellationToken)">
            <summary>
            Return up to date diagnostics of the given <paramref name="diagnosticKind"/> for the given <paramref name="range"/>
            for the given <paramref name="document"/>.
            <para>
            This can be expensive since it is force analyzing diagnostics if it doesn't have up-to-date one yet.
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerServiceExtensions.GetDiagnosticsForSpanAsync(Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerService,Microsoft.CodeAnalysis.TextDocument,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.String,Microsoft.CodeAnalysis.CodeActions.ICodeActionRequestPriorityProvider,Microsoft.CodeAnalysis.Diagnostics.DiagnosticKind,System.Threading.CancellationToken)">
            <summary>
            Return up to date diagnostics for the given <paramref name="range"/> and parameters for the given <paramref name="document"/>.
            <para>
            This can be expensive since it is force analyzing diagnostics if it doesn't have up-to-date one yet. If
            <paramref name="diagnosticId"/> is not null, it gets diagnostics only for this given <paramref
            name="diagnosticId"/> value.
            </para>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticsRefresher">
            <summary>
            Used to send request for diagnostic pull to the client.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticsRefresher.RequestWorkspaceRefresh">
            <summary>
            Requests workspace diagnostics refresh.
            Any component that maintains state whose change may affect reported diagnostics should call <see cref="M:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticsRefresher.RequestWorkspaceRefresh"/> whenever that state changes.
            Any component that reports diagnostics based on the value of a global option should also call <see cref="M:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticsRefresher.RequestWorkspaceRefresh"/> whenever the option value changes.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticsRefresher.GlobalStateVersion">
            <summary>
            Current version of global state that may affect diagnostics. Incremented on every refresh.
            Used to determine whether any global state that might affect workspace diagnostics has changed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DefaultDiagnosticsRefresher._globalStateVersion">
            <summary>
            Incremented every time a refresh is requested.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerService.s_projectToCompilationWithAnalyzers">
            <summary>
            Cached data from a <see cref="T:Microsoft.CodeAnalysis.ProjectState"/> to the last <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzersPair"/> instance
            created for it.  Note: the CompilationWithAnalyzersPair instance is dependent on the set of <see
            cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/>s passed along with the project.  As such, we might not be able to use a prior cached
            value if the set of analyzers changes.  In that case, a new instance will be created and will be cached for the
            next caller.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerService.DiagnosticIncrementalAnalyzer">
            <summary>
            Diagnostic Analyzer Engine V2
            
            This one follows pattern compiler has set for diagnostic analyzer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerService.DiagnosticIncrementalAnalyzer.ComputeDiagnosticAnalysisResultsAsync(Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzersPair,Microsoft.CodeAnalysis.Project,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DocumentDiagnosticAnalyzer},System.Threading.CancellationToken)">
            <summary>
            Return all diagnostics that belong to given project for the given <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> either
            from cache or by calculating them.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerService.DiagnosticIncrementalAnalyzer.StateManager">
            <summary>
            This is in charge of anything related to <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerService.DiagnosticIncrementalAnalyzer.StateManager.#ctor(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerInfoCache)">
            <summary>
            This is in charge of anything related to <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerService.DiagnosticIncrementalAnalyzer.StateManager._hostAnalyzerStateMap">
            <summary>
            Analyzers supplied by the host (IDE). These are built-in to the IDE, the compiler, or from an installed IDE extension (VSIX). 
            Maps language name to the analyzers and their state.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerService.DiagnosticIncrementalAnalyzer.StateManager._projectAnalyzerStateMap">
            <summary>
            Analyzers referenced by the project via a PackageReference. Updates are protected by _projectAnalyzerStateMapGuard.
            ImmutableDictionary used to present a safe, non-immutable view to users.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerService.DiagnosticIncrementalAnalyzer.StateManager._projectAnalyzerStateMapGuard">
            <summary>
            Guard around updating _projectAnalyzerStateMap. This is used in UpdateProjectStateSets to avoid
            duplicated calculations for a project during contentious calls.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerService.DiagnosticIncrementalAnalyzer.StateManager.GetOrCreateAnalyzersAsync(Microsoft.CodeAnalysis.SolutionState,Microsoft.CodeAnalysis.ProjectState,System.Threading.CancellationToken)">
            <summary>
            Return <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/>s for the given <see cref="T:Microsoft.CodeAnalysis.Project"/>. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerService.DiagnosticIncrementalAnalyzer.StateManager.UpdateProjectAnalyzerInfoAsync(Microsoft.CodeAnalysis.SolutionState,Microsoft.CodeAnalysis.ProjectState,System.Threading.CancellationToken)">
            <summary>
            Updates the map to the given project snapshot.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerService.DiagnosticIncrementalAnalyzer.IncrementalMemberEditAnalyzer">
            <summary>
            This type performs incremental analysis in presence of edits to only a single member inside a document.
            For typing scenarios where we are continuously editing a method body, we can optimize the full
            document diagnostic computation by doing the following:
              1. Re-using all the old cached diagnostics outside the edited member node from a prior
                 document snapshot, but with updated diagnostic spans.
                 AND
              2. Replacing all the old diagnostics for the edited member node in a prior document snapshot
                 with the newly computed diagnostics for this member node in the latest document snaphot.
            If we are unable to perform this incremental diagnostics update, we fallback to computing
            the diagnostics for the entire document.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerService.DiagnosticIncrementalAnalyzer.IncrementalMemberEditAnalyzer._lastDocumentWithCachedDiagnostics">
            <summary>
            Weak reference to the last document snapshot for which full document diagnostics
            were computed and saved.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerService.DiagnosticIncrementalAnalyzer.IncrementalMemberEditAnalyzer.MemberSpans">
            <summary>
            Spans of member nodes for incremental analysis.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerService.DiagnosticIncrementalAnalyzer.IncrementalMemberEditAnalyzer.MemberSpans.#ctor(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.VersionStamp,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan})">
            <summary>
            Spans of member nodes for incremental analysis.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerService.DiagnosticIncrementalAnalyzer.s_projectToForceAnalysisData">
            <summary>
            Cached data from a real <see cref="T:Microsoft.CodeAnalysis.ProjectState"/> instance to the cached diagnostic data produced by
            <em>all</em> the analyzers for the project.  This data can then be used by <see
            cref="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerService.DiagnosticIncrementalAnalyzer.GetDiagnosticsForIdsAsync(Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.DocumentId,System.Collections.Immutable.ImmutableHashSet{System.String},System.Func{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Boolean},System.Boolean,System.Boolean,System.Threading.CancellationToken)"/> to speed up subsequent calls through the normal <see
            cref="T:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerService"/> entry points as long as the project hasn't changed at all.
            </summary>
            <remarks>
            This table is keyed off of <see cref="T:Microsoft.CodeAnalysis.ProjectState"/> but stores data from <see cref="T:Microsoft.CodeAnalysis.SolutionState"/> on
            it.  Specifically <see cref="P:Microsoft.CodeAnalysis.SolutionState.Analyzers"/>.  Normally keying off a ProjectState would not be ok
            as the ProjectState might stay the same while the SolutionState changed.  However, that can't happen as
            SolutionState has the data for Analyzers computed prior to Projects being added, and then never changes.
            Practically, solution analyzers are the core Roslyn analyzers themselves we distribute, or analyzers shipped
            by vsix (not nuget).  These analyzers do not get loaded after changing *until* VS restarts.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.DocumentAnalysisExecutor">
            <summary>
            Executes analyzers on a document for computing local syntax/semantic/additional file diagnostics for a specific <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DocumentAnalysisScope"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DocumentAnalysisExecutor.ComputeDiagnosticsAsync(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Threading.CancellationToken)">
            <summary>
            Return all local diagnostics (syntax, semantic) that belong to given document for the given analyzer by calculating them.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DocumentAnalysisExecutor.CreateAnalyzerExceptionDiagnostic(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Exception)">
            <summary>
            Create a diagnostic for exception thrown by the given analyzer.
            </summary>
            <remarks>
            Keep this method in sync with "AnalyzerExecutor.CreateAnalyzerExceptionDiagnostic".
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DocumentAnalysisExecutor.IsAnalyzerEnabledForProject(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.Options.IGlobalOptionService)">
            <summary>
            Return true if the given <paramref name="analyzer"/> is not suppressed for the given project.
            NOTE: This API is intended to be used only for performance optimization.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptionsProvider">
            <summary>
            Provides C# and VB analyzers a convenient access to common editorconfig options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptionsProvider.#ctor(Microsoft.CodeAnalysis.Options.IOptionsReader,System.String)">
            <summary>
            Provides C# and VB analyzers a convenient access to common editorconfig options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticHelper.Create(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.CodeStyle.NotificationOption2,Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Location},System.Collections.Immutable.ImmutableDictionary{System.String,System.String},System.Object[])">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.
            </summary>
            <param name="descriptor">A <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> describing the diagnostic.</param>
            <param name="location">An optional primary location of the diagnostic. If null, <see cref="T:Microsoft.CodeAnalysis.Location"/> will return <see cref="P:Microsoft.CodeAnalysis.Location.None"/>.</param>
            <param name="notificationOption">Notification option for the diagnostic.</param>
            <param name="analyzerOptions">Analyzer options</param>
            <param name="additionalLocations">
            An optional set of additional locations related to the diagnostic.
            Typically, these are locations of other items referenced in the message.
            If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.AdditionalLocations"/> will return an empty list.
            </param>
            <param name="properties">
            An optional set of name-value pairs by means of which the analyzer that creates the diagnostic
            can convey more detailed information to the fixer. If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Properties"/> will return
            <see cref="F:System.Collections.Immutable.ImmutableDictionary`2.Empty"/>.
            </param>
            <param name="messageArgs">Arguments to the message of the diagnostic.</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticHelper.CreateWithLocationTags(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.CodeStyle.NotificationOption2,Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location},System.Object[])">
            <summary>
            Create a diagnostic that adds properties specifying a tag for a set of locations.
            </summary>
            <param name="descriptor">A <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> describing the diagnostic.</param>
            <param name="location">An optional primary location of the diagnostic. If null, <see cref="T:Microsoft.CodeAnalysis.Location"/> will return <see cref="P:Microsoft.CodeAnalysis.Location.None"/>.</param>
            <param name="notificationOption">Notification option of the diagnostic.</param>
            <param name="analyzerOptions">Analyzer options.</param>
            <param name="additionalLocations">
            An optional set of additional locations related to the diagnostic.
            Typically, these are locations of other items referenced in the message.
            These locations are joined with <paramref name="additionalUnnecessaryLocations"/> to produce the value for
            <see cref="P:Microsoft.CodeAnalysis.Diagnostic.AdditionalLocations"/>.
            </param>
            <param name="additionalUnnecessaryLocations">
            An optional set of additional locations indicating unnecessary code related to the diagnostic.
            These locations are joined with <paramref name="additionalLocations"/> to produce the value for
            <see cref="P:Microsoft.CodeAnalysis.Diagnostic.AdditionalLocations"/>.
            </param>
            <param name="messageArgs">Arguments to the message of the diagnostic.</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticHelper.CreateWithLocationTags(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.CodeStyle.NotificationOption2,Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location},System.Collections.Immutable.ImmutableDictionary{System.String,System.String},System.Object[])">
            <summary>
            Create a diagnostic that adds properties specifying a tag for a set of locations.
            </summary>
            <param name="descriptor">A <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> describing the diagnostic.</param>
            <param name="location">An optional primary location of the diagnostic. If null, <see cref="T:Microsoft.CodeAnalysis.Location"/> will return <see cref="P:Microsoft.CodeAnalysis.Location.None"/>.</param>
            <param name="notificationOption">Notification option for the diagnostic.</param>
            <param name="analyzerOptions">Analyzer options.</param>
            <param name="additionalLocations">
            An optional set of additional locations related to the diagnostic.
            Typically, these are locations of other items referenced in the message.
            These locations are joined with <paramref name="additionalUnnecessaryLocations"/> to produce the value for
            <see cref="P:Microsoft.CodeAnalysis.Diagnostic.AdditionalLocations"/>.
            </param>
            <param name="additionalUnnecessaryLocations">
            An optional set of additional locations indicating unnecessary code related to the diagnostic.
            These locations are joined with <paramref name="additionalLocations"/> to produce the value for
            <see cref="P:Microsoft.CodeAnalysis.Diagnostic.AdditionalLocations"/>.
            </param>
            <param name="properties">
            An optional set of name-value pairs by means of which the analyzer that creates the diagnostic
            can convey more detailed information to the fixer.
            </param>
            <param name="messageArgs">Arguments to the message of the diagnostic.</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticHelper.CreateWithMessage(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.CodeStyle.NotificationOption2,Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Location},System.Collections.Immutable.ImmutableDictionary{System.String,System.String},Microsoft.CodeAnalysis.LocalizableString)">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.
            </summary>
            <param name="descriptor">A <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/> describing the diagnostic.</param>
            <param name="location">An optional primary location of the diagnostic. If null, <see cref="T:Microsoft.CodeAnalysis.Location"/> will return <see cref="P:Microsoft.CodeAnalysis.Location.None"/>.</param>
            <param name="notificationOption">Notification option for the diagnostic.</param>
            <param name="analyzerOptions">Analyzer options.</param>
            <param name="additionalLocations">
            An optional set of additional locations related to the diagnostic.
            Typically, these are locations of other items referenced in the message.
            If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.AdditionalLocations"/> will return an empty list.
            </param>
            <param name="properties">
            An optional set of name-value pairs by means of which the analyzer that creates the diagnostic
            can convey more detailed information to the fixer. If null, <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Properties"/> will return
            <see cref="F:System.Collections.Immutable.ImmutableDictionary`2.Empty"/>.
            </param>
            <param name="message">Localizable message for the diagnostic.</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> instance.</returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.IDEDiagnosticIds.FileHeaderMismatch">
            <summary>
            Reported when a file header is missing or does not match the expected string.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.IDEDiagnosticIdToOptionMappingHelper">
            <summary>
            Helper type to map <see cref="T:Microsoft.CodeAnalysis.Diagnostics.IDEDiagnosticIds"/> to an unique editorconfig code style option, if any,
            such that diagnostic's severity can be configured in .editorconfig with an entry such as:
                "%option_name% = %option_value%:%severity%
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.SuppressMessageAttributeState.TargetSymbolResolver.Resolve(System.Boolean@)">
            <summary>
            Attempts to resolve the "Target" argument of the global SuppressMessageAttribute to symbols in compilation.
            </summary>
            <param name="resolvedWithDocCommentIdFormat">Indicates if resolved "Target" argument is in Roslyn's <see cref="T:Microsoft.CodeAnalysis.DocumentationCommentId"/> format.</param>
            <returns>Resolved symbols for the the "Target" argument of the global SuppressMessageAttribute.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.ILspBuildOnlyDiagnostics">
            <summary>
            Marker interface for individual Roslyn languages to expose what diagnostics IDs they have are 'build only'. This
            affects how the LSP client will handle and dedupe related diagnostics produced by Roslyn for live diagnostics
            against the diagnostics produced by CPS when a build is performed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.ILspBuildOnlyDiagnosticsMetadata">
            <inheritdoc cref="T:Microsoft.CodeAnalysis.LanguageServer.ILspBuildOnlyDiagnostics"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.LspBuildOnlyDiagnosticsAttribute">
            <inheritdoc cref="T:Microsoft.CodeAnalysis.LanguageServer.ILspBuildOnlyDiagnostics"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.LspBuildOnlyDiagnosticsAttribute.#ctor(System.String,System.String[])">
            <inheritdoc cref="T:Microsoft.CodeAnalysis.LanguageServer.ILspBuildOnlyDiagnostics"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerOptionsStorage.BackgroundAnalysisScopeOption">
            <summary>
            Option to turn configure background analysis scope for the current user.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerOptionsStorage.CompilerDiagnosticsScopeOption">
            <summary>
            Option to configure compiler diagnostics scope for the current user.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerOptionsStorage.LowMemoryForcedMinimalBackgroundAnalysis">
            <summary>
            Enables forced <see cref="F:Microsoft.CodeAnalysis.SolutionCrawler.BackgroundAnalysisScope.Minimal"/> scope when low VM is detected to improve performance.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerOptionsStorage.GetBackgroundAnalysisScope(Microsoft.CodeAnalysis.Options.IGlobalOptionService,System.String)">
            <summary>
            <para>Gets the effective background analysis scope for the current solution.</para>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerOptionsStorage.GetBackgroundCompilerAnalysisScope(Microsoft.CodeAnalysis.Options.IGlobalOptionService,System.String)">
            <summary>
            <para>Gets the effective background compiler analysis scope for the current solution.</para>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerOptionsStorage.IsFullSolutionAnalysisEnabled(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Options.IGlobalOptionService,System.String)">
            <summary>
            Returns true if full solution analysis is enabled for the given
            <paramref name="analyzer"/> through options for the given <paramref name="language"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerOptionsStorage.IsFullSolutionAnalysisEnabled(Microsoft.CodeAnalysis.Options.IGlobalOptionService,System.String)">
            <summary>
            Returns true if the entire solution will be analyzed in the background
            to compute up-to-date diagnostics for the error list.
            Note that the background analysis scope for compiler diagnostics and
            analyzers can be different. If you want to fetch individual values for
            whether or not full solution analysis is enabled for compiler diagnostics
            and analyzers, use the other overload
            <see cref="M:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerOptionsStorage.IsFullSolutionAnalysisEnabled(Microsoft.CodeAnalysis.Options.IGlobalOptionService,System.String,System.Boolean@,System.Boolean@)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerOptionsStorage.IsFullSolutionAnalysisEnabled(Microsoft.CodeAnalysis.Options.IGlobalOptionService,System.String,System.Boolean@,System.Boolean@)">
            <summary>
            Returns true if the entire solution will be analyzed in the background
            to compute up-to-date diagnostics for the error list.
            Note that the background analysis scope for compiler diagnostics and
            analyzers can be different. Full analysis is enabled if either
            <paramref name="compilerFullSolutionAnalysisEnabled"/> is true or
            <paramref name="analyzersFullSolutionAnalysisEnabled"/> is true.
            Full analysis is disabled only if both these flags are false.
            If you do not care about the individual full solution analysis values
            for compiler diagnostics and analyzers, use the other overload
            <see cref="M:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerOptionsStorage.IsFullSolutionAnalysisEnabled(Microsoft.CodeAnalysis.Options.IGlobalOptionService,System.String)"/>.
            </summary>
            <param name="globalOptions">Global options.</param>
            <param name="language">
            Language of the projects in the solution to analyze.
            </param>
            <param name="compilerFullSolutionAnalysisEnabled">
            Indicates if the compiler diagnostics need to be computed for the entire solution.
            </param>
            <param name="analyzersFullSolutionAnalysisEnabled">
            Indicates if analyzer diagnostics need to be computed for the entire solution.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerOptionsStorage.IsAnalysisDisabled(Microsoft.CodeAnalysis.Options.IGlobalOptionService,System.String)">
            <summary>
            Returns true if background analysis is completely disabled for
            both compiler diagnostics and analyzer diagnostics, i.e. the user
            does not want to see squiggles or error list entries for any diagnostics.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DocumentationComments.AbstractDocumentationCommentFormattingService.FormatterState._listStack">
             <summary>
             Defines the containing lists for the current formatting state. The last item in the list is the
             innermost list.
            
             <list type="bullet">
             <item>
             <term><c>type</c></term>
             <description>The type of list.</description>
             </item>
             <item>
             <term><c>index</c></term>
             <description>The index of the current item in the list.</description>
             </item>
             <item>
             <term><c>renderedItem</c></term>
             <description><see langword="true"/> if the label (a bullet or number) for the current list item has already been rendered; otherwise <see langword="false"/>.</description>
             </item>
             </list>
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DocumentationComments.AbstractDocumentationCommentFormattingService.FormatterState._navigationTargetStack">
            <summary>
            The top item of the stack indicates the hyperlink to apply to text rendered at the current location. It
            consists of a navigation <c>target</c> (the destination to navigate to when clicked) and a <c>hint</c>
            (typically shown as a tooltip for the link). This stack is never empty; when no hyperlink applies to the
            current scope, the top item of the stack will be a default tuple instance.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DocumentationComments.AbstractDocumentationCommentFormattingService.FormatterState._styleStack">
            <summary>
            Tracks the style for text. The top item of the stack is the current style to apply (the merged result of
            all containing styles). This stack is never empty; when no style applies to the current scope, the top
            item of the stack will be <see cref="F:Microsoft.CodeAnalysis.TaggedTextStyle.None"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentationComments.AbstractDocumentationCommentFormattingService.FormatterState.NextListItem">
            <summary>
            Marks the start of an item in a list; called before each item.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DocumentationComments.DocumentationCommentProposal">
            <summary>
            Represents the set of all edits that will be needed to fill in the documentation comment for a symbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DocumentationComments.DocumentationCommentProposedEdit">
            <summary>
            The individual piece of each documentation comment that will eventually be proposed as an edit.
            E.g. the summary tag, the param tag, etc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentationComments.DocumentationCommentSnippet.SpanToReplace">
            <summary>
            The span in the original text that should be replaced with the documentation comment.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentationComments.DocumentationCommentSnippet.SnippetText">
            <summary>
            The documentation comment text to replace the span with
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentationComments.DocumentationCommentSnippet.CaretOffset">
            <summary>
            The offset within <see cref="P:Microsoft.CodeAnalysis.DocumentationComments.DocumentationCommentSnippet.SnippetText"/> where the caret should be positioned after replacement
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentationComments.DocumentationCommentSnippet.Position">
            <summary>
            The original position of the caret in the original text.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentationComments.DocumentationCommentSnippet.MemberNode">
            <summary>
            The node that is being documented.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentationComments.DocumentationCommentSnippet.IndentText">
            <summary>
            The text to use for indentation. This is specifically used for the generate documentation with
            Copilot case to ensure the wrapped comments are indented correctly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentationComments.IDocumentationCommentSnippetService.DocumentationCommentCharacter">
            <summary>
            A single character string indicating what the comment character is for the documentation comments
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DocumentHighlighting.ExportEmbeddedLanguageDocumentHighlighterAttribute">
            <summary>
            Use this attribute to export a <see cref="T:Microsoft.CodeAnalysis.DocumentHighlighting.IEmbeddedLanguageDocumentHighlighter"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentHighlighting.ExportEmbeddedLanguageDocumentHighlighterAttribute.#ctor(System.String,System.String[],System.Boolean,System.String[])">
            <summary>
            Use this attribute to export a <see cref="T:Microsoft.CodeAnalysis.DocumentHighlighting.IEmbeddedLanguageDocumentHighlighter"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DocumentHighlighting.IDocumentHighlightsService">
            <summary>
            Note: This is the new version of the language service and superseded the same named type
            in the EditorFeatures layer.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DocumentHighlighting.IEmbeddedLanguageDocumentHighlighter">
            <inheritdoc cref="T:Microsoft.CodeAnalysis.DocumentHighlighting.IDocumentHighlightsService"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentHighlighting.IEmbeddedLanguageDocumentHighlighter.GetDocumentHighlights(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxToken,System.Int32,Microsoft.CodeAnalysis.DocumentHighlighting.HighlightingOptions,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.DocumentHighlighting.IDocumentHighlightsService.GetDocumentHighlightsAsync(Microsoft.CodeAnalysis.Document,System.Int32,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Document},Microsoft.CodeAnalysis.DocumentHighlighting.HighlightingOptions,System.Threading.CancellationToken)"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DocumentIdSpan">
            <summary>
            Lightweight analog to <see cref="T:Microsoft.CodeAnalysis.DocumentSpan"/> that should be used in features that care about
            pointing at a particular location in a <see cref="T:Microsoft.CodeAnalysis.Document"/> but do not want to root a potentially
            very stale <see cref="T:Microsoft.CodeAnalysis.Solution"/> snapshot that may keep around a lot of memory in a host.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentIdSpan.#ctor(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Lightweight analog to <see cref="T:Microsoft.CodeAnalysis.DocumentSpan"/> that should be used in features that care about
            pointing at a particular location in a <see cref="T:Microsoft.CodeAnalysis.Document"/> but do not want to root a potentially
            very stale <see cref="T:Microsoft.CodeAnalysis.Solution"/> snapshot that may keep around a lot of memory in a host.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DocumentSpan">
            <summary>
            Represents a <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> location in a <see cref="P:Microsoft.CodeAnalysis.DocumentSpan.Document"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentSpan.#ctor(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Represents a <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> location in a <see cref="P:Microsoft.CodeAnalysis.DocumentSpan.Document"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.ActiveMembersBuilder">
            <summary>
            Builds a set of active methods during EnC analysis.
            Active method is a method whose body directly contains an active statement (i.e. an active statement not in a lambda/function).
            Constructor to which field/property initializers are emitted is active if its body or any of the field/property initializers has an active statement outside of a lambda.
            Fields and properties with initializers are considered active if any of the constructors that these initializers are emitted to are active.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.ActiveMembersBuilder.#ctor(Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer,Microsoft.CodeAnalysis.EditAndContinue.DocumentSemanticModel,Microsoft.CodeAnalysis.EditAndContinue.DocumentSemanticModel,System.Threading.CancellationToken)">
            <summary>
            Builds a set of active methods during EnC analysis.
            Active method is a method whose body directly contains an active statement (i.e. an active statement not in a lambda/function).
            Constructor to which field/property initializers are emitted is active if its body or any of the field/property initializers has an active statement outside of a lambda.
            Fields and properties with initializers are considered active if any of the constructors that these initializers are emitted to are active.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.s_unqualifiedMemberDisplayFormat">
            <summary>
            Contains enough information to determine whether two symbols have the same signature.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.TryFindMemberDeclaration(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Collections.OneOrMany{Microsoft.CodeAnalysis.SyntaxNode}@)">
            <summary>
            Finds member declaration node(s) containing given <paramref name="node"/>, if any.
            </summary>
            <param name="activeSpan">Span used to disambiguate member declarations if there are multiple applicable ones based on <paramref name="node"/>.</param>
            <remarks>
            The implementation has to decide what kinds of nodes in top-level match relationship represent a declaration.
            Every member declaration must be represented by exactly one node, but not all nodes have to represent a declaration.
            
            May return multiple declarations if the specified <paramref name="node"/> belongs to bodies of multiple declarations,
            such as in VB <c>Dim a, b As New T</c> case when <paramref name="node"/> is e.g. <c>T</c>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.TryGetDeclarationBody(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ISymbol)">
             <summary>
             If the specified <paramref name="node"/> represents a member declaration returns an object that represents its body.
             </summary>
             <param name="symbol">
               If specified then the returned body must belong to this symbol.
            
               <paramref name="node"/> node itself may represent a <see cref="T:Microsoft.CodeAnalysis.EditAndContinue.MemberBody"/> that doesn't belong to the <paramref name="symbol"/>.
               E.g. a record copy-constructor declaration is represented by the record type declaration node,
               but this node also represents the record symbol itself.
             </param>
             <returns>
             Null for nodes that don't represent declarations.
             </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.IsDeclarationWithSharedBody(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            True if the specified <paramref name="declaration"/> node shares body with another declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.FindEnclosingLambdaBody(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns a node that represents a body of a lambda containing specified <paramref name="node"/>,
            or null if the node isn't contained in a lambda. If a node is returned it must uniquely represent the lambda,
            i.e. be no two distinct nodes may represent the same lambda.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.TryGetActiveSpan(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Int32,Microsoft.CodeAnalysis.Text.TextSpan@)">
            <summary>
            Get the active span that corresponds to specified node (or its part).
            </summary>
            <param name="minLength">
            In case there are multiple breakpoint spans starting at the <see cref="P:Microsoft.CodeAnalysis.SyntaxNode.SpanStart"/> of the <paramref name="node"/>,
            <paramref name="minLength"/> can be used to disambiguate between them. 
            The inner-most available span whose length is at least <paramref name="minLength"/> is returned.
            </param>
            <param name="statementPart">
            <paramref name="node"/> might have multiple active statement span. <paramref name="statementPart"/> is used to identify the 
            specific part.
            </param>
            <returns>
            True if the node has an active span associated with it, false otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.EnumerateNearStatements(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Yields potential active statements around the specified active statement
            starting with siblings following the statement, then preceding the statement, follows with its parent, its following siblings, etc.
            </summary>
            <returns>
            Pairs of (node, statement part), or (node, -1) indicating there is no logical following statement.
            The enumeration continues until the root is reached.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.AreEquivalentActiveStatements(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.Int32)">
            <summary>
            Returns true if the code emitted for the old active statement part (<paramref name="statementPart"/> of <paramref name="oldStatement"/>) 
            is the same as the code emitted for the corresponding new active statement part (<paramref name="statementPart"/> of <paramref name="newStatement"/>). 
            </summary>
            <remarks>
            A rude edit is reported if an active statement is changed and this method returns true.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.AreEquivalent(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Determines if two syntax tokens are the same, disregarding trivia differences.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.GetTopLevelTypeDeclarations(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns all top-level type declarations (non-nested) for a given compilation unit node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.AddSymbolEdits(Microsoft.CodeAnalysis.Collections.TemporaryArray{System.ValueTuple{Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Differencing.EditKind}}@,Microsoft.CodeAnalysis.Differencing.EditKind,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.EditAndContinue.DocumentSemanticModel,Microsoft.CodeAnalysis.EditAndContinue.DocumentSemanticModel,Microsoft.CodeAnalysis.Differencing.Match{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IReadOnlyDictionary{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Differencing.EditKind},Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.SymbolInfoCache,System.Threading.CancellationToken)">
            <summary>
            Returns all symbols with declaring syntax (<see cref="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.GetSymbolDeclarationSyntax(Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)"/> must return a syntax node)
            associated with an edit and an actual edit kind, which may be different then the specified one.
            Returns an empty set if the edit is not associated with any symbols.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.GetEditedSymbols(Microsoft.CodeAnalysis.Differencing.EditKind,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.EditAndContinue.DocumentSemanticModel,Microsoft.CodeAnalysis.EditAndContinue.DocumentSemanticModel,System.Threading.CancellationToken)">
            <summary>
            Returns pairs of old and new symbols associated with a given syntactic edit.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.GetBodyDisplayName(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Differencing.EditKind)">
            <summary>
            Returns the display name of an ancestor node that contains the specified node and has a display name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.IsNestedFunction(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            True if the node represents any form of a function definition nested in another function body (i.e. anonymous function, lambda, local function).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.TryGetLambdaBodies(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.EditAndContinue.LambdaBody@,Microsoft.CodeAnalysis.EditAndContinue.LambdaBody@)">
            <summary>
            Returns all lambda bodies of a node representing a lambda, 
            or false if the node doesn't represent a lambda.
            </summary>
            <remarks>
            C# anonymous function expression and VB lambda expression both have a single body
            (in VB the body is the header of the lambda expression).
            
            Some lambda queries (group by, join by) have two bodies.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.TryGetContainingTypeDeclaration(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns the type declaration that contains a specified <paramref name="node"/>.
            This can be class, struct, interface, record or enum declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.IsDeclarationWithInitializer(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Return true if the declaration is a field/property declaration with an initializer. 
            Shall return false for enum members and const fields.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.IsPrimaryConstructorDeclaration(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            True if <paramref name="declaration"/> is a declaration node of a primary constructor (i.e. parameter list of a type declaration).
            </summary>
            <remarks>
            <see cref="P:Microsoft.CodeAnalysis.ISymbol.DeclaringSyntaxReferences"/> of a primary constructor returns the type declaration syntax.
            This is inconvenient for EnC analysis since it doesn't allow us to distinguish declaration of the type from the constructor.
            E.g. delete/insert of a primary constructor is not the same as delete/insert of the entire type declaration.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.IsConstructorWithMemberInitializers(Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)">
            <summary>
            Return true if <paramref name="symbol"/> is a constructor to which field/property initializers are emitted. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.LambdaInfo">
            <summary>
            Information about an active and/or a matched lambda.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.IncludeLambdaBodyMaps(Microsoft.CodeAnalysis.EditAndContinue.DeclarationBodyMap,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.ActiveNode},System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.EditAndContinue.LambdaBody,Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.LambdaInfo}@)">
            <summary>
            Calculates a syntax map of the entire method body including all lambda bodies it contains.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.ComputeDeclarationBodyMap(Microsoft.CodeAnalysis.EditAndContinue.DeclarationBody,Microsoft.CodeAnalysis.EditAndContinue.DeclarationBody,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.ActiveNode})">
            <summary>
            Called for a member body and for bodies of all lambdas and local functions (recursively) found in the member body.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.TryGetMatchingAncestor(System.Collections.Generic.IReadOnlyDictionary{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            Finds the inner-most ancestor of the specified node that has a matching node in the new tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.AnalyzeTrivia(Microsoft.CodeAnalysis.Differencing.Match{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IReadOnlyDictionary{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Differencing.EditKind},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{System.ValueTuple{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Text.TextSpan}},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.Contracts.EditAndContinue.SequencePointUpdates},System.Threading.CancellationToken)">
            <summary>
            Top-level edit script does not contain edits for a member if only trivia changed in its body.
            It also does not reflect changes in line mapping directives.
            Members that are unchanged but their location in the file changes are not considered updated.
            This method calculates line and trivia edits for all these cases.
            
            The resulting line edits are grouped by mapped document path and sorted by <see cref="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.SourceLineUpdate.OldLine"/> in each group.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.MemberInitializationUpdates">
            <summary>
            Aggregates information needed to emit updates of constructors that contain member initialization.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.MemberInitializationUpdates.#ctor(Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Aggregates information needed to emit updates of constructors that contain member initialization.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.MemberInitializationUpdates.ChangedDeclarations">
            <summary>
            Contains syntax maps for all changed data member initializers or constructor declarations (of constructors emitting initializers)
            in the currently analyzed document. The key is the new declaration of the member.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.MemberInitializationUpdates.HasDeletedMemberInitializer">
            <summary>
            True if a member initializer has been deleted
            (<see cref="F:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.MemberInitializationUpdates.ChangedDeclarations"/> only contains syntax nodes of new declarations, which are not available for deleted members).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.AddSynthesizedMemberEditsForRecordParameterChange(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.EditAndContinue.SemanticEditInfo},Microsoft.CodeAnalysis.IParameterSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.SymbolKey,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Adds edits of synthesized members that may be affected by a <paramref name="parameterSymbol"/> change.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.AddDeconstructorEdits(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.EditAndContinue.SemanticEditInfo},Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.SymbolKey,Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.Compilation,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Adds edits deleting/inserting deconstructor no longer matching <paramref name="constructor"/> of a record
            and inserting/deleting deconstructor the one that maches its signature.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.AllowsDeletion(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns whether or not the specified symbol can be deleted by the user. Normally deletes are a rude edit
            but for some kinds of symbols we allow deletes, and synthesize an update to an empty method body during
            emit.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.AddUpdateEditsForMemberAndAccessors(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.EditAndContinue.SemanticEditInfo},Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)">
            <summary>
            Add <see cref="F:Microsoft.CodeAnalysis.Emit.SemanticEditKind.Update"/> edit for the specified symbol and its accessors.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.AddDeleteEditsForMemberAndAccessors(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.EditAndContinue.SemanticEditInfo},Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SymbolKey,System.Threading.CancellationToken)">
            <summary>
            Add <see cref="F:Microsoft.CodeAnalysis.Emit.SemanticEditKind.Delete"/> edit for the specified symbol and its accessors.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.AddInsertEditsForMemberAndAccessors(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.EditAndContinue.SemanticEditInfo},Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)">
            <summary>
            Add <see cref="F:Microsoft.CodeAnalysis.Emit.SemanticEditKind.Insert"/> edit for the specified symbol and its accessors.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.AddSemanticEditsOriginatingFromParameterUpdate(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.EditAndContinue.SemanticEditInfo},Microsoft.CodeAnalysis.IParameterSymbol,Microsoft.CodeAnalysis.IParameterSymbol,Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken)">
            <summary>
            Semantic edits of members synthesized based on parameters that have no declaring syntax (<see cref="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.GetSymbolDeclarationSyntax(Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)"/> returns null)
            and therefore not produced by <see cref="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.GetSymbolEdits(Microsoft.CodeAnalysis.Differencing.EditKind,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.EditAndContinue.DocumentSemanticModel,Microsoft.CodeAnalysis.EditAndContinue.DocumentSemanticModel,Microsoft.CodeAnalysis.Differencing.Match{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IReadOnlyDictionary{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Differencing.EditKind},Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.SymbolInfoCache,System.Threading.CancellationToken)"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.CanRenameOrChangeSignature(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueCapabilitiesGrantor)">
            <summary>
            Check if the <paramref name="capabilities"/> allow us to rename or change signature of a member.
            Such edit translates to an addition of a new member, an update of any method bodies associated with the old one and marking the member as "deleted".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.AddSynthesizedRecordMethodUpdatesForPropertyChange(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.EditAndContinue.SemanticEditInfo},Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Adds edits for synthesized record members.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.DiagnosticContext.Report(Microsoft.CodeAnalysis.EditAndContinue.RudeEditKind,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken,System.String[])">
            <summary>
            Reports rude edit in the context of newDeclaration.
            
            If <paramref name="locationNode"/> is in the same syntax tree as newDeclaration its span will be used for the location of the diagnostic, otherwise the diagnostic will be reported on the newDeclaration.
            If <paramref name="arguments"/> is given it is used for the diagnostic arguments, otherwise the display name of the newDeclaration is passed as the single argument.
            
            The rude edit will be associated with the syntax kind of newDeclaration in telemetry.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.DiagnosticContext.Report(Microsoft.CodeAnalysis.EditAndContinue.RudeEditKind,System.Threading.CancellationToken,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.String[],System.Nullable{Microsoft.CodeAnalysis.EditAndContinue.RudeEditReportingCondition})">
            <summary>
            Reports rude edit in the context of newDeclaration.
            
            If <paramref name="span"/> is given it will be used for the location of the diagnostic, otherwise the diagnostic will be reported on the newDeclaration.
            If <paramref name="arguments"/> is given it is used for the diagnostic arguments, otherwise the display name of the newDeclaration is passed as the single argument.
            
            The rude edit will be associated with the syntax kind of newDeclaration in telemetry.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.AnyMemberInitializerBody(Microsoft.CodeAnalysis.INamedTypeSymbol,System.Func{Microsoft.CodeAnalysis.EditAndContinue.MemberBody,System.Boolean},System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Return true if <paramref name="predicate"/> is true for a body of any instance/static member of <paramref name="type"/> that has an initializer.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.VariableCapture">
            <summary>
            Represents a captured local variable or a parameter of the current member.
            Primary constructor parameters that are accessed via "this" are represented as
            <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.VariableCaptureKind.This"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.VariableCapture.#ctor(Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.VariableCaptureKind,Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Represents a captured local variable or a parameter of the current member.
            Primary constructor parameters that are accessed via "this" are represented as
            <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.VariableCaptureKind.This"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.VariableCaptureKey">
            <summary>
            Use to look up captures by their symbol identity.
            Captures of kind <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.VariableCaptureKind.This"/> are represented by null <paramref name="CapturedVariable"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.VariableCaptureKey.#ctor(Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.VariableCaptureKind,Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Use to look up captures by their symbol identity.
            Captures of kind <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.VariableCaptureKind.This"/> are represented by null <paramref name="CapturedVariable"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.GetSymbolDeclarationSyntax(Microsoft.CodeAnalysis.ISymbol,System.Func{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxReference},Microsoft.CodeAnalysis.SyntaxReference},System.Threading.CancellationToken)">
            <summary>
            Returns node that represents a declaration of the symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.ChildThatContainsPosition(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Int32@)">
            <summary>
            Returns child node or token that contains given position.
            </summary>
            <remarks>
            This is a copy of <see cref="M:Microsoft.CodeAnalysis.SyntaxNode.ChildThatContainsPosition(System.Int32)"/> that also returns the index of the child node.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.IsPrimaryConstructorParameterMatchingSymbol(Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)">
            <summary>
            True if <paramref name="symbol"/> is a property or a field whose name matches one of the primary constructor parameter names.
            TODO: should be compiler API: https://github.com/dotnet/roslyn/issues/54286
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.GetEncompassingPrimaryConstructor(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)">
            <summary>
            Primary constructor that the <paramref name="symbol"/> participates in (if any),
            i.e. the <paramref name="symbol"/> itself if it is a primary constructor,
            or the primary constructor the member initializer of <paramref name="symbol"/> contributes to.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.SymbolPresenceAffectsSynthesizedRecordMembers(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            True if <paramref name="symbol"/> being inserted or deleted affects the bodies of synthesized record members.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer.DeleteEditImpliesInsertEdit(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken)">
            <summary>
            True if a syntactic delete edit of an <paramref name="oldSymbol"/> in <paramref name="oldCompilation"/>
            that has a corresponding <paramref name="newSymbol"/> in the new compilation implies an existance
            of a matching syntactic insert edit (either in the currently analyzed document or another one).
            
            The old symbol has to be explicitly declared, otherwise it couldn't have been deleted via syntactic delete edit.
            Only detects scenarios where an insert must have occurred. False doesn't mean an insert does not exist.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement">
            <summary>
            Represents an instruction range in the code that contains an active instruction of at least one thread and that is delimited by consecutive sequence points.
            More than one thread can share the same instance of <see cref="T:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement.Id">
            <summary>
            Ordinal of the active statement within the set of all active statements.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement.InstructionId">
            <summary>
            The instruction of the active statement that is being executed.
            The executing version of the method might be several generations old.
            E.g. when the thread is executing an exception handling region and hasn't been remapped yet.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement.FileSpan">
            <summary>
            The current source span.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement.Flags">
            <summary>
            Aggregated across all threads.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement.IsLeaf">
            <summary>
            True if at least one of the threads whom this active statement belongs to is in a leaf frame.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement.IsNonLeaf">
            <summary>
            True if at least one of the threads whom this active statement belongs to is in a non-leaf frame.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement.IsMethodUpToDate">
            <summary>
            True if the active statement is located in a version of the method that's not the latest version of the method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement.IsStale">
            <summary>
            True if the active statement is located in a version of the method that precedes a later version that was created by Hot Reload update.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementExceptionRegions.Spans">
            <summary>
            Exception region spans corresponding to an active statement.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementExceptionRegions.IsActiveStatementCovered">
            <summary>
            True if the active statement is covered by any of the exception region spans.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementLineSpan">
            <summary>
            Represents location of an active statement tracked by the client editor.
            </summary>
            <param name="Id">The corresponding <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement.Id"/>.</param>
            <param name="LineSpan">Line span in the mapped document.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementLineSpan.#ctor(Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementId,Microsoft.CodeAnalysis.Text.LinePositionSpan)">
            <summary>
            Represents location of an active statement tracked by the client editor.
            </summary>
            <param name="Id">The corresponding <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement.Id"/>.</param>
            <param name="LineSpan">Line span in the mapped document.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementLineSpan.Id">
            <summary>The corresponding <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement.Id"/>.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementLineSpan.LineSpan">
            <summary>Line span in the mapped document.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementSpanProvider">
            <summary>
            Provides active statement spans within the specified document of a solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementsMap.DocumentPathMap">
            <summary>
            Groups active statements by document path as listed in the PDB.
            Within each group the statements are ordered by their start position.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementsMap.InstructionMap">
            <summary>
            Active statements by instruction id.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementsMap._lazyOldDocumentActiveStatements">
            <summary>
            Maps syntax tree to active statements with calculated unmapped spans.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementsMap.GetSpansStartingInSpan``2(``1,``1,System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,``1,System.Int32})">
            <summary>
            Since an active statement represents a range between two sequence points and its span is associated with the first of these sequence points,
            we decide whether the active statement is relevant within given span by checking whether its start location is within that span.
            An active statement may overlap a span even if its starting location is not in the span, but such active statement is not relevant 
            for analysis of code within the given span.
            
            Assumes that <paramref name="spans"/> are sorted by their start position.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementSpan">
            <summary>
            Represents a span of an active statement tracked by the client editor.
            </summary>
            <param name="Id">The corresponding <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement.Id"/>.</param>
            <param name="LineSpan">Line span in the mapped document.</param>
            <param name="Flags">Flags.</param>
            <param name="UnmappedDocumentId">
            The id of the unmapped document where the source of the active statement is and from where the statement might be mapped to <see cref="P:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementSpan.LineSpan"/> via <c>#line</c> directive.
            Null if unknown (not determined yet).
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementSpan.#ctor(Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementId,Microsoft.CodeAnalysis.Text.LinePositionSpan,Microsoft.CodeAnalysis.Contracts.EditAndContinue.ActiveStatementFlags,Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Represents a span of an active statement tracked by the client editor.
            </summary>
            <param name="Id">The corresponding <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement.Id"/>.</param>
            <param name="LineSpan">Line span in the mapped document.</param>
            <param name="Flags">Flags.</param>
            <param name="UnmappedDocumentId">
            The id of the unmapped document where the source of the active statement is and from where the statement might be mapped to <see cref="P:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementSpan.LineSpan"/> via <c>#line</c> directive.
            Null if unknown (not determined yet).
            </param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementSpan.Id">
            <summary>The corresponding <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement.Id"/>.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementSpan.LineSpan">
            <summary>Line span in the mapped document.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementSpan.Flags">
            <summary>Flags.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementSpan.UnmappedDocumentId">
            <summary>
            The id of the unmapped document where the source of the active statement is and from where the statement might be mapped to <see cref="P:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementSpan.LineSpan"/> via <c>#line</c> directive.
            Null if unknown (not determined yet).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution">
            <summary>
            Encapsulates access to the last committed solution.
            We don't want to expose the solution directly since access to documents must be gated by out-of-sync checks.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.DocumentState.OutOfSync">
            <summary>
            The current document content does not match the content the module was compiled with.
            This document state may change to <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.DocumentState.MatchesBuildOutput"/> or <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.DocumentState.DesignTimeOnly"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.DocumentState.Indeterminate">
            <summary>
            It hasn't been possible to determine whether the current document content does matches the content 
            the module was compiled with due to error while reading the PDB or the source file.
            This document state may change to <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.DocumentState.MatchesBuildOutput"/> or <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.DocumentState.DesignTimeOnly"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.DocumentState.DesignTimeOnly">
            <summary>
            The document is not compiled into the module. It's only included in the project
            to support design-time features such as completion, etc.
            This is a final state. Once a document is in this state it won't switch to a different one.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.DocumentState.MatchesBuildOutput">
            <summary>
            The current document content matches the content the built module was compiled with.
            This is a final state. Once a document is in this state it won't switch to a different one.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution._solution">
            <summary>
            Current solution snapshot used as a baseline for calculating EnC delta.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution._staleProjects">
            <summary>
            Tracks stale projects. Changes in these projects are ignored and their representation in the <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution._solution"/> does not match the binaries on disk.
            The value is the MVID of the module at the time it was determined to be stale (source code content did not match the PDB).
            A build that updates the binary to new content (that presumably matches the source code) will update the MVID. When that happens we unstale the project.
            
            Build of a multi-targeted project that sets <c>SingleTargetBuildForStartupProjects</c> msbuild property (e.g. MAUI) only 
            builds TFM that's active. Other TFMs of the projects remain unbuilt or stale (from previous build).
            
            A project is removed from this set if it's rebuilt.
            
            Lock <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution._guard"/> to update.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution._documentState">
            <summary>
            Implements workaround for https://github.com/dotnet/project-system/issues/5457.
            
            When debugging is started we capture the current solution snapshot.
            The documents in this snapshot might not match exactly to those that the compiler used to build the module 
            that's currently loaded into the debuggee. This is because there is no reliable synchronization between
            the (design-time) build and Roslyn workspace. Although Roslyn uses file-watchers to watch for changes in 
            the files on disk, the file-changed events raised by the build might arrive to Roslyn after the debugger
            has attached to the debuggee and EnC service captured the solution.
            
            Ideally, the Project System would notify Roslyn at the end of each build what the content of the source
            files generated by various targets is. Roslyn would then apply these changes to the workspace and 
            the EnC service would capture a solution snapshot that includes these changes.
            
            Since this notification is currently not available we check the current content of source files against
            the corresponding checksums stored in the PDB. Documents for which we have not observed source file content 
            that maches the PDB checksum are considered <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.DocumentState.OutOfSync"/>. 
            
            Some documents in the workspace are added for design-time-only purposes and are not part of the compilation
            from which the assembly is built. These documents won't have a record in the PDB and will be tracked as 
            <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.DocumentState.DesignTimeOnly"/>.
            
            A document state can only change from <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.DocumentState.OutOfSync"/> to <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.DocumentState.MatchesBuildOutput"/>.
            Once a document state is <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.DocumentState.MatchesBuildOutput"/> or <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.DocumentState.DesignTimeOnly"/>
            it will never change.
            
            Lock <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution._guard"/> to access.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.GetDocumentAndStateAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Returns a document snapshot for given <see cref="T:Microsoft.CodeAnalysis.Document"/> whose content exactly matches
            the source file used to compile the binary currently loaded in the debuggee. Returns null
            if it fails to find a document snapshot whose content hash maches the one recorded in the PDB.
            
            The result is cached and the next lookup uses the cached value, including failures unless <paramref name="reloadOutOfSyncDocument"/> is true.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution.TryReadSourceFileChecksumFromPdb(Microsoft.CodeAnalysis.EditAndContinue.TraceLog,Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueMethodDebugInfoReader,System.String,System.Collections.Immutable.ImmutableArray{System.Byte}@,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm@)">
            <summary>
            Returns true if the PDB contains a document record for given <paramref name="sourceFilePath"/>,
            in which case <paramref name="checksum"/> and <paramref name="algorithm"/> contain its checksum.
            False if the document is not found in the PDB.
            Null if it can't be determined because the PDB is not available or an error occurred while reading the PDB.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.DebuggingSession">
            <summary>
            Represents a debugging session.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.DebuggingSession.SessionLog">
            <summary>
            Logs debugging session events.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.DebuggingSession.AnalysisLog">
            <summary>
            Logs EnC analysis events. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.DebuggingSession._projectBaselines">
            <summary>
            Current baselines for given project id.
            The baselines are updated when changes are committed at the end of edit session.
            </summary>
            <remarks>
            The backing module readers of initial baselines need to be kept alive -- store them in
            <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.DebuggingSession._initialBaselineModuleReaders"/> and dispose them at the end of the debugging session.
            
            The baseline of each updated project is linked to its initial baseline that reads from the on-disk metadata and PDB.
            Therefore once an initial baseline is created it needs to be kept alive till the end of the debugging session,
            even when it's replaced in <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.DebuggingSession._projectBaselines"/> by a newer baseline.
            
            One project may have multiple baselines. Deltas emitted for the project when source changes are applied are based 
            on the same source changes for all the baselines, however they differ in the baseline they are chained to (MVID and relative tokens).
            
            For example, in the following scenario:
            
              A shared library Lib is referenced by two executable projects A and B and Lib.dll is copied to their respective output directories and the following events occur:
              1) A is launched, modules A.exe and Lib.dll [1] are loaded.
              2) Change is made to Lib.cs and applied.
              3) B is launched, which builds new version of Lib.dll [2], and modules B.exe and Lib.dll [2] are loaded.
              4) Another change is made to Lib.cs and applied.
                
              At this point we have two baselines for Lib: Lib.dll [1] and Lib.dll [2], each have different MVID.
              We need to emit 2 deltas for the change in step 4:
              - one that chains to the first delta applied to Lib.dll, which itself chains to the baseline of Lib.dll [1].
              - one that chains to the baseline Lib.dll [2]
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.DebuggingSession._baselineContentAccessLock">
            <summary>
            To avoid accessing metadata/symbol readers that have been disposed,
            read lock is acquired before every operation that may access a baseline module/symbol reader 
            and write lock when the baseline readers are being disposed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.DebuggingSession._updateOrdinal">
            <summary>
            Incremented on every emit update invocation. Used by logging.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.DebuggingSession.LastCommittedSolution">
            <summary>
            The solution captured when the debugging session entered run mode (application debugging started),
            or the solution which the last changes committed to the debuggee at the end of edit session were calculated from.
            The solution reflecting the current state of the modules loaded in the debugee.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.DebuggingSession.ReportDiagnostics">
            <summary>
            True if the diagnostics produced by the session should be reported to the diagnotic analyzer.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.DebuggingSession._lastModuleUpdatesLog">
            <summary>
            Last array of module updates generated during the debugging session.
            Useful for crash dump diagnostics.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.DebuggingSession.GetProjectModuleIdAsync(Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)">
            <summary>
            Reads the latest MVID of the assembly compiled from given project.
            </summary>
            <returns>
            An MVID and an error message to report, in case an IO exception occurred while reading the binary.
            The MVID is <see cref="F:System.Guid.Empty"/> if either the project is not built, or the MVID can't be read from the module binary.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.DebuggingSession.GetOrCreateEmitBaselines(System.Guid,Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.Diagnostic},System.Threading.ReaderWriterLockSlim@)">
            <summary>
            Get <see cref="T:Microsoft.CodeAnalysis.Emit.EmitBaseline"/> for given project.
            </summary>
            <param name="moduleId">The current MVID of the project compilation output.</param>
            <param name="baselineProject">Project used to create the initial baseline, if the baseline does not exist yet.</param>
            <param name="baselineCompilation">Compilation used to create the initial baseline, if the baseline does not exist yet.</param>
            <returns>True unless the project outputs can't be read.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.DebuggingSession.GetBaseActiveStatementSpansAsync(Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DocumentId},System.Threading.CancellationToken)">
            <summary>
            Returns <see cref="T:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementSpan"/>s for each document of <paramref name="documentIds"/>,
            or default if not in a break state.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.DeclarationBody.RootNodes">
            <summary>
            Root nodes of the body. Descendant nodes of these roots include all nodes of the body and no nodes that do not belong to the body.
            Note: descendant nodes may include some tokens that are not part of the body and exclude some tokens that are.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.DeclarationBody.GetExpressionsAndStatements">
            <summary>
            Returns all nodes of the body.
            </summary>
            <remarks>
            Note that VB lambda bodies are represented by a lambda header and that some lambda bodies share 
            their parent nodes with other bodies (e.g. join clause expressions).
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.DeclarationBody.EncompassingAncestor">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> that includes all active tokens (<see cref="M:Microsoft.CodeAnalysis.EditAndContinue.MemberBody.GetActiveTokens"/>)
            and its span covers the entire <see cref="P:Microsoft.CodeAnalysis.EditAndContinue.MemberBody.Envelope"/>.
            May include descendant nodes or tokens that do not belong to the body.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.DeclarationBody.GetCapturedVariables(Microsoft.CodeAnalysis.SemanticModel)">
            <summary>
            Analyzes data flow in the member body represented by the specified node and returns all captured variables and parameters (including "this").
            If the body is a field/property initializer analyzes the initializer expression only.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.DeclarationBody.ComputeMap(Microsoft.CodeAnalysis.EditAndContinue.DeclarationBody,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode}})">
            <summary>
            Computes a statement-level syntax tree match of this body with <paramref name="newBody"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.DeclarationBody.ComputeSingleRootMatch(Microsoft.CodeAnalysis.EditAndContinue.DeclarationBody,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode}})">
            <summary>
            If both this body and <paramref name="newBody"/> have single roots, computes a statement-level syntax tree match rooted in these roots.
            Otherwise, returns null (e.g. a primary constructor with implicit initializer does not have any body to match).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.DeclarationBody.TryMatchActiveStatement(Microsoft.CodeAnalysis.EditAndContinue.DeclarationBody,Microsoft.CodeAnalysis.SyntaxNode,System.Int32@,Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            Matches old active statement node to new active statement node for nodes that are not accounted for in the body match or do not match but should be mapped
            (e.g. constructor initializers, opening brace of block body to expression body, etc.).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.DocumentAnalysisResults.DocumentId">
            <summary>
            The state of the document the results are calculated for.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.DocumentAnalysisResults.FilePath">
            <summary>
            Document file path for logging.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.DocumentAnalysisResults.ActiveStatements">
            <summary>
            Spans of active statements in the document, or null if the document has syntax errors or has not changed.
            Calculated even in presence of rude edits so that the active statements can be rendered in the editor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.DocumentAnalysisResults.RudeEdits">
            <summary>
            Diagnostics for rude edits in the document, or empty if the document is unchanged or has syntax errors.
            Includes errors, should block the update and warnings, which should not.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.DocumentAnalysisResults.SyntaxError">
            <summary>
            The first syntax error, if the document <see cref="P:Microsoft.CodeAnalysis.EditAndContinue.DocumentAnalysisResults.HasChanges"/> and a syntax error. Null otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.DocumentAnalysisResults.SemanticEdits">
            <summary>
            Edits made in the document, or null if the document is unchanged, has syntax errors or rude edits.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.DocumentAnalysisResults.ExceptionRegions">
             <summary>
             Exception regions -- spans of catch and finally handlers that surround the active statements.
             
             Null if the document has syntax errors, rude edits or has not changed.
             </summary>
             <remarks>
             Null if there are any rude edit diagnostics.
             
             Otherwise, each active statement in <see cref="P:Microsoft.CodeAnalysis.EditAndContinue.DocumentAnalysisResults.ActiveStatements"/> has a corresponding slot in <see cref="P:Microsoft.CodeAnalysis.EditAndContinue.DocumentAnalysisResults.ExceptionRegions"/>.
            
             Exception regions for each EH block/clause are marked as |...|.
               try { ... AS ... } |catch { } finally { }|
               try { } |catch { ... AS ... }| finally { }
               try { } catch { } |finally { ... AS ... }|
             
             Contains a minimal set of spans that cover the handlers.
             For example:
               try { } |finally { try { ... AS ... } catch {  } }|
               try { } |finally { try { } catch { ... AS ... } }|
               try { try { } |finally { ... AS ... }| } |catch { } catch { } finally { }|
             </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.DocumentAnalysisResults.LineEdits">
            <summary>
            Line edits in the document (or mapped documents), or null if the document has syntax errors, rude edits or has not changed.
            </summary>
            <remarks>
            Grouped by file name and updates in each group are ordered by <see cref="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.SourceLineUpdate.OldLine"/>. 
            Each entry in the group applies the delta of <see cref="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.SourceLineUpdate.NewLine"/> - <see cref="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.SourceLineUpdate.OldLine"/>
            to all lines in range [<see cref="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.SourceLineUpdate.OldLine"/>, next entry's <see cref="P:Microsoft.CodeAnalysis.Contracts.EditAndContinue.SourceLineUpdate.OldLine"/>).
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.DocumentAnalysisResults.RequiredCapabilities">
            <summary>
            Capabilities that are required for the updates made in this document.
            <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueCapabilities.None"/> if the document does not have valid changes.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.DocumentAnalysisResults.ElapsedTime">
            <summary>
            Time span it took to perform the analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.DocumentAnalysisResults.AnalysisBlocked">
            <summary>
            True if the document <see cref="P:Microsoft.CodeAnalysis.EditAndContinue.DocumentAnalysisResults.HasChanges"/> and contains errors that block EnC analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.DocumentAnalysisResults.HasChanges">
            <summary>
            Document contains changes.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.DocumentAnalysisResults.HasBlockingRudeEdits">
            <summary>
            True if any of the <see cref="P:Microsoft.CodeAnalysis.EditAndContinue.DocumentAnalysisResults.RudeEdits"/> are blocking.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.DocumentAnalysisResults.Blocked(Microsoft.CodeAnalysis.DocumentId,System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.EditAndContinue.RudeEditDiagnostic},Microsoft.CodeAnalysis.Diagnostic,System.TimeSpan,System.Boolean)">
            <summary>
            Report errors blocking the document analysis.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.DocumentAnalysisResults.Unchanged(Microsoft.CodeAnalysis.DocumentId,System.String,System.TimeSpan)">
            <summary>
            Report unchanged document results.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.DocumentSemanticModel.Model">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/> for the document, or null if the document has been deleted.
            The <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.DocumentSemanticModel.SyntaxTree"/> is empty in the latter case.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.DocumentSemanticModel.RequiredModel">
            <summary>
            Semnatic model can only be used if we have a syntax node from the document (the tree is not empty).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueCapabilities">
            <summary>
            The capabilities that the runtime has with respect to edit and continue
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueCapabilities.Baseline">
            <summary>
            Edit and continue is generally available with the set of capabilities that Mono 6, .NET Framework and .NET 5 have in common.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueCapabilities.AddMethodToExistingType">
            <summary>
            Adding a static or instance method to an existing type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueCapabilities.AddStaticFieldToExistingType">
            <summary>
            Adding a static field to an existing type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueCapabilities.AddInstanceFieldToExistingType">
            <summary>
            Adding an instance field to an existing type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueCapabilities.NewTypeDefinition">
            <summary>
            Creating a new type definition.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueCapabilities.ChangeCustomAttributes">
            <summary>
            Adding, updating and deleting of custom attributes (as distinct from pseudo-custom attributes)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueCapabilities.UpdateParameters">
            <summary>
            Whether the runtime supports updating the Param table, and hence related edits (eg parameter renames)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueCapabilities.GenericAddMethodToExistingType">
            <summary>
            Adding a static or instance method, property or event to an existing type (without backing fields), such that the method and/or the type are generic.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueCapabilities.GenericUpdateMethod">
            <summary>
            Updating an existing static or instance method, property or event (without backing fields) that is generic and/or contained in a generic type. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueCapabilities.GenericAddFieldToExistingType">
            <summary>
            Adding a static or instance field to an existing generic type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueCapabilities.AddExplicitInterfaceImplementation">
            <summary>
            The runtime supports adding to InterfaceImpl table.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueCapabilities.AddFieldRva">
            <summary>
            The runtime supports adding FieldRva table entry. This allows compiler to emit better code for certain features including
            array initializers, collection expressions, UTF8 string literals and data section string literals.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueCapabilitiesGrantor">
            <summary>
            Grants capabilities. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueCapabilitiesGrantor.#ctor(Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueCapabilities)">
            <summary>
            Grants capabilities. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueDocumentAnalysesCache">
            <summary>
            Calculates and caches results of changed documents analysis. 
            The work is triggered by an incremental analyzer on idle or explicitly when "continue" operation is executed.
            Contains analyses of the latest observed document versions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueDocumentAnalysesCache.#ctor(Roslyn.Utilities.AsyncLazy{Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementsMap},Roslyn.Utilities.AsyncLazy{Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueCapabilities},Microsoft.CodeAnalysis.EditAndContinue.TraceLog)">
            <summary>
            Calculates and caches results of changed documents analysis. 
            The work is triggered by an incremental analyzer on idle or explicitly when "continue" operation is executed.
            Contains analyses of the latest observed document versions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueDocumentAnalysesCache.GetDocumentAnalysisAsync(Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution,Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementSpanProvider,System.Threading.CancellationToken)">
            <summary>
            Returns a document analysis or kicks off a new one if one is not available for the specified document snapshot.
            </summary>
            <param name="oldSolution">Committed solution.</param>
            <param name="newDocument">Document snapshot to analyze.</param>
            <param name="activeStatementSpanProvider">Provider of active statement spans tracked by the editor for the solution snapshot of the <paramref name="newDocument"/>.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueDocumentAnalysesCache.GetLatestUnmappedActiveStatementSpansAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementSpanProvider,System.Threading.CancellationToken)">
            <summary>
            Calculates unmapped active statement spans in the <paramref name="newDocument"/> from spans provided by <paramref name="newActiveStatementSpanProvider"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueErrorCode.ChangingProjectSettingBase">
            <summary>
            Base code for project setting rude edits. 
            <see cref="T:Microsoft.CodeAnalysis.EditAndContinue.ProjectSettingKind"/> is added to this value.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueMethodDebugInfoReader">
            <summary>
            Reader of debug information needed for EnC.
            This object does not own the underlying memory (SymReader/MetadataReader).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueMethodDebugInfoReader.TryGetDocumentChecksum(System.String,System.Collections.Immutable.ImmutableArray{System.Byte}@,System.Guid@)">
            <summary>
            Reads document checksum.
            </summary>
            <returns>True if a document with given path is listed in the PDB.</returns>
            <exception cref="T:System.Exception">Error reading debug information from the PDB.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueMethodDebugInfoReader.Portable.TryGetCustomDebugInformation(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Guid,System.Reflection.Metadata.CustomDebugInformation@)">
            <exception cref="T:System.BadImageFormatException">Invalid data format.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueMethodDebugInfoReader.Create(Microsoft.DiaSymReader.ISymUnmanagedReader5,System.Int32)">
            <summary>
            Creates <see cref="T:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueMethodDebugInfoReader"/> backed by a given <see cref="T:Microsoft.DiaSymReader.ISymUnmanagedReader5"/>.
            </summary>
            <param name="symReader">SymReader open on a Portable or Windows PDB.</param>
            <param name="version">The version of the PDB to read.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="symReader"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="version"/> is less than 1.</exception>
            <exception cref="T:System.Runtime.InteropServices.COMException">Error reading debug information.</exception>
            <returns>
            The resulting reader does not take ownership of the <paramref name="symReader"/> or the memory it reads.
            </returns>
            <remarks>
            Automatically detects the underlying PDB format and returns the appropriate reader.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueMethodDebugInfoReader.Create(System.Reflection.Metadata.MetadataReader)">
            <summary>
            Creates <see cref="T:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueMethodDebugInfoReader"/> back by a given <see cref="T:System.Reflection.Metadata.MetadataReader"/>.
            </summary>
            <param name="pdbReader"><see cref="T:System.Reflection.Metadata.MetadataReader"/> open on a Portable PDB.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="pdbReader"/> is null.</exception>
            <returns>
            The resulting reader does not take ownership of the <paramref name="pdbReader"/> or the memory it reads.
            </returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueService">
            <summary>
            Implements core of Edit and Continue orchestration: management of edit sessions and connecting EnC related services.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueService._debuggingSessions">
            <summary>
            List of active debugging sessions (small number of simoultaneously active sessions is expected).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.EditSession.Capabilities">
            <summary>
            Gets the capabilities of the runtime with respect to applying code changes.
            Retrieved lazily from <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.DebuggingSession.DebuggerService"/> since they are only needed when changes are detected in the solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.EditSession.BaseActiveStatements">
            <summary>
            Map of base active statements.
            Calculated lazily based on info retrieved from <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.DebuggingSession.DebuggerService"/> since it is only needed when changes are detected in the solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.EditSession.Analyses">
            <summary>
            Cache of document EnC analyses.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.EditSession.InBreakState">
            <summary>
            True for Edit and Continue edit sessions - when the application is in break state.
            False for Hot Reload edit sessions - when the application is running.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.EditSession.GetUnsupportedChangesDiagnosticAsync(Microsoft.CodeAnalysis.Emit.EmitDifferenceResult,System.Threading.CancellationToken)">
            <summary>
            The compiler has various scenarios that will cause it to synthesize things that might not be covered
            by existing rude edits, but we still need to ensure the runtime supports them before we proceed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.EditSession.ReportModuleDiagnosticsAsync(System.Guid,Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.Project,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.EditAndContinue.DocumentAnalysisResults},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.Diagnostic},System.Threading.CancellationToken)">
            <summary>
            Errors to be reported when a project is updated but the corresponding module does not support EnC.
            </summary>
            <returns>Non-null diagnostic id if the module blocks EnC operation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.EditSession.GetChangedDocumentsAsync(Microsoft.CodeAnalysis.EditAndContinue.TraceLog,Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)">
            <summary>
            Enumerates <see cref="T:Microsoft.CodeAnalysis.DocumentId"/>s of changed (not added or removed) <see cref="T:Microsoft.CodeAnalysis.Document"/>s (not additional nor analyzer config).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.EmitSolutionUpdateResults.Solution">
             <summary>
             Solution snapshot to resolve diagnostics in.
             Note that this might be a different snapshot from the one passed to EmitSolutionUpdateAsync,
             with source generator files refreshed.
            
             Null only for empty results.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.EmitSolutionUpdateResults.Diagnostics">
            <summary>
            Reported diagnostics per project.
            At most one set of diagnostics per project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.EmitSolutionUpdateResults.ProjectsToRestart">
            <summary>
            Running projects that have to be restarted and a list of projects with rude edits that caused the restart.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.EmitSolutionUpdateResults.ProjectsToRebuild">
            <summary>
            Projects whose source have been updated and need to be rebuilt. Does not include projects without change that depend on such projects.
            It is assumed that the host automatically rebuilds all such projects that need rebuilding because it detects the dependent project outputs have been updated.
            Unordered set.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.EmitSolutionUpdateResults.GetProjectsToRebuildAndRestart(Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadUpdate},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.EditAndContinue.ProjectDiagnostics},System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.EditAndContinue.RunningProjectInfo},System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ProjectId}}@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ProjectId}@)">
            <summary>
            Returns projects that need to be rebuilt and/or restarted due to blocking rude edits in order to apply changes.
            </summary>
            <param name="runningProjects">Identifies projects that have been launched.</param>
            <param name="projectsToRestart">
            Running projects that have to be restarted and a list of projects with rude edits that caused the restart.
            </param>
            <param name="projectsToRebuild">
            Projects whose source have been updated and need to be rebuilt. Does not include projects without change that depend on such projects.
            It is assumed that the host automatically rebuilds all such projects that need rebuilding because it detects the dependent project outputs have been updated.
            Unordered set.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.EmitSolutionUpdateResults.GetTransientDiagnostics">
            <summary>
            Returns all diagnostics that can be addressed by rebuilding/restarting the project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.EmitSolutionUpdateResults.GetPersistentDiagnostics">
            <summary>
            Returns all diagnostics that can't be addressed by rebuilding/restarting the project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.IActiveStatementSpanFactory.GetBaseActiveStatementSpansAsync(Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DocumentId},System.Threading.CancellationToken)">
            <summary>
            Returns base mapped active statement spans contained in each specified document projected to a given solution snapshot
            (i.e. the solution snapshot the base active statements are current for could be different from the given <paramref name="solution"/>).
            </summary>
            <returns>
            <see langword="default"/> if called outside of an edit session.
            The length of the returned array matches the length of <paramref name="documentIds"/> otherwise.
            </returns>
            <remarks>
            The document may be any text document.
            <paramref name="documentIds"/> may not correspond to any document in the given <paramref name="solution"/> (an empty array of spans is returned for such document).
            Returns <see cref="T:Microsoft.CodeAnalysis.DocumentId"/> of the unmapped document containing the active statement (i.e. the document that has the #line directive mapping the statement to one of the specified <paramref name="documentIds"/>),
            or null the unmapped document has not been determined (the active statement has not changed from the baseline).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.IActiveStatementSpanFactory.GetAdjustedActiveStatementSpansAsync(Microsoft.CodeAnalysis.TextDocument,Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementSpanProvider,System.Threading.CancellationToken)">
            <summary>
            Returns adjusted active statements in the specified mapped <paramref name="document"/> snapshot.
            </summary>
            <returns>
            <see langword="default"/> if called outside of an edit session, or active statements for the document can't be determined for some reason
            (e.g. the document has syntax errors or is out-of-sync).
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.IActiveStatementSpanLocator.GetSpansAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.DocumentId,System.String,System.Threading.CancellationToken)">
            <summary>
            Returns current locations of the active statement tracking spans in the specified document snapshot (#line target document).
            </summary>
            <returns>Empty array if tracking spans are not available for the document.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.IEditAndContinueLogReporter">
            <summary>
            Exported by the host to provide additional logging for EnC operations.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.IEditAndContinueSessionTracker">
            <summary>
            Exposes EnC and Hot Reload session state to in-proc components.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.IEditAndContinueSessionTracker.IsSessionActive">
            <summary>
            True while Hot Reload or EnC session is active.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.IEditAndContinueSessionTracker.ApplyChangesDiagnostics">
            <summary>
            Diagnostics reported by the last <see cref="M:Microsoft.CodeAnalysis.EditAndContinue.IEditAndContinueService.EmitSolutionUpdateAsync(Microsoft.CodeAnalysis.EditAndContinue.DebuggingSessionId,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.EditAndContinue.RunningProjectInfo},Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementSpanProvider,System.Threading.CancellationToken)"/> call.
            Includes emit errors, project level errors, project level rude edits and issues reported by the debugger when applying changes.
            Does not include rude edits reported for added or changed documents, which are reported by <see cref="M:Microsoft.CodeAnalysis.EditAndContinue.IEditAndContinueService.GetDocumentDiagnosticsAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementSpanProvider,System.Threading.CancellationToken)"/>,
            Includes rude edits reported for deleted documents.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.LambdaBody.IsSyntaxEquivalentTo(Microsoft.CodeAnalysis.EditAndContinue.LambdaBody)">
            <summary>
            Determines if the bodies are syntactically same disregarding trivia differences.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.MemberBody.Envelope">
            <summary>
            A minimal span that contains all possible breakpoint spans of <see cref="T:Microsoft.CodeAnalysis.EditAndContinue.MemberBody"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.MemberBody.ContainsActiveStatementSpan(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            True if <paramref name="span"/> belongs to the <see cref="T:Microsoft.CodeAnalysis.EditAndContinue.MemberBody"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.MemberBody.IsExcludedActiveStatementSpanWithinEnvelope(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            True for <paramref name="span"/> within <see cref="P:Microsoft.CodeAnalysis.EditAndContinue.MemberBody.Envelope"/> does not belong to the body.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.MemberBody.GetActiveTokens(System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken}})">
            <summary>
            All tokens of the body that may be part of an active statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.MemberBody.GetUserCodeTokens(System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken}})">
            <summary>
            All tokens of the body representing user code. This may be empty sequence if the entire body is synthesized.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.MemberBody.FindStatementAndPartner(Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.EditAndContinue.MemberBody,Microsoft.CodeAnalysis.SyntaxNode@,System.Int32@)">
            <summary>
            Finds an active statement at given span within this body and the corresponding partner statement in 
            <paramref name="partnerDeclarationBody"/>, if specified. Only called with <paramref name="partnerDeclarationBody"/> when
            the body does not have any non-trivial changes and thus the correpsonding active statement is always found in the partner body.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.ModuleUpdateStatus">
            <summary>
            Indicates the state of a manage module update.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ModuleUpdateStatus.None">
            <summary>
            No change made.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ModuleUpdateStatus.Ready">
            <summary>
            Changes can be applied (project might need rebuild in presence of transient errors).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ModuleUpdateStatus.Blocked">
            <summary>
            Some changes are errors that block rebuild of the module.
            This means that the code is in a broken state that cannot be resolved by restarting the application.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.NonRemappableRegion.OldSpan">
            <summary>
            PDB span in pre-remap method version.
            </summary>
            <remarks>
            When a thread is executing in an old version of a method before it is remapped to the new version
            its active statement needs to be mapped from <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.NonRemappableRegion.OldSpan"/> in the old version 
            to <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.NonRemappableRegion.NewSpan"/> in the new version of the method.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.NonRemappableRegion.NewSpan">
            <summary>
            PDB span in the new method version.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.NonRemappableRegion.IsExceptionRegion">
            <summary>
            True if the region represents an exception region, false if it represents an active statement.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectAnalysisSummary.NoChanges">
            <summary>
            Project hasn't been changed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectAnalysisSummary.InvalidChanges">
            <summary>
            Project contains rude edits or a document whose analysis is blocked due to syntax error or rude edit in parse options.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectAnalysisSummary.ValidInsignificantChanges">
            <summary>
            The project only changed in comments, whitespaces, etc. that don't require compilation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectAnalysisSummary.ValidChanges">
            <summary>
            The project contains valid changes that require application of a delta.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectChanges.SemanticEdits">
            <summary>
            All semantic changes made in changed documents.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectChanges.LineChanges">
            <summary>
            All line changes made in changed documents.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectChanges.AddedSymbols">
            <summary>
            All symbols added in changed documents.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectChanges.ActiveStatementChanges">
            <summary>
            All active statements and the corresponding exception regions in changed documents.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectChanges.RequiredCapabilities">
            <summary>
            Runtime capabilities required to apply the changes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.Extensions.SupportsEditAndContinue(Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.EditAndContinue.TraceLog)">
            <summary>
            True if the project supports Edit and Continue.
            Only depends on the language of the project and never changes.
            
            Source generated files in the project must match the paths used by the compiler, otherwise
            different metadata might be emitted for file-scoped classes between compilation and EnC.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.Extensions.ProjectSettingsSupportEditAndContinue(Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.EditAndContinue.TraceLog)">
            <summary>
            True if project settings are compatible with Edit and Continue.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.Extensions.IsSynthesizedParameter(Microsoft.CodeAnalysis.IParameterSymbol)">
            <summary>
            True if the parameter is synthesized based on some other symbol (origin).
            In some cases <see cref="P:Microsoft.CodeAnalysis.ISymbol.IsImplicitlyDeclared"/> of parameters of synthezied methods might be false.
            The parameter syntax in these cases is associated with multiple symbols.
            We pick one that is considered the origin and the others are considered synthesized based on it.
            
            1) Parameter of a record deconstructor
               Considered synthesized since the primary parameter syntax represents the parameter of the primary constructor.
               The deconstructor is synthesized based on the primary constructor.
            2) Parameter of an Invoke method of a delegate type
               The Invoke method is synthesized but its parameters represent the parameters of the delegate.
               The parameters of BeginInvoke and EndInvoke are synthesized based on the Invoke method parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.Extensions.GetMatchingDeconstructor(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Returns a deconstructor that matches the parameters of the given <paramref name="constructor"/>, or null if there is none.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.Extensions.PartialAsImplementation(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns a partial implementation part of a partial member, or the member itself if it's not partial.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.Extensions.HasExplicitlyImplementedInterfaceMember(Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Returns true if any member of the type implements an interface member explicitly.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.ProjectDifferences">
            <summary>
            Differences between documents of old and new projects.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.ProjectDifferences.#ctor">
            <summary>
            Differences between documents of old and new projects.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.ProjectSettingKind">
            <summary>
            Represents project properties and items that impact parse options, compilation options and source file context interpretation.
            
            Project settings fall into following categories:
            1) Change requires restart. Error is reported.
               E.g. language version
               
            2) Change has no-effect until restart. Warning is reported if tracked by <see cref="T:Microsoft.CodeAnalysis.Project"/>.
               E.g. output type, platform, emit options
               Not all project settings are tracked by Roslyn. Only those that are are reported.
               If we want to enable auto-restart when a setting is changed we need to track it in <see cref="T:Microsoft.CodeAnalysis.Project"/>.
            
            5) Change has no effect on emitted IL/metadata, the effect is not observable to the application. Not reported.
               E.g. analyzer settings, allow unsafe, nullable, code page, delay sign, no warn, xml doc file, embedded sources, etc.
               
            The enum only includes settings from categories [1] and [2].
            The names of the enum members should match the corresponding msbuild property names.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectSettingKind.LangVersion">
            <summary>
            Error to avoid confusion and inconsistencies.
            If changed we would interpret changed syntax trees using one language version while unchanged would use another language version.
            We would also compile changed members using one version while unchanged would use another.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectSettingKind.Features">
            <summary>
            Error for the same reasons as <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectSettingKind.LangVersion"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectSettingKind.DefineConstants">
            <summary>
            Error for the same reasons as <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectSettingKind.LangVersion"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectSettingKind.CheckForOverflowUnderflow">
            <summary>
            Error for the same reasons as <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectSettingKind.LangVersion"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectSettingKind.OutputType">
            <summary>
            Warning since output type only affects entry point.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectSettingKind.StartupObject">
            <summary>
            Warning.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectSettingKind.ModuleAssemblyName">
            <summary>
            Error, need to preserve the module name.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectSettingKind.AssemblyName">
            <summary>
            Error, need to preserve the assembly name.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectSettingKind.Platform">
            <summary>
            Warning, can't be changed without restarting the application but not blocking.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectSettingKind.OptimizationLevel">
            <summary>
            Must be <see cref="F:Microsoft.CodeAnalysis.OptimizationLevel.Debug"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.ProjectSettingKind.RootNamespace">
            <summary>
            Error. Can't change namespace of existing types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementSpanProviderCallback.GetSpansAsync(Microsoft.CodeAnalysis.DocumentId,System.String,System.Threading.CancellationToken)">
            <summary>
            Remote API.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.IRemoteEditAndContinueService.CommitSolutionUpdateAsync(Microsoft.CodeAnalysis.EditAndContinue.DebuggingSessionId,System.Threading.CancellationToken)">
            <summary>
            Returns ids of documents for which diagnostics need to be refreshed in-proc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.IRemoteEditAndContinueService.BreakStateOrCapabilitiesChangedAsync(Microsoft.CodeAnalysis.EditAndContinue.DebuggingSessionId,System.Nullable{System.Boolean},System.Threading.CancellationToken)">
            <summary>
            Returns ids of documents for which diagnostics need to be refreshed in-proc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.IRemoteEditAndContinueService.EndDebuggingSessionAsync(Microsoft.CodeAnalysis.EditAndContinue.DebuggingSessionId,System.Threading.CancellationToken)">
            <summary>
            Returns ids of documents for which diagnostics need to be refreshed in-proc.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.RemoteEditAndContinueServiceProxy">
            <summary>
            Facade used to call remote <see cref="T:Microsoft.CodeAnalysis.EditAndContinue.IRemoteEditAndContinueService"/> methods.
            Encapsulates all RPC logic as well as dispatching to the local service if the remote service is disabled.
            THe facade is useful for targeted testing of serialization/deserialization of EnC service calls.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.RemoteEditAndContinueServiceProxy.#ctor(Microsoft.CodeAnalysis.Host.SolutionServices)">
            <summary>
            Facade used to call remote <see cref="T:Microsoft.CodeAnalysis.EditAndContinue.IRemoteEditAndContinueService"/> methods.
            Encapsulates all RPC logic as well as dispatching to the local service if the remote service is disabled.
            THe facade is useful for targeted testing of serialization/deserialization of EnC service calls.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.RudeEditDiagnostic.Span">
            <summary>
            Span in the new document. May be <c>default</c> if the document (or its entire content) has been deleted.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.RudeEditDiagnosticsBuilder.DeferredDiagnostics">
            <summary>
            Diagnostics that are only reported after after completing the analysis.
            These diagnostics might be reported or discarded based on the results of the analysis.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.RudeEditKind">
            <summary>
            Diagnostics reported by <see cref="T:Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.RudeEditReportingCondition.ReportWhenSymbolIsActive">
            <summary>
            True to report the diagnostic when <see cref="P:Microsoft.CodeAnalysis.EditAndContinue.RudeEditReportingCondition.OldSymbol"/> is active.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.RunningProjectInfo.RestartWhenChangesHaveNoEffect">
            <summary>
            Required restart of the project when an edit that has no effect until the app is restarted is made to any dependent project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.RunningProjectInfo.AllowPartialUpdate">
            <summary>
            TODO: remove when implemented: https://github.com/dotnet/roslyn/issues/78244
            Indicates that the info has been passed from debugger.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditAndContinue.SyntaxMaps.NewTree">
            <summary>
            The tree the maps operate on (the new tree, since the maps are mapping from new nodes to old nodes/rude edits).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.SemanticEditInfo.Kind">
            <summary>
            <see cref="F:Microsoft.CodeAnalysis.Emit.SemanticEditKind.Insert"/> or <see cref="F:Microsoft.CodeAnalysis.Emit.SemanticEditKind.Update"/> or <see cref="F:Microsoft.CodeAnalysis.Emit.SemanticEditKind.Delete"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.SemanticEditInfo.Symbol">
            <summary>
            If <see cref="P:Microsoft.CodeAnalysis.EditAndContinue.SemanticEditInfo.Kind"/> is <see cref="F:Microsoft.CodeAnalysis.Emit.SemanticEditKind.Insert"/> represents the inserted symbol in the new compilation.
            If <see cref="P:Microsoft.CodeAnalysis.EditAndContinue.SemanticEditInfo.Kind"/> is <see cref="F:Microsoft.CodeAnalysis.Emit.SemanticEditKind.Update"/> represents the updated symbol in both compilations.
            If <see cref="P:Microsoft.CodeAnalysis.EditAndContinue.SemanticEditInfo.Kind"/> is <see cref="F:Microsoft.CodeAnalysis.Emit.SemanticEditKind.Delete"/> represents the deleted symbol in the old compilation.
            
            We use <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/> to represent the symbol rather then <see cref="T:Microsoft.CodeAnalysis.ISymbol"/>,
            since different semantic edits might have been calculated against different solution snapshot and thus symbols are not directly comparable.
            When the edits are processed we map the <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/> to the current compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.SemanticEditInfo.DeletedSymbolContainer">
            <summary>
            If <see cref="P:Microsoft.CodeAnalysis.EditAndContinue.SemanticEditInfo.Kind"/> is <see cref="F:Microsoft.CodeAnalysis.Emit.SemanticEditKind.Delete"/> represents the containing symbol in the new compilation.
            
            We use <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/> to represent the symbol rather then <see cref="T:Microsoft.CodeAnalysis.ISymbol"/>,
            since different semantic edits might have been calculated against different solution snapshot and thus symbols are not directly comparable.
            When the edits are processed we map the <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/> to the current compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.SemanticEditInfo.SyntaxMaps">
            <summary>
            Syntax maps for nodes in the tree for this edit, which will be merged with other maps from other trees for this type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.SemanticEditInfo.PartialType">
            <summary>
            Specified if the edit needs to be merged with other edits of the same <see cref="P:Microsoft.CodeAnalysis.EditAndContinue.SemanticEditInfo.PartialType"/>.
            
            If specified, the <see cref="P:Microsoft.CodeAnalysis.EditAndContinue.SemanticEditInfo.SyntaxMaps"/> is either null or incomplete: it only provides mapping of the changed members of a single partial type declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.SolutionSnapshotRegistry.RegisterSolutionSnapshot(Microsoft.CodeAnalysis.Solution)">
            <summary>
            Called from LSP server.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.SourceFileSpan">
            <summary>
            Represents a span of text in a source code file in terms of file name, line number, and offset within line.
            An alternative for <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan"/> without <see cref="P:Microsoft.CodeAnalysis.FileLinePositionSpan.HasMappedPath"/> bit.
            </summary>
            <remarks>
            Initializes the <see cref="T:Microsoft.CodeAnalysis.EditAndContinue.SourceFileSpan"/> instance.
            </remarks>
            <param name="path">The file identifier - typically a relative or absolute path.</param>
            <param name="span">The span.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.SourceFileSpan.#ctor(System.String,Microsoft.CodeAnalysis.Text.LinePositionSpan)">
            <summary>
            Represents a span of text in a source code file in terms of file name, line number, and offset within line.
            An alternative for <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan"/> without <see cref="P:Microsoft.CodeAnalysis.FileLinePositionSpan.HasMappedPath"/> bit.
            </summary>
            <remarks>
            Initializes the <see cref="T:Microsoft.CodeAnalysis.EditAndContinue.SourceFileSpan"/> instance.
            </remarks>
            <param name="path">The file identifier - typically a relative or absolute path.</param>
            <param name="span">The span.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.SourceFileSpan.Path">
            <summary>
            Path, or null if the span represents an invalid value.
            </summary>
            <remarks>
            Path may be <see cref="F:System.String.Empty"/> if not available.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.SourceFileSpan.Span">
            <summary>
            Gets the span.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.SourceFileSpan.IsValid">
            <summary>
            Returns true if the span represents a valid location.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.SourceFileSpan.Start">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Text.LinePosition"/> of the start of the span.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.SourceFileSpan.End">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Text.LinePosition"/> of the end of the span.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.StateMachineInfo">
            <summary>
            Describes a method, lambda or local function that generates a state machine.
            </summary>
            <param name="IsAsync">
            If the method is marked as async and generates a state machine.
            Method marked with async keyword in C# and VB generates a state machine even if it doesn't have any await expressions (<paramref name="HasSuspensionPoints"/> is false).
            </param>
            <param name="IsIterator">
            If the method is marked as iterator and generates a state machine.
            In C# an (async) iterator method must have a yield statement (<paramref name="IsIterator"/> is true, <paramref name="HasSuspensionPoints"/> is true).
            In VB a method without a Yield statement can be marked as an Iterator (<paramref name="IsIterator"/> is true, <paramref name="HasSuspensionPoints"/> may be false).
            </param>
            <param name="HasSuspensionPoints">
            True if any awaits and/or yields are present in the method.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.StateMachineInfo.#ctor(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Describes a method, lambda or local function that generates a state machine.
            </summary>
            <param name="IsAsync">
            If the method is marked as async and generates a state machine.
            Method marked with async keyword in C# and VB generates a state machine even if it doesn't have any await expressions (<paramref name="HasSuspensionPoints"/> is false).
            </param>
            <param name="IsIterator">
            If the method is marked as iterator and generates a state machine.
            In C# an (async) iterator method must have a yield statement (<paramref name="IsIterator"/> is true, <paramref name="HasSuspensionPoints"/> is true).
            In VB a method without a Yield statement can be marked as an Iterator (<paramref name="IsIterator"/> is true, <paramref name="HasSuspensionPoints"/> may be false).
            </param>
            <param name="HasSuspensionPoints">
            True if any awaits and/or yields are present in the method.
            </param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.StateMachineInfo.IsAsync">
            <summary>
            If the method is marked as async and generates a state machine.
            Method marked with async keyword in C# and VB generates a state machine even if it doesn't have any await expressions (<paramref name="HasSuspensionPoints"/> is false).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.StateMachineInfo.IsIterator">
            <summary>
            If the method is marked as iterator and generates a state machine.
            In C# an (async) iterator method must have a yield statement (<paramref name="IsIterator"/> is true, <paramref name="HasSuspensionPoints"/> is true).
            In VB a method without a Yield statement can be marked as an Iterator (<paramref name="IsIterator"/> is true, <paramref name="HasSuspensionPoints"/> may be false).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.StateMachineInfo.HasSuspensionPoints">
            <summary>
            True if any awaits and/or yields are present in the method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.StateMachineInfo.IsStateMachine">
            <summary>
            True if a state machine is generated.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditAndContinue.TraceLog">
            <summary>
            Implements EnC logging.
            
            Writes log messages to:
            - fixed size rolling tracing log captured in a memory dump,
            - a file log, if a log directory is provided,
            - log service, if avaiable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditAndContinue.TraceLog.#ctor(System.String,Microsoft.CodeAnalysis.EditAndContinue.IEditAndContinueLogReporter,System.Int32)">
            <summary>
            Implements EnC logging.
            
            Writes log messages to:
            - fixed size rolling tracing log captured in a memory dump,
            - a file log, if a log directory is provided,
            - log service, if avaiable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.UnmappedActiveStatement.UnmappedSpan">
            <summary>
            Unmapped span of the active statement
            (span within the file that contains #line directive that has an effect on the active statement, if there is any).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.UnmappedActiveStatement.Statement">
            <summary>
            Active statement - its <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement.FileSpan"/> is mapped.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditAndContinue.UnmappedActiveStatement.ExceptionRegions">
            <summary>
            Mapped exception regions around the active statement.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.AbstractEmbeddedLanguageFeatureService`1.SyntaxTokenKinds">
            <summary>
            The kinds of literal tokens that we want to do embedded language work for.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.AbstractEmbeddedLanguageFeatureService`1._legacyServices">
            <summary>
            Services that can annotated older APIs not updated to use the [StringSyntax] attribute.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.AbstractEmbeddedLanguageFeatureService`1._identifierToServices">
            <summary>
            Ordered mapping of a lang ID (like 'Json') to all the services for that language. This allows for multiple
            classifiers to be available.  The first service though that returns results for a string will 'win' and no
            other services will contribute.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.AbstractEmbeddedLanguageFeatureService`1.Info">
            <summary>
            Information about the embedded language.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.AbstractEmbeddedLanguageFeatureService`1._detector">
            <summary>
            Helper to look at string literals and determine what language they are annotated to take.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.AbstractEmbeddedLanguagesProvider">
            <summary>
            Abstract implementation of the C# and VB embedded language providers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.AbstractEmbeddedLanguagesProvider.EscapeText(System.String,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Escapes <paramref name="text"/> appropriately so it can be inserted into 
            <paramref name="token"/>.  For example if inserting `\p{Number}` into a normal C#
            string token, the `\` would have to be escaped into `\\`.  However in a verbatim-string
            literal (i.e. `@"..."`) it would not have to be escaped.
            </summary>
            <param name="token">The original string token that <paramref name="text"/> is being
            inserted into.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.EmbeddedLanguageCommentDetector">
            <summary>
            Helps match patterns of the form: language=name,option1,option2,option3
            <para/>
            All matching is case insensitive, with spaces allowed between the punctuation. Option values are
            returned as strings.
            <para/>
            Option names are the values from the TOptions enum.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.EmbeddedLanguageCommentOptions`1">
            <summary>
            Helps match patterns of the form: language=name,option1,option2,option3
            <para/>
            All matching is case insensitive, with spaces allowed between the punctuation. Option values will be or'ed
            together to produce final options value.  If an unknown option is encountered, processing will stop with
            whatever value has accumulated so far.
            <para/>
            Option names are the values from the TOptions enum.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.EmbeddedLanguageDetector.IsEmbeddedLanguageToken(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SemanticModel,System.Threading.CancellationToken,System.String@,System.Collections.Generic.IEnumerable{System.String}@)">
            <summary>
            Determines if <paramref name="token"/> is an embedded language token.  If the token is, the specific
            language indicated will be returned in <paramref name="identifier"/>.  If the token was annotated with a
            <c>// lang=id</c> comment, then options present in the comment (e.g. <c>// lang=id,opt1,opt2,...</c> will be
            returned through <paramref name="options"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.EmbeddedLanguageDetector.IsEmbeddedLanguageStringLiteralToken_Direct(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SemanticModel,System.Threading.CancellationToken,System.String@)">
            <summary>
            Checks for a string literal <em>directly</em> used in a location we can tell is controlled by a
            <c>[StringSyntax]</c> attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EmbeddedLanguages.EmbeddedLanguageMetadata.Identifiers">
            <summary>
            The particular language-IDs this language supports (for example 'regex/regexp/etc.').
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EmbeddedLanguages.EmbeddedLanguageMetadata.SupportsUnannotatedAPIs">
            <summary>
            If this language supports strings being passed to APIs that do not have a <c>// lang=...</c> comment or a
            <c>[StringSyntax]</c> attribute on them.  This is not exposed publicly as all modern language plugins should
            use those mechanisms.  This is for Regex/Json to support lighting up on older platform APIs that shipped
            before this IDE capability and thus were never annotated.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.ExportEmbeddedLanguageFeatureServiceAttribute">
            <summary>
            Use this attribute to export an <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.IEmbeddedLanguageFeatureService"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EmbeddedLanguages.ExportEmbeddedLanguageFeatureServiceAttribute.Name">
            <summary>
            Name of the classifier.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EmbeddedLanguages.ExportEmbeddedLanguageFeatureServiceAttribute.Languages">
            <summary>
            Names of the containing language hosting the embedded language.  e.g. C# or VB.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EmbeddedLanguages.ExportEmbeddedLanguageFeatureServiceAttribute.Identifiers">
            <summary>
            Identifiers in code (or StringSyntaxAttribute) used to identify an embedded language string. For example
            <c>Regex</c> or <c>Json</c>.
            </summary>
            <remarks>This can be used to find usages of an embedded language using a comment marker like <c>//
            lang=regex</c> or passed to a symbol annotated with <c>[StringSyntaxAttribyte("Regex")]</c>.  The identifier
            is case sensitive for the StringSyntaxAttribute, and case insensitive for the comment.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EmbeddedLanguages.ExportEmbeddedLanguageFeatureServiceAttribute.SupportsUnannotatedAPIs">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.EmbeddedLanguages.EmbeddedLanguageMetadata.SupportsUnannotatedAPIs"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.IEmbeddedLanguage">
            <summary>
            Services related to a specific embedded language.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EmbeddedLanguages.IEmbeddedLanguage.CompletionProvider">
            <summary>
            Completion provider that can provide completion items for this
            specific embedded language.
            
            <see cref="T:Microsoft.CodeAnalysis.Completion.Providers.AbstractAggregateEmbeddedLanguageCompletionProvider"/> will aggregate all these
            individual providers and expose them as one single completion provider to
            the rest of Roslyn.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.IEmbeddedLanguageFeatureService">
            <summary>
            Marker interface for services that handle features for embedded languages.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.IEmbeddedLanguagesProvider">
            <summary>
            Service that returns all the embedded languages supported.  Each embedded language can expose
            individual language services through the <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.IEmbeddedLanguage"/> interface.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCharClass">
            <summary>
            Minimal copy of https://github.com/dotnet/corefx/blob/main/src/System.Text.RegularExpressions/src/System/Text/RegularExpressions/RegexCharClass.cs
            Used to accurately determine if something is a WordChar according to the .NET regex engine.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexHelpers.MapEscapeChar(Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar)">
            <summary>
            Maps an escaped character to the actual character it was escaping.  For something like
            'a' this will map to actual '\a' char (the bell character).  However, for something like
            '(' this will just map to '(' as that's all that \( does in a regex.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexLexer">
             <summary>
             Produces tokens from the sequence of <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar"/> characters.  Unlike the
             native C# and VB lexer, this lexer is much more tightly controlled by the parser.  For
             example, while C# can have trivia on virtual every token, the same is not true for
             RegexTokens.  As such, instead of automatically lexing out tokens to make them available for
             the parser, the parser asks for each token as necessary passing the right information to
             indicate which types and shapes of tokens are allowed.
            
             The tight coupling means that the parser is allowed direct control of the position of the
             lexer.
            
             Note: most of the time, tokens returned are just a single character long, including for long
             sequences of text characters (like ```"goo"```).  This is just three <see
             cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexTextNode"/>s in a row (each containing a <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind.TextToken"/> a
             single character long).
            
             There are multi-character tokens though.  For example ```10``` in ```a{10,}``` or ```name```
             in ```\k'name'```
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexSequenceNode">
            <summary>
            Represents a possibly-empty sequence of regex expressions.  For example, the regex ""
            will produce an empty RegexSequence nodes, and "a|" will produce an alternation with an
            empty sequence on the right side.  Having a node represent the empty sequence is actually
            appropriate as these are legal regexes and the empty sequence represents 'a pattern
            that will match any position'.  Not having a node for this would actually end up 
            complicating things in terms of dealing with nulls in the tree.
            
            This does not deviate from Roslyn principles.  While nodes for empty text are rare, they
            are allowed (for example, OmittedTypeArgument in C#).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexSequenceNode.#ctor(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexExpressionNode})">
            <summary>
            Represents a possibly-empty sequence of regex expressions.  For example, the regex ""
            will produce an empty RegexSequence nodes, and "a|" will produce an alternation with an
            empty sequence on the right side.  Having a node represent the empty sequence is actually
            appropriate as these are legal regexes and the empty sequence represents 'a pattern
            that will match any position'.  Not having a node for this would actually end up 
            complicating things in terms of dealing with nulls in the tree.
            
            This does not deviate from Roslyn principles.  While nodes for empty text are rare, they
            are allowed (for example, OmittedTypeArgument in C#).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexTextNode">
            <summary>
            Represents a chunk of text (usually just a single char) from the original pattern.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexBaseCharacterClassNode">
            <summary>
            Base type for [...] and [^...] character classes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCharacterClassNode">
            <summary>
            [...] node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCharacterClassNode.#ctor(Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind},Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexSequenceNode,Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind})">
            <summary>
            [...] node.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexNegatedCharacterClassNode">
            <summary>
            [^...] node
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCharacterClassRangeNode">
            <summary>
            ```a-z``` node in a character class.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCharacterClassSubtractionNode">
            <summary>
            ```-[f-m]``` in a pattern like ```[a-z-[f-m]]```.  A subtraction must come last in a 
            character class, and removes some range of chars from the character class built up
            so far.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexExpressionNode">
            <summary>
            Root of all expression nodes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexPrimaryExpressionNode">
            <summary>
            Root of all the primary nodes (similar to unary nodes in C#).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexWildcardNode">
            <summary>
            A ```.``` expression.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexQuantifierNode">
            <summary>
            Root of all quantifier nodes: ```?```, ```*``` etc.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexZeroOrMoreQuantifierNode">
            <summary>
            ```expr*```
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexOneOrMoreQuantifierNode">
            <summary>
            ```expr+```
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexZeroOrOneQuantifierNode">
            <summary>
            ```expr?```
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexLazyQuantifierNode">
            <summary>
            Quantifiers can be optionally followed by a ? to make them lazy.  i.e. ```a*?``` or ```a+?```.
            You can even have ```a??```  (zero or one 'a', lazy).  However, only one lazy modifier is allowed
            ```a*??``` or ```a???``` is not allowed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexNumericQuantifierNode">
            <summary>
            Base type of all regex numeric quantifier nodes.  i.e.  
            ```a{5}```,  ```a{5,}``` and ```a{5,10}```
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexExactNumericQuantifierNode">
            <summary>
            ```a{5}```
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexExactNumericQuantifierNode.#ctor(Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexPrimaryExpressionNode,Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind},Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind},Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind})">
            <summary>
            ```a{5}```
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexOpenNumericRangeQuantifierNode">
            <summary>
            ```a{5,}```
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexClosedNumericRangeQuantifierNode">
            <summary>
            ```a{5,10}```
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexAnchorNode">
            <summary>
            ```$``` or ```^```.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexAlternationNode">
            <summary>
            ```expr1|expr2``` node.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexGroupingNode">
            <summary>
            Base type of all non-trivia ```(...)``` nodes
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexSimpleGroupingNode">
            <summary>
            The ```(...)``` node you get when the group does not start with ```(?```
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexQuestionGroupingNode">
            <summary>
            Base type of all ```(?...)``` groupings.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexOptionsGroupingNode">
            <summary>
            Base type of ```(?inmsx)``` or ```(?inmsx:...)``` nodes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexSimpleOptionsGroupingNode">
            <summary>
            ```(?inmsx)``` node.  Changes options in a sequence for all subsequence nodes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexSimpleOptionsGroupingNode.#ctor(Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind},Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind},Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind},Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind})">
            <summary>
            ```(?inmsx)``` node.  Changes options in a sequence for all subsequence nodes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexNestedOptionsGroupingNode">
            <summary>
            ```(?inmsx:expr)``` node.  Changes options for the parsing of 'expr'.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexNonCapturingGroupingNode">
            <summary>
            ```(?:expr)``` node.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexPositiveLookaheadGroupingNode">
            <summary>
            ```(?=expr)``` node.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexNegativeLookaheadGroupingNode">
            <summary>
            ```(?!expr)``` node.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexPositiveLookbehindGroupingNode">
            <summary>
            ```(?&lt;=expr)``` node.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexNegativeLookbehindGroupingNode">
            <summary>
            ```(?&lt;!expr)``` node.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexAtomicGroupingNode">
            <summary>
            ```(?&gt;expr)``` node.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCaptureGroupingNode">
            <summary>
            ```(?'name'expr)``` or ```(?&lt;name&gt;expr)``` node.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexBalancingGroupingNode">
            <summary>
            ```(?'name1-name2'expr)``` or ```(?&lt;name1-name2&gt;expr)``` node.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexConditionalCaptureGroupingNode">
            <summary>
            ```(?(capture_name)result)```
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexConditionalExpressionGroupingNode">
            <summary>
            ```(?(group)result)```
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexEscapeNode">
            <summary>
            Base type of all regex primitives that start with \
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexTypeEscapeNode">
            <summary>
            Base type of all regex escapes that start with \ and some informative character (like \v \t \c etc.).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexSimpleEscapeNode">
            <summary>
            A basic escape that just has \ and one additional character and needs no further information.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexAnchorEscapeNode">
            <summary>
            One of \b \B \A \G \z \Z
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexAnchorEscapeNode.#ctor(Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind},Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind})">
            <summary>
            One of \b \B \A \G \z \Z
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCharacterClassEscapeNode">
            <summary>
            One of \s \S \d \D \w \W
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCharacterClassEscapeNode.#ctor(Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind},Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind})">
            <summary>
            One of \s \S \d \D \w \W
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexControlEscapeNode">
            <summary>
            ```\cX``` escape
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexControlEscapeNode.#ctor(Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind},Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind},Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind})">
            <summary>
            ```\cX``` escape
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexHexEscapeNode">
            <summary>
            ```\xFF``` escape.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexHexEscapeNode.#ctor(Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind},Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind},Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind})">
            <summary>
            ```\xFF``` escape.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexUnicodeEscapeNode">
            <summary>
            ```\uFFFF``` escape.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexUnicodeEscapeNode.#ctor(Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind},Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind},Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind})">
            <summary>
            ```\uFFFF``` escape.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCaptureEscapeNode">
            <summary>
            ```\'name'``` or ```\&lt;name&gt;``` escape.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCaptureEscapeNode.#ctor(Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind},Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind},Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind},Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind})">
            <summary>
            ```\'name'``` or ```\&lt;name&gt;``` escape.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKCaptureEscapeNode">
            <summary>
            ```\k'name'``` or ```\k&lt;name&gt;``` escape.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKCaptureEscapeNode.#ctor(Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind},Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind},Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind},Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind},Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind})">
            <summary>
            ```\k'name'``` or ```\k&lt;name&gt;``` escape.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexOctalEscapeNode">
            <summary>
            ```\1``` escape. In contexts where back-references are not allowed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexOctalEscapeNode.#ctor(Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind},Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind})">
            <summary>
            ```\1``` escape. In contexts where back-references are not allowed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexBackreferenceEscapeNode">
            <summary>
            ```\1```
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexBackreferenceEscapeNode.#ctor(Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind},Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind})">
            <summary>
            ```\1```
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCategoryEscapeNode">
            <summary>
            ```\p{...}```
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexParser">
             <summary>
             Produces a <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexTree"/> from a sequence of <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar"/> characters.
            
             Importantly, this parser attempts to replicate diagnostics with almost the exact same text
             as the native .NET regex parser.  This is important so that users get an understandable
             experience where it appears to them that this is all one cohesive system and that the IDE
             will let them discover and fix the same issues they would encounter when previously trying
             to just compile and execute these regexes.
             </summary>
             <remarks>
             Invariants we try to maintain (and should consider a bug if we do not): l 1. If the .NET
             regex parser does not report an error for a given pattern, we should not either. it would be
             very bad if we told the user there was something wrong with there pattern when there really
             wasn't.
            
             2. If the .NET regex parser does report an error for a given pattern, we should either not
             report an error (not recommended) or report the same error at an appropriate location in the
             pattern.  Not reporting the error can be confusing as the user will think their pattern is
             ok, when it really is not.  However, it can be acceptable to do this as it's not telling
             them that something is actually wrong, and it may be too difficult to find and report the
             same error.  Note: there is only one time we do this in this parser (see the deviation
             documented in <see cref="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexParser.ParsePossibleEcmascriptBackreferenceEscape(Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind},System.Boolean)"/>).
            
             Note1: "report the same error" means that we will attempt to report the error using the same
             text the .NET regex parser uses for its error messages.  This is so that the user is not
             confused when they use the IDE vs running the regex by getting different messages for the
             same issue.
            
             Note2: the above invariants make life difficult at times.  This happens due to the fact that
             the .NET parser is multi-pass.  Meaning it does a first scan (which may report errors), then
             does the full parse.  This means that it might report an error in a later location during
             the initial scan than it would during the parse.  We replicate that behavior to follow the
             second invariant.
            
             Note3: It would be nice if we could check these invariants at runtime, so we could control
             our behavior by the behavior of the real .NET regex engine.  For example, if the .NET regex
             engine did not report any issues, we could suppress any diagnostics we generated and we
             could log an NFW to record which pattern we deviated on so we could fix the issue for a
             future release.  However, we cannot do this as the .NET regex engine has no guarantees about
             its performance characteristics.  For example, certain regex patterns might end up causing
             that engine to consume unbounded amounts of CPU and memory.  This is because the .NET regex
             engine is not just a parser, but something that builds an actual recognizer using techniques
             that are not necessarily bounded.  As such, while we test ourselves around it during our
             tests, we cannot do the same at runtime as part of the IDE.
            
             This parser was based off the corefx RegexParser based at:
             https://github.com/dotnet/corefx/blob/f759243d724f462da0bcef54e86588f8a55352c6/src/System.Text.RegularExpressions/src/System/Text/RegularExpressions/RegexParser.cs#L1
            
             Note4: The .NET parser itself changes over time (for example to fix behavior that even it
             thinks is buggy).  When this happens, we have to make a choice as to which behavior to
             follow. In general, the overall principle is that we should follow the more lenient
             behavior.  If we end up taking the more strict interpretation we risk giving people an error
             during design time that they would not get at runtime.  It's far worse to have that than to
             not report an error, even though one might happen later.
             </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexParser.CaptureInfoAnalyzer">
            <summary>
            Analyzes the first parsed tree to determine the set of capture numbers and names.  These are
            then used to do the second parsing pass as they can change how the regex engine interprets
            some parts of the pattern (though not the groups themselves).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexParser.CaptureInfoAnalyzer.AssignNumbersToCaptureNames">
            <summary>
            Give numbers to all named captures.  They will get successive <see
            cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexParser.CaptureInfoAnalyzer._autoNumber"/> values that have not already been handed out to existing
            numbered capture groups.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexParser.ConsumeCurrentToken(System.Boolean)">
            <summary>
            Returns the latest token the lexer has produced, and then asks the lexer to 
            produce the next token after that.
            </summary>
            <param name="allowTrivia">Whether or not trivia is allowed on the next token
            produced.  In the .NET parser trivia is only allowed on a few constructs,
            and our parser mimics that behavior.  Note that even if trivia is allowed,
            the type of trivia that can be scanned depends on the current RegexOptions.
            For example, if <see cref="F:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace"/> is currently
            enabled, then '#...' comments are allowed.  Otherwise, only '(?#...)' comments
            are allowed.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexParser.TryParse(Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence,System.Text.RegularExpressions.RegexOptions)">
            <summary>
            Given an input text, and set of options, parses out a fully representative syntax tree 
            and list of diagnostics.  Parsing should always succeed, except in the case of the stack 
            overflowing.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexParser.AddUniqueDiagnostics(System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedDiagnostic},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedDiagnostic},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedDiagnostic})">
            <summary>
            It's very common to have duplicated diagnostics.  For example, consider "((". This will
            have two 'missing )' diagnostics, both at the end.  Reporting both isn't helpful, so we
            filter duplicates out here.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexParser.ParseAlternatingSequencesWorker(System.Boolean,System.Boolean)">
             <summary>
             Parses out code of the form: ...|...|... This is the type of code you have at the top level of a regex, or
             inside any grouping construct.  Note that sequences can be empty in .NET regex.  i.e. the following is
             legal:
            
                 ...||...
            
             An empty sequence just means "match at every position in the test string".
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexParser.ParseEscape(Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind},System.Boolean)">
            <summary>
            Parses out an escape sequence.  Escape sequences are allowed in top level sequences
            and in character classes.  In a top level sequence trivia will be allowed afterwards,
            but in a character class trivia is not allowed afterwards.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameCompilationUnit">
            <summary>
            The root unit for a stackframe. Includes the method declaration for the stack frame and optional file information. 
            Any leading "at " is considered trivia of <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameCompilationUnit.MethodDeclaration"/>, and " in " is put as trivia for the <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameCompilationUnit.FileInformationExpression"/>.
            Remaining unparsable text is put as leading trivia on the <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameCompilationUnit.EndOfLineToken"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameCompilationUnit.#ctor(Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameMethodDeclarationNode,Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameFileInformationNode,Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameKind})">
            <summary>
            The root unit for a stackframe. Includes the method declaration for the stack frame and optional file information. 
            Any leading "at " is considered trivia of <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameCompilationUnit.MethodDeclaration"/>, and " in " is put as trivia for the <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameCompilationUnit.FileInformationExpression"/>.
            Remaining unparsable text is put as leading trivia on the <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameCompilationUnit.EndOfLineToken"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameCompilationUnit.MethodDeclaration">
            <summary>
            Represents the method declaration for a stack frame. Requires at least a member 
            access and argument list with no parameters to be considered valid
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameCompilationUnit.FileInformationExpression">
            <summary>
            File information for a stack frame. May be optionally contained. If available, represents
            the file path of a stackframe and optionally the line number. This is available as hint information
            and may be useful for a user, but is not always accurate when mapping back to source.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameCompilationUnit.EndOfLineToken">
            <summary>
            The end token of a frame. Any trailing text is added as leading trivia of this token.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameExtensions.ToImmutableArray(System.Nullable{Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxTrivia{Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameKind}})">
            <summary>
            Creates an <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> with a single value or empty 
            if the <paramref name="trivia"/> has no value
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameExtensions.ToImmutableArray(Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxTrivia{Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameKind})">
            <summary>
            Creates an <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> with a single trivia item in it
            </summary>
            <remarks>
            This is created for convenience so callers don't have to have different patterns between nullable and 
            non nullable calues
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameLexer.ScanCurrentCharAsTokenIfMatch(Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameKind,Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameKind}@)">
            <summary>
            Progress the position by one if the current character
            matches the kind.
            </summary>
            <returns>
            <see langword="true"/> if the position was incremented
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameLexer.ScanCurrentCharAsTokenIfMatch(Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameKind,System.Boolean,Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameKind}@)">
            <summary>
            Progress the position by one if the current character
            matches the kind.
            </summary>
            <returns>
            <see langword="true"/> if the position was incremented
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameLexer.ScanCurrentCharAsTokenIfMatch(System.Func{Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameKind,System.Boolean},Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameKind}@)">
            <summary>
            Progress the position by one if the current character
            matches the kind.
            </summary>
            <returns>
            <see langword="true"/> if the position was incremented
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameLexer.TryScanPath">
            <summary>
            Attempts to parse <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameKind.InTrivia"/> and a path following https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file#file-and-directory-names
            Uses <see cref="T:System.IO.FileInfo"/> as a tool to determine if the path is correct for returning. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameLexer.TryScanRequiredLineNumber">
            <summary>
            Returns a number token with the <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameKind.LineTrivia"/> and remaining <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameKind.SkippedTextTrivia"/>
            attached to it. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameLexer.TryScanRequiredGeneratedNameSeparator">
            <summary>
            Scans a form similar to g__, where g is a GeneratedNameKind (a single character)
            and identifier is valid identifier characters as with <see cref="M:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameLexer.TryScanIdentifier"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameLexer.TryScanRequiredGeneratedNameSuffix">
            <summary>
            In a generated name for local functions the final portion is {numeric}_{numeric}
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameLexer.TryScanConstructor">
            <summary>
            Scans for .ctor or .cctor as a ConstructorToken
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameTypeNode">
            <summary>
            Base class for all type nodes
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameNameNode">
            <summary>
            Base class for all name nodes
            </summary>
            <remarks>
            All of these are <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameTypeNode" />. If a node requires an identifier or name that 
            is not a type then it should use <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken`1"/> with <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameKind.IdentifierToken"/>
            directly.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameSimpleNameNode">
            <summary>
            Base class for <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameIdentifierNameNode"/> and <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameGenericNameNode"/>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameQualifiedNameNode">
            <summary>
            Represents a qualified name, such as "MyClass.MyMethod"
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameIdentifierNameNode">
            <summary>
            The simplest identifier node, which wraps a <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameKind.IdentifierToken" />
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameIdentifierNameNode.#ctor(Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameKind})">
            <summary>
            The simplest identifier node, which wraps a <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameKind.IdentifierToken" />
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameGenericNameNode">
            <summary>
            An identifier with an arity, such as "MyNamespace.MyClass`1" 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameGenericNameNode.GraveAccentToken">
            <summary>
            The "`" token in arity identifiers. Must be <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameKind.GraveAccentToken"/>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameGeneratedMethodNameNode">
            <summary>
            Generated methods follow the pattern Namespace.ClassName.&gt;MethodName$&lt;(), where 
            the "$" is optional.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameLocalMethodNameNode">
            <summary>
            Local method names are identifiers for local functions. They follow the pattern
            <code>
            Namespace.ClassName.&gt;ContainingMember&lt;g__LocalMethodName|0_0()
                                ^----------------------^-------------------------- EncapsulatingMethod
                                                        ^-^----------------------- GeneratedNameSeparator
                                                           ^--------------^------- Identifier 
                                                                           ^------ PipeToken
                                                                            ^--^-- Suffix
            </code>                                                               
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameArrayTypeNode">
            <summary>
            Represents an array type declaration, such as string[,][]
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameArrayTypeNode.TypeIdentifier">
            <summary>
            The type identifier without the array indicators.
            <code>
            string[][]
            ^----^
            </code>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameArrayTypeNode.ArrayRankSpecifiers">
            <summary>
            Each unique array identifier for the type
            <code>
            string[,][]
                   ^---  First array rank specifier  = "[,]"
                      ^- Second array rank specifier = "[]" 
            </code>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameTypeArgumentList">
            <summary>
            The type argument list for a method declaration. 
            
            <code>
            Ex: MyType.MyMethod[T, U, V](T t, U u, V v) 
                               ^-----------------------  "[" = Open Token 
                                ^------^   ------------  "T, U, V" = SeparatedStackFrameNodeList&lt;StackFrameTypeArgumentNode&gt;
                                        ^--------------  "]" = Close Token
            </code>
            
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameParser">
            <summary>
            Attempts to parse a stack frame line from given input. StackFrame is generally
            defined as a string line in a StackTrace. See https://docs.microsoft.com/en-us/dotnet/api/system.environment.stacktrace for 
            more documentation on dotnet stack traces. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameParser.TryParse(Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence)">
            <summary>
            Given an input text, and set of options, parses out a fully representative syntax tree 
            and list of diagnostics.  Parsing should always succeed, except in the case of the stack 
            overflowing.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameParser.TryParse(System.String)">
            <summary>
            Constructs a <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence"/> and calls <see cref="M:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameParser.TryParse(Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence)"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameParser.TryParseTree">
            <summary>
            Attempts to parse the full tree. Returns null on malformed data
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameParser.TryParseRequiredMethodDeclaration">
            <summary>
            Attempts to parse the full method declaration, optionally adding leading whitespace as trivia. Includes
            all of the generic indicators for types, 
            
            Ex: [|MyClass.MyMethod(string s)|]
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameParser.TryParseRequiredNameNode(System.Boolean)">
             <summary>
             Parses a <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameNameNode"/> which could either be a <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameSimpleNameNode"/> or <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameQualifiedNameNode" />.
             
             Nodes will be parsed for arity but not generic type arguments.
            
             <code>
             All of the following are valid nodes, where "$$" marks the parsing starting point, and "[|" + "|]" mark the endpoints of the parsed node excluding trivia
               * [|$$MyNamespace.MyClass.MyMethod|](string s)
               * MyClass.MyMethod([|$$string|] s)
               * MyClass.MyMethod([|$$string[]|] s)
               * [|$$MyClass`1.MyMethod|](string s)
               * [|$$MyClass.MyMethod|][T](T t)
             </code>
             
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameParser.TryParseQualifiedName(Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameNameNode)">
            <summary>
            Given an existing left hand side node or token, parse a qualified name if possible. Returns 
            null with success if a dot token is not available
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameParser.TryScanGeneratedName">
            <summary>
            Generated names are unutterables made by the compiler. This can include async code, top level statement main, local
            functions, anonymous types, etc. 
            
            <code>
            
                examples:
                
                1. GeneratedMethodName
                       Program.&lt;Main&gt;$
                               ^-------------- Beginning of generated name
                                   ^---^------ Identifier "Main"
                                        ^--^-- End of generated name with "&lt;$" 
                2. LocalMethodName
                       C.&lt;MyMethod&gt;g__Local|0_0(String s)
                         ^--------------------------------------- Beginning of generated name
                             ^------^---------------------------- Encapsulating method name
                                         ^----------------------- "g__" identifies this as a local function. 
                                            ^----^--------------- "Local" is the name of the local function
                                                 ^---^----------- "|0_0" is suffix information such as slot 
                                                      ^--------^- "(String s)" identifiers the method paramters
            </code>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameParser.TryScanGenericTypeIdentifier(Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameKind})">
             <summary>
             Given an identifier, attempts to parse the type identifier arity for it.
            
             <code>
             ex: MyNamespace.MyClass`1.MyMethod()
                             ^--------------------- MyClass would be the identifier passed in
                                    ^-------------- Grave token
                                     ^------------- Arity token of "1" 
             </code>
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameParser.TryParseTypeArguments">
            <summary>
            Type arguments for stacks are only valid on method declarations, and can have either '[' or '&lt;' as the 
            starting character depending on output source.
            
            ex: MyNamespace.MyClass.MyMethod[T](T t)
            ex: MyNamespace.MyClass.MyMethod&lt;T&lt;(T t)
            
            Assumes the identifier "MyMethod" has already been parsed, and the type arguments will need to be parsed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameParser.TryParseRequiredMethodParameters">
            <summary>
            MyNamespace.MyClass.MyMethod[|(string s1, string s2, int i1)|]
            Takes parameter declarations from method text and parses them into a <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameParameterList"/>.
            </summary>
            <remarks>
            This method assumes that the caller requires method parameters, and returns null for all failure cases. The caller
            should escalate to abort parsing on null values. 
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameParser.ParseParameterNode">
            <summary>
            Parses a <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameParameterDeclarationNode"/> by parsing identifiers first representing the type and then the parameter identifier.
            Ex: System.String[] s
                ^--------------^ -- Type = "System.String[]"
                                ^-- Identifier = "s"    
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameParser.ParseArrayRankSpecifiers">
            <summary>
            Parses the array rank specifiers for an identifier. 
            Ex: string[,][]
                      ^----^ both are array rank specifiers
                             0: "[,]
                             1: "[]"
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameParser.TryParseFileInformation">
            <summary>
            Parses text for a valid file path using valid file characters. It's very possible this includes a path that doesn't exist but
            forms a valid path identifier. 
            
            Can return if only a path is available but not line numbers, but throws if the value after the path is a colon as the expectation
            is that line number should follow.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.AbstractLanguageDetector`1.IsArgumentToWellKnownAPI(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SemanticModel,System.Threading.CancellationToken,`0@)">
            <summary>
            Whether or not this is an argument to a well known api for this language (like Regex.Match or JToken.Parse).
            We light up support if we detect these, even if these APIs don't have the StringSyntaxAttribute attribute on
            them.  That way users can get a decent experience even on downlevel frameworks.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.AbstractLanguageDetector`1.TryGetOptions(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken,`0@)">
            <summary>
            Giving a sibling argument expression to the string literal, attempts to determine if they correspond to
            options for that language.  For example with <c>new Regex("[a-z]", RegexOptions.CaseInsensitive)</c> the 
            second argument's expression defines options that control how the literal is parsed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.AbstractLanguageDetector`1.GetStringSyntaxDefaultOptions">
            <summary>
            What options we should assume by default if we're matched up against a symbol that has a [StringSyntax]
            attribute on it.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.AbstractLanguageDetector`4.s_compilationToDetector">
            <summary>
            Cache so that we can reuse the same TDetector when analyzing a particular compilation model. This saves the
            time from having to recreate this for every string literal that features examine for a particular
            compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.AbstractLanguageDetector`4.TryParse(Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence,`0)">
            <summary>
            Tries to parse out an appropriate language tree given the characters in this string literal.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.AbstractLanguageDetector`4.TryParseString(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SemanticModel,System.Threading.CancellationToken)">
            <summary>
            Attempts to parse the string-literal-like <paramref name="token"/> into an embedded language tree.  The
            token must either be in a location semantically known to accept this language, or it must have an
            appropriate comment on it stating that it should be interpreted as this language.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.DateAndTime.DateAndTimeEmbeddedCompletionProvider.EmbeddedCompletionContext._userFormatPrefix">
            <summary>
            The portion of the user string token prior to the section we're replacing.  Used for building the
            example format to present.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.DateAndTime.DateAndTimeEmbeddedCompletionProvider.EmbeddedCompletionContext._userFormatSuffix">
            <summary>
            The portion of the user string token after to the section we're replacing.  Used for building the
            example format to present.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.DateAndTime.DateAndTimeOptions">
            <summary>
            No actual options for DateAndTime. But we use this to fit into the common pattern of embedded languages.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.DateAndTime.DateTimeTree">
            <summary>
            No actual tree for DateAndTime. But we use this to fit into the common pattern of embedded languages.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.DateAndTime.LanguageServices.DateAndTimeLanguageDetector">
            <summary>
            Helper class to detect <see cref="T:System.DateTime"/> and <see cref="T:System.DateTimeOffset"/> format strings in a document efficiently.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.DateAndTime.LanguageServices.DateAndTimeLanguageDetector.#ctor(Microsoft.CodeAnalysis.EmbeddedLanguages.EmbeddedLanguageInfo,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Helper class to detect <see cref="T:System.DateTime"/> and <see cref="T:System.DateTimeOffset"/> format strings in a document efficiently.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonLexer.AdvanceToEndOfEscape(System.Int32,System.Int32)">
            <summary>
            <see cref="M:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonLexer.AdvanceToEndOfEscape(System.Int32,System.Int32)"/> does not actually lex out an escape token.  Instead, it just moves the
            position forward and returns a diagnostic if this was not a valid escape.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonCompilationUnit.Sequence">
            <summary>
            For error recovery purposes, we support a sequence of nodes at the top level (even
            though only a single node is actually allowed).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonValueNode">
            <summary>
            Root of all value nodes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonTextNode">
            <summary>
            Represents a chunk of text that we did not understand as anything special.  i.e. it wasn't a keyword, number, or
            literal.  One common case of this is an unquoted property name (which json.net accepts).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonCommaValueNode">
            <summary>
            See the note in <see cref="T:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonParser"/> for why commas are stored as values for convenience.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonConstructorNode">
            <summary>
            Json.net construction.  It allows things like <c>new Date(1, 2, 3)</c>.  This is not allowed in strict mode.  
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonOptions.Loose">
            <summary>
            Parse using loose rules.  This is very relaxed and allows lots of features not allowed by standard IETF 8259
            (like comments, and trailing commas).  This also allows all the additional constructs added by Json.net, like
            constructors and string that use single-quotes instead of double-quotes.
            </summary> 
        </member>
        <member name="F:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonOptions.Strict">
            <summary>
            Strict IETF 8259 mode.  Anything not allowed by that spec is flagged as an error.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonOptions.Comments">
            <summary>
            Same as <see cref="F:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonOptions.Strict"/> except that comments are allowed as well. Corresponds to <c>new JsonDocumentOptions
            { CommentHandling = Allow }</c>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonOptions.TrailingCommas">
            <summary>
            Same as <see cref="F:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonOptions.Strict"/> except that trailing commas are allowed as well. Corresponds to <c>new
            JsonDocumentOptions { AllowTrailingCommas = true }</c>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonParser">
            <summary>
            Parser used for reading in a sequence of <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar"/>s, and producing a <see
            cref="T:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonTree"/> out of it. Parsing will always succeed (except in the case of a
            stack-overflow) and will consume the entire sequence of chars.  General roslyn syntax
            principles are held to (i.e. immutable, fully representative, etc.).
            <para>
            The parser always parses out the same tree regardless of input.  *However*, depending on the
            flags passed to it, it may return a different set of *diagnostics*.  Specifically, the
            parser supports json.net parsing and strict RFC8259 (https://tools.ietf.org/html/rfc8259).
            As such, the parser supports a superset of both, but then does a pass at the end to produce
            appropriate diagnostics.
            </para>
            </summary>
            <remarks>
            Note: the json structure we parse out is actually very simple.  It's effectively all lists
            of <see cref="T:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonValueNode"/> values.  We just treat almost everything as a 'value'.  For
            example, a <see cref="T:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonPropertyNode"/> (i.e. <c>"x" = 0</c>) is a 'value'.  As such, it
            can show up in arrays (i.e.  <c>["x" = 0, "y" = 1]</c>).  This is not legal, but it greatly
            simplifies parsing.  Effectively, we just have recursive list parsing, where we accept any
            sort of value in any sort of context.  A later pass will then report errors for the wrong
            sorts of values showing up in incorrect contexts.
            <para>
            Note: We also treat commas (<c>,</c>) as being a 'value' on its own.  This simplifies parsing
            by allowing us to not have to represent Lists and SeparatedLists.  It also helps model
            things that are supported in json.net (like <c>[1,,2]</c>).  Our post-parsing pass will
            then ensure that these comma-values only show up in the right contexts.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonParser.ConsumeCurrentToken">
            <summary>
            Returns the latest token the lexer has produced, and then asks the lexer to 
            produce the next token after that.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonParser.TryParse(Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence,Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonOptions)">
            <summary>
            Given an input text, parses out a fully representative syntax tree  and list of 
            diagnostics.  Parsing should always succeed, except in the case of the stack 
            overflowing.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonParser.CheckTopLevel(Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence,Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonCompilationUnit)">
            <summary>
            Checks for errors in json for both json.net and strict mode.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonParser.StrictSyntaxChecker">
            <summary>
            Checks the superset-tree for constructs that aren't allowed in strict rfc8259
            (https://tools.ietf.org/html/rfc8259) mode.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.LanguageServices.AbstractJsonDetectionAnalyzer">
            <summary>
            Analyzer that helps find strings that are likely to be JSON and which we should offer the
            enable language service features for.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.LanguageServices.AbstractJsonDetectionAnalyzer.#ctor(Microsoft.CodeAnalysis.EmbeddedLanguages.EmbeddedLanguageInfo)">
            <summary>
            Analyzer that helps find strings that are likely to be JSON and which we should offer the
            enable language service features for.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.LanguageServices.AbstractJsonDetectionCodeFixProvider">
            <summary>
            Code fix impl for embedded json strings.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.LanguageServices.AbstractJsonDiagnosticAnalyzer">
            <summary>
            Analyzer that reports diagnostics in strings that we know are JSON text.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.LanguageServices.JsonBraceMatcher">
            <summary>
            Brace matcher impl for embedded json strings.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.LanguageServices.JsonClassifier">
            <summary>
            Classifier impl for embedded json strings.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.LanguageServices.JsonLanguageDetector">
            <summary>
            Helper class to detect json in string tokens in a document efficiently.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.LanguageServices.JsonLanguageDetector.#ctor(Microsoft.CodeAnalysis.EmbeddedLanguages.EmbeddedLanguageInfo,System.Collections.Generic.ISet{Microsoft.CodeAnalysis.INamedTypeSymbol})">
            <summary>
            Helper class to detect json in string tokens in a document efficiently.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.LanguageServices.JsonLanguageDetector.GetStringSyntaxDefaultOptions">
            <summary>
            [StringSyntax(Json)] means we're targetting .net, which means we're strict by default if we don't see any
            options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.LanguageServices.JsonLanguageDetector.TryParseString(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SemanticModel,System.Boolean,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.LanguageServices.JsonLanguageDetector.TryParseString(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SemanticModel,System.Boolean,System.Threading.CancellationToken)"/>
            <summary>
            If <paramref name="includeProbableStrings"/> is true, then this will also succeed on a string-literal like
            <paramref name="token"/> that strongly appears to have JSON in it.  This allows some features to light up
            automatically on code that is strongly believed to be JSON, but which is not passed to a known JSON api,
            and does not have a comment on it stating it is JSON.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.LanguageServices.JsonLanguageDetector.IsProbablyJson(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonTree@)">
            <summary>
            Returns <see langword="true"/> if this string-like <paramref name="token"/> is likely a JSON literal.  As
            many simple strings are legal JSON (like <c>0</c>) we require enough structure here to feel confident that
            this truly is JSON.  Currently, this means it must have at least one <c>{ ... }</c> object literal, and that
            literal must have at least one <c>"prop": val</c> property in it.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.RegularExpressions.LanguageServices.AbstractRegexDiagnosticAnalyzer">
            <summary>
            Analyzer that reports diagnostics in strings that we know are regex text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.RegularExpressions.LanguageServices.RegexEmbeddedCompletionProvider.ProvideCompletionsBasedOffOfPrecedingCharacter(Microsoft.CodeAnalysis.Features.EmbeddedLanguages.RegularExpressions.LanguageServices.RegexEmbeddedCompletionProvider.EmbeddedCompletionContext)">
            <summary>
            Produces completions using the previous character to determine which set of
            regex items to show.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.RegularExpressions.LanguageServices.RegexBraceMatcher">
            <summary>
            Brace matching impl for embedded regex strings.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.RegularExpressions.LanguageServices.RegexClassifier">
            <summary>
            Classifier impl for embedded regex strings.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.RegularExpressions.LanguageServices.RegexLanguageDetector">
            <summary>
            Helper class to detect regex pattern tokens in a document efficiently.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.RegularExpressions.LanguageServices.RegexLanguageDetector.#ctor(Microsoft.CodeAnalysis.EmbeddedLanguages.EmbeddedLanguageInfo,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Generic.HashSet{System.String})">
            <summary>
            Helper class to detect regex pattern tokens in a document efficiently.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Features.EmbeddedLanguages.RegularExpressions.LanguageServices.RegexLanguageDetector.GetMethodNamesOfInterest(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts)">
            <summary>
            Finds public, static methods in <see cref="T:System.Text.RegularExpressions.Regex"/> that have a parameter called
            'pattern'.  These are helpers (like <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)"/> 
            where at least one (but not necessarily more) of the parameters should be treated as a
            pattern.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Features.Intents.IntentProcessorResult">
            <summary>
            Defines the text changes needed to apply an intent.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Features.Intents.IntentProcessorResult.#ctor(Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DocumentId},System.String,System.String)">
            <summary>
            Defines the text changes needed to apply an intent.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Features.Intents.IntentProcessorResult.Solution">
            <summary>
            The changed solution for this intent result.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Features.Intents.IntentProcessorResult.ChangedDocuments">
            <summary>
            The set of documents that have changed for this intent result.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Features.Intents.IntentProcessorResult.Title">
            <summary>
            The title associated with this intent result.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Features.Intents.IntentProcessorResult.ActionName">
            <summary>
            Contains metadata that can be used to identify the kind of sub-action these edits
            apply to for the requested intent.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Features.Intents.WellKnownIntents">
            <summary>
            The set of well known intents that Roslyn can calculate edits for.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Features.RQName.Nodes.RQMethodPropertyOrEventName.OrdinaryNameValue">
            <summary>
            Methods, Properties, or Events either have "ordinary" names,
            or explicit interface names. But even explicit names have an
            underlying ordinary name as well. This is just the value for
            ordinary names, or the underlying ordinary name if this is an
            explicit name.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Features.RQName.RQNameInternal">
            <summary>
            Helpers related to <see cref="N:Microsoft.CodeAnalysis.Features.RQName"/>s.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Features.RQName.RQNameInternal.From(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns an RQName for the given symbol, or <see langword="null"/> if the symbol cannot be represented by an RQName.
            </summary>
            <param name="symbol">The symbol to build an RQName for.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Features.RQName.RQNodeBuilder.Build(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Builds the RQName for a given symbol.
            </summary>
            <returns>The node if it could be created, otherwise null</returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Features.Testing.AbstractTestMethodFinder`1.s_methodSymbolNoParametersDisplayFormat">
            <summary>
            Output the method symbol as a fully qualified method name, e.g. Namespace.Class.Method to match what test discovery gives us.
            Generics are not applicable here - none of our supported test frameworks allow generic test classes / methods.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Features.Testing.ITestMethodFinder.GetPotentialTestMethodsAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
            <summary>
            Finds potential test methods in the range.  This is not intended to be 100% accurate, but good enough without exploding complexity.
            For example, this does not consider inheritance.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Features.Testing.ITestMethodFinder.IsTestMethod(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Determines if the given method node is a potential test method.
            This is used in code lens computation, so it generally does syntax-only checks.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Features.Testing.ITestMethodFinder.IsMatch(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.String,System.Threading.CancellationToken)">
            <summary>
            Determines if a node is a likely match for the fully qualified test name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Features.Testing.ITestFrameworkMetadata.MatchesAttributeSyntacticName(System.String)">
            <summary>
            Determines if the input attribute token name matches known test method attribute names.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.CompilationOutputFiles.OpenAssemblyStream">
            <summary>
            Opens an assembly file produced by the compiler (corresponds to OutputAssembly build task parameter).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.CompilationOutputFiles.OpenPdbStream">
            <summary>
            Opens a PDB file produced by the compiler.
            Returns null if the compiler generated no PDB (the symbols might be embedded in the assembly).
            </summary>
            <remarks>
            The stream must be readable and seekable.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Emit.CompilationOutputFilesWithImplicitPdbPath">
            <summary>
            Provides access to compilation outputs based only on the path of the output asssembly.
            If PDB path is known upfront use <see cref="T:Microsoft.CodeAnalysis.Emit.CompilationOutputFiles"/> instead.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Emit.CompilationOutputs">
            <summary>
            Reads compilation outputs such as output assembly and PDB.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.CompilationOutputs.AssemblyDisplayPath">
            <summary>
            String describing the assembly to be used in user facing error messages (e.g. file path).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Emit.CompilationOutputs.PdbDisplayPath">
            <summary>
            String describing the PDB to be used in user facing error messages (e.g. file path).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.CompilationOutputs.OpenAssemblyMetadata(System.Boolean)">
            <summary>
            Opens metadata section of the assembly file produced by the compiler.
            </summary>
            <param name="prefetch">
            True to prefetch all metadata from the assembly and close the underlying stream on return,
            otherwise keeps the underlying stream open until the returned <see cref="T:System.Reflection.Metadata.MetadataReaderProvider"/> is disposed.
            </param>
            <returns>
            Instance of <see cref="T:System.Reflection.Metadata.MetadataReaderProvider"/>, which owns the opened metadata and must be disposed once the caller is done reading the data, 
            or null if the assembly is not available.
            </returns>
            <exception cref="T:System.BadImageFormatException">Invalid format of the assembly data.</exception>
            <exception cref="T:System.InvalidOperationException">The stream returned by <see cref="M:Microsoft.CodeAnalysis.Emit.CompilationOutputs.OpenAssemblyStreamChecked"/> does not support read and seek operations.</exception>
            <exception cref="T:System.Exception">Error while reading assembly data.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.CompilationOutputs.ReadAssemblyModuleVersionId">
            <summary>
            Reads MVID of the output assembly. Overridable for test mocking.
            Returns <see cref="F:System.Guid.Empty"/> if the assembly is not available.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.CompilationOutputs.OpenPdb">
            <summary>
            Opens PDB produced by the compiler.
            The caller must dispose the returned <see cref="T:Microsoft.CodeAnalysis.Debugging.DebugInformationReaderProvider"/>.
            </summary>
            <returns>
            Instance of <see cref="T:Microsoft.CodeAnalysis.Debugging.DebugInformationReaderProvider"/>, which owns the opened PDB and must be disposed once the caller is done reading the data,
            or null if PDB is not available.
            </returns>
            <exception cref="T:System.BadImageFormatException">Invalid format of the PDB or assembly data.</exception>
            <exception cref="T:System.InvalidOperationException">The stream returned by <see cref="M:Microsoft.CodeAnalysis.Emit.CompilationOutputs.OpenPdbStreamChecked"/> or <see cref="M:Microsoft.CodeAnalysis.Emit.CompilationOutputs.OpenAssemblyStreamChecked"/> does not support read and seek operations.</exception>
            <exception cref="T:System.Exception">Error while reading assembly data.</exception>
            <remarks>
            If a separate PDB stream is not available (<see cref="M:Microsoft.CodeAnalysis.Emit.CompilationOutputs.OpenPdbStreamChecked"/> returns null) opens the PDB embedded in the assembly, if present.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.CompilationOutputs.OpenAssemblyStream">
            <summary>
            Opens an assembly file produced by the compiler.
            </summary>
            <remarks>
            The stream must be readable and seekable.
            </remarks>
            <returns>New <see cref="T:System.IO.Stream"/> instance or null if the assembly is not available.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Emit.CompilationOutputs.OpenPdbStream">
            <summary>
            Opens a PDB file produced by the compiler.
            </summary>
            <remarks>
            The stream must be readable and seekable.
            </remarks>
            <returns>New <see cref="T:System.IO.Stream"/> instance or null if the compiler generated no PDB (the symbols might be embedded in the assembly).</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Extensions.ExtensionMessageHandlerServiceFactory.ExtensionMessageHandlerService.ExtensionFolder">
            <summary>
            Represents a folder that many individual extension assemblies can be loaded from.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Extensions.ExtensionMessageHandlerServiceFactory.ExtensionMessageHandlerService.ExtensionFolder._lazyAssemblyLoader">
            <summary>
            Lazily computed assembly loader for this particular folder.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Extensions.ExtensionMessageHandlerServiceFactory.ExtensionMessageHandlerService.ExtensionFolder._assemblyFilePathToHandlers">
            <summary>
            Mapping from assembly file path to the handlers it contains.  Should only be mutated while the <see
            cref="F:Microsoft.CodeAnalysis.Extensions.ExtensionMessageHandlerServiceFactory.ExtensionMessageHandlerService._gate"/> lock is held by our parent <see cref="F:Microsoft.CodeAnalysis.Extensions.ExtensionMessageHandlerServiceFactory.ExtensionMessageHandlerService.ExtensionFolder._extensionMessageHandlerService"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Extensions.ExtensionMessageHandlerServiceFactory.ExtensionMessageHandlerService.ExtensionFolder.UnregisterAssembly(System.String)">
            <summary>
            Unregisters this assembly path from this extension folder.  If this was the last registered path, then
            this will return true so that this folder can be unloaded.  Also returns the lazy handlers for this
            assembly path.  If <see cref="M:Microsoft.CodeAnalysis.Extensions.ExtensionMessageHandlerServiceFactory.ExtensionMessageHandlerService.ExtensionFolder.GetExtensionMessageNamesAsync(System.String,System.Threading.CancellationToken)"/> has been called, this will be a fully
            computed value. Otherwise, it will be an uncomputed value.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Extensions.ExtensionMessageHandlerServiceFactory.ExtensionMessageHandlerService._gate">
            <summary>
            Lock for <see cref="F:Microsoft.CodeAnalysis.Extensions.ExtensionMessageHandlerServiceFactory.ExtensionMessageHandlerService._folderPathToExtensionFolder"/>, <see cref="F:Microsoft.CodeAnalysis.Extensions.ExtensionMessageHandlerServiceFactory.ExtensionMessageHandlerService._cachedHandlers_useOnlyUnderLock"/>, and
            <see cref="F:Microsoft.CodeAnalysis.Extensions.ExtensionMessageHandlerServiceFactory.ExtensionMessageHandlerService._unregisteredHandlerNames_useOnlyUnderLock"/>.  Note: this type is designed such that all time
            while this lock is held should be minimal.  Importantly, no async work or IO should be done while holding
            this lock.  Instead, all of that work should be pushed into AsyncLazy values that compute when asked,
            outside of this lock.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Extensions.ExtensionMessageHandlerServiceFactory.ExtensionMessageHandlerService._folderPathToExtensionFolder">
            <summary>
            Extensions assembly load contexts and loaded handlers, indexed by extension folder path.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Extensions.ExtensionMessageHandlerServiceFactory.ExtensionMessageHandlerService._cachedHandlers_useOnlyUnderLock">
            <summary>
            Cached handlers of workspace or document related messages, indexed by handler message name.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Extensions.ExtensionMessageHandlerServiceFactory.ExtensionMessageHandlerService._unregisteredHandlerNames_useOnlyUnderLock">
            <summary>
            Names of handlers that were previously loaded, but have since been unloaded.  This is used to distinguish a
            strict bug, where Gladstone calls into a handler that was never registered, versus a benign case where it is
            concurrently calling into a handler that it is also unloading.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Extensions.IExtensionAssemblyLoaderProvider">
            <summary>
            Abstraction around <see cref="T:Microsoft.CodeAnalysis.Host.IAnalyzerAssemblyLoaderProvider"/> so that we can mock that behavior in tests.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Extensions.IExtensionAssemblyLoader">
            <summary>
            Abstraction around <see cref="T:Microsoft.CodeAnalysis.IAnalyzerAssemblyLoader"/> so that we can mock that behavior in tests.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Extensions.IExtensionMessageHandlerFactory">
            <summary>
            Factory for creating instances of extension message handlers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Extensions.IExtensionMessageHandlerFactory.CreateWorkspaceMessageHandlers(System.Reflection.Assembly,System.String,System.Threading.CancellationToken)">
            <summary>
            Creates <see cref="T:Microsoft.CodeAnalysis.Extensions.IExtensionMessageHandlerWrapper`1"/> instances for each
            <c>IExtensionWorkspaceMessageHandler</c> type in <paramref name="assembly"/>.
            </summary>
            <param name="assembly">The assembly to scan for handlers.</param>
            <param name="extensionIdentifier">Unique identifier of the extension owning this handler.</param>
            <remarks>May be called multiple times for the same <see cref="T:System.Reflection.Assembly"/> instance.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Extensions.IExtensionMessageHandlerFactory.CreateDocumentMessageHandlers(System.Reflection.Assembly,System.String,System.Threading.CancellationToken)">
            <summary>
            Creates <see cref="T:Microsoft.CodeAnalysis.Extensions.IExtensionMessageHandlerWrapper`1"/> instances for each
            <c>IExtensionDocumentMessageHandler</c> type in <paramref name="assembly"/>.
            </summary>
            <param name="assembly">The assembly to scan for handlers.</param>
            <param name="extensionIdentifier">Unique identifier of the extension owning this handler.</param>
            <remarks>May be called multiple times for the same <see cref="T:System.Reflection.Assembly"/> instance.</remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Extensions.ExtensionMessageResult">
            <param name="Response">The result value the extension produced, converted to Json using JsonSerializer.Serialize. On
            the object value returned from <see cref="M:Microsoft.CodeAnalysis.Extensions.IExtensionMessageHandlerWrapper`1.ExecuteAsync(System.Object,`0,System.Threading.CancellationToken)"/>.  Can be <see
            langword="null"/> if the extension was unloaded, or there was an extension thrown by the extension.  If the
            extension actually returns <see langword="null"/> then that will be encoded into Json as <c>"null"</c>.</param>
            <param name="ExtensionWasUnloaded">If the extension the message was called for was previously unloaded and is no longer
            available to perform the request.</param>
            <param name="ExtensionException">Any exception produced by the extension itself during <see
            cref="M:Microsoft.CodeAnalysis.Extensions.IExtensionMessageHandlerWrapper`1.ExecuteAsync(System.Object,`0,System.Threading.CancellationToken)"/>.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Extensions.ExtensionMessageResult.#ctor(System.String,System.Boolean,System.Exception)">
            <param name="Response">The result value the extension produced, converted to Json using JsonSerializer.Serialize. On
            the object value returned from <see cref="M:Microsoft.CodeAnalysis.Extensions.IExtensionMessageHandlerWrapper`1.ExecuteAsync(System.Object,`0,System.Threading.CancellationToken)"/>.  Can be <see
            langword="null"/> if the extension was unloaded, or there was an extension thrown by the extension.  If the
            extension actually returns <see langword="null"/> then that will be encoded into Json as <c>"null"</c>.</param>
            <param name="ExtensionWasUnloaded">If the extension the message was called for was previously unloaded and is no longer
            available to perform the request.</param>
            <param name="ExtensionException">Any exception produced by the extension itself during <see
            cref="M:Microsoft.CodeAnalysis.Extensions.IExtensionMessageHandlerWrapper`1.ExecuteAsync(System.Object,`0,System.Threading.CancellationToken)"/>.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Extensions.ExtensionMessageResult.Response">
            <summary>The result value the extension produced, converted to Json using JsonSerializer.Serialize. On
            the object value returned from <see cref="M:Microsoft.CodeAnalysis.Extensions.IExtensionMessageHandlerWrapper`1.ExecuteAsync(System.Object,`0,System.Threading.CancellationToken)"/>.  Can be <see
            langword="null"/> if the extension was unloaded, or there was an extension thrown by the extension.  If the
            extension actually returns <see langword="null"/> then that will be encoded into Json as <c>"null"</c>.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Extensions.ExtensionMessageResult.ExtensionWasUnloaded">
            <summary>If the extension the message was called for was previously unloaded and is no longer
            available to perform the request.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Extensions.ExtensionMessageResult.ExtensionException">
            <summary>Any exception produced by the extension itself during <see
            cref="M:Microsoft.CodeAnalysis.Extensions.IExtensionMessageHandlerWrapper`1.ExecuteAsync(System.Object,`0,System.Threading.CancellationToken)"/>.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Extensions.IExtensionMessageHandlerService">
            <summary>
            This service is used to register, unregister and execute extension message handlers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Extensions.IExtensionMessageHandlerService.RegisterExtensionAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Registers extension message handlers from the specified assembly.
            </summary>
            <param name="assemblyFilePath">The assembly to register and create message handlers from.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Extensions.IExtensionMessageHandlerService.UnregisterExtensionAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Unregisters extension message handlers previously registered from <paramref name="assemblyFilePath"/>.
            </summary>
            <param name="assemblyFilePath">The assembly for which handlers should be unregistered.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Extensions.IExtensionMessageHandlerService.ResetAsync(System.Threading.CancellationToken)">
            <summary>
            Unregisters all extension message handlers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Extensions.IExtensionMessageHandlerService.GetExtensionMessageNamesAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Gets the message names supported by the extension specified by <paramref name="assemblyFilePath"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Extensions.IExtensionMessageHandlerService.HandleExtensionWorkspaceMessageAsync(Microsoft.CodeAnalysis.Solution,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Executes a non-document-specific extension message handler with the given message and solution.
            </summary>
            <param name="solution">The solution the message refers to.</param>
            <param name="messageName">The name of the handler to execute. This is generally the full name of the type implementing the handler.</param>
            <param name="jsonMessage">The json message to be passed to the handler.</param>
            <returns>The json message returned by the handler.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Extensions.IExtensionMessageHandlerService.HandleExtensionDocumentMessageAsync(Microsoft.CodeAnalysis.Document,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Executes a document-specific extension message handler with the given message and solution.
            </summary>
            <param name="documentId">The document the message refers to.</param>
            <param name="messageName">The name of the handler to execute. This is generally the full name of the type implementing the handler.</param>
            <param name="jsonMessage">The json message to be passed to the handler.</param>
            <returns>The json message returned by the handler.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Extensions.IExtensionMessageHandlerWrapper">
            <summary>
            Wrapper for an <c>IExtensionWorkspaceMessageHandler</c> or <c>IExtensionDocumentMessageHandler</c>
            as returned by <see cref="T:Microsoft.CodeAnalysis.Extensions.IExtensionMessageHandlerFactory"/>. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Extensions.IExtensionMessageHandlerWrapper.MessageType">
            <summary>
            The type of object received as parameter by the extension message handler.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Extensions.IExtensionMessageHandlerWrapper.ResponseType">
            <summary>
            The type of object returned as result by the extension message handler.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Extensions.IExtensionMessageHandlerWrapper.Name">
            <summary>
            The name of the extension message handler. This is generally the full name of the class implementing the handler.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Extensions.IExtensionMessageHandlerWrapper.ExtensionIdentifier">
            <summary>
            The identifier of the extension that this message handler belongs to.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Extensions.IExtensionMessageHandlerWrapper`1">
            <typeparam name="TArgument">The type of object received as parameter by the extension message
            handler.</typeparam>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Extensions.IExtensionMessageHandlerWrapper`1.ExecuteAsync(System.Object,`0,System.Threading.CancellationToken)">
            <summary>
            Executes the extension message handler with the given message and document.
            </summary>
            <param name="message">An object of type <see cref="P:Microsoft.CodeAnalysis.Extensions.IExtensionMessageHandlerWrapper.MessageType"/> to be passed
            to the handler.</param>
            <param name="argument">The argument the handler operates on.</param>
            <returns>An object of type <see cref="P:Microsoft.CodeAnalysis.Extensions.IExtensionMessageHandlerWrapper.ResponseType"/> returned by the message
            handler.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Extensions.IRemoteExtensionMessageHandlerService">
            <summary>
            Remote API for <see cref="T:Microsoft.CodeAnalysis.Extensions.IExtensionMessageHandlerService"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingDocumentSpan.DocumentSpan">
            <summary>
            The raw <see cref="T:Microsoft.CodeAnalysis.Document"/> and <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> that the symbol is located at.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingDocumentSpan.Span">
            <summary>
            The line and character the symbol is located.  If this is a mapped location (e.g. affected by a <c>#line</c>
            directive), this will be the final location the symbol was mapped to.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingHotReloadService.StartSessionAsync(Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.ImmutableArray{System.String},System.Threading.CancellationToken)">
            <summary>
            Starts the watcher.
            </summary>
            <param name="solution">Solution that represents sources that match the built binaries on disk.</param>
            <param name="capabilities">Array of capabilities retrieved from the runtime to dictate supported rude edits.</param>
            <param name="cancellationToken">Cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingHotReloadService.EmitSolutionUpdateAsync(Microsoft.CodeAnalysis.Solution,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Emits updates for all projects that differ between the given <paramref name="solution"/> snapshot and the one given to the previous successful call 
            where <paramref name="commitUpdates"/> was `true` or the one passed to <see cref="M:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingHotReloadService.StartSessionAsync(Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.ImmutableArray{System.String},System.Threading.CancellationToken)"/>
            for the first invocation.
            </summary>
            <param name="solution">Solution snapshot.</param>
            <param name="commitUpdates">commits changes if true, discards if false</param>
            <param name="cancellationToken">Cancellation token.</param>
            <returns>
            Updates (one for each changed project) and Rude Edit diagnostics. Does not include syntax or semantic diagnostics.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingSearchHelpers.ConvertFromMetadataTypeName(System.String)">
            <summary>
            Converts from a metadata-name into the internal simple dotted name we store in our index as the container
            for a symbol.  In the future, we could consider storing the fully-qualified-metadata-name in our index as
            it's trivial to compute it as we're walking down the syntax tree.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingSearchQuery.FullyQualifiedTypeName">
            <summary>
            Fully qualified metadata name for the type being searched for, or the containing type of the method being
            searched for (if <see cref="F:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingSearchQuery.MethodName"/> is provided).  Should follow .Net metadata naming, e.g. <c>`</c>
            for arity and <c>+</c> for nested types.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingSearchQuery.MethodName">
            <summary>
            Optional name of method within <see cref="F:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingSearchQuery.FullyQualifiedTypeName"/> being searched for.  Should not include arity.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingSearchQuery.MethodArity">
            <summary>
            Arity of the method being searched for.  Only valid if <see cref="F:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingSearchQuery.MethodName"/> is non-null.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingSearchQuery.MethodParameterCount">
            <summary>
            Parameter count of the method being searched for.  Only valid if <see cref="F:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingSearchQuery.MethodName"/> is non-null.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingSearchQuery.Strict">
            <summary>
            Whether or not this is a strict search or not.  Strict searches require matching arity and parameter counts,
            while non-strict searches do not.  Non-strict searches are useful in cases where the initial searching data
            may not be produced in a well formed fashion (for example, some legacy test providers that do not follow:
            https://github.com/microsoft/vstest-docs/blob/main/RFCs/0017-Managed-TestCase-Properties.md).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.LegacySolutionEvents.UnitTestingLegacySolutionEventsListener">
            <summary>
            Retrieves stream of workspace events and forwards them to the dedicated solution crawler instance that exists
            for unit testing.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Notification.IGlobalOperationNotificationService">
            <summary>
            Optional interface that can be used to hear about when expensive global operations (like a 'build') occur in the
            current host.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Notification.IGlobalOperationNotificationService.Started">
            <summary>
            raised when global operation is started
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Notification.IGlobalOperationNotificationService.Stopped">
            <summary>
            raised when global operation is stopped
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Notification.IGlobalOperationNotificationService.Start(System.String)">
            <summary>
            start new global operation
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.IUnitTestingSolutionCrawlerProgressReporter">
            <summary>
            Provide a way to see whether solution crawler is started or not
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.IUnitTestingSolutionCrawlerProgressReporter.InProgress">
            <summary>
            Return true if solution crawler is in progress.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.IUnitTestingSolutionCrawlerProgressReporter.ProgressChanged">
            <summary>
            Raised when solution crawler progress changed
            
            Notifications for this event are serialized to preserve order. 
            However, individual event notifications may occur on any thread.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingProgressData.PendingItemCount">
            <summary>
            number of pending work item in the queue. 
            null means N/A for the associated <see cref="P:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingProgressData.Status"/>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.IUnitTestingSolutionCrawlerRegistrationService">
            <summary>
            Register a solution crawler for a particular workspace
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.IUnitTestingSolutionCrawlerService">
            <summary>
            Provide a way to control solution crawler.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.IUnitTestingSolutionCrawlerService.Reanalyze(System.String,Microsoft.CodeAnalysis.Host.SolutionServices,Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.IUnitTestingIncrementalAnalyzer,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectId},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.DocumentId})">
            <summary>
            Ask solution crawler to re-analyze given <see cref="T:Microsoft.CodeAnalysis.ProjectId"/>s or/and <see cref="T:Microsoft.CodeAnalysis.DocumentId"/>s 
            in given <see cref="T:Microsoft.CodeAnalysis.Workspace"/> with given <see cref="T:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.IUnitTestingIncrementalAnalyzer"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.IUnitTestingSolutionCrawlerService.GetProgressReporter(Microsoft.CodeAnalysis.Workspace)">
            <summary>
            Get <see cref="T:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.IUnitTestingSolutionCrawlerProgressReporter"/> for the given <see cref="T:Microsoft.CodeAnalysis.Workspace"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.IUnitTestingWorkCoordinatorPriorityService.IsLowPriorityAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            True if this document is less important than other documents in the project it is 
            contained in, and should have work scheduled for it happen after all other documents
            in the project.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingGlobalOperationAwareIdleProcessor._globalOperationNotificationService">
            <summary>
            We're not at a layer where we are guaranteed to have an IGlobalOperationNotificationService.  So allow for
            it being null.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingIdleProcessor._isPaused_doNotAccessDirectly">
            <summary>
            Whether or not this processor is paused.  As long as it is paused, it will not start executing new work,
            even if <see cref="F:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingIdleProcessor.BackOffTimeSpan"/> has been met.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingIdleProcessor.OnPaused">
            <summary>
            Will be called in a serialized fashion (i.e. never concurrently).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingIdleProcessor.GetIsPaused">
            <summary>
            Whether or not we are paused due to a global operation being in effect.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingIdleProcessor.ShouldContinueToBackOff">
            <summary>
            Whether or not enough time has passed since the last time we were asked to back off.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingIdleProcessor.WaitForIdleAsync(Microsoft.CodeAnalysis.Shared.TestHooks.IExpeditableDelaySource)">
            <returns><see langword="true"/> if the delay compeleted normally; otherwise, <see langword="false"/> if the
            delay completed due to a request to expedite the delay.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingSolutionCrawlerRegistrationService.UnitTestingSolutionCrawlerProgressReporter">
            <summary>
            Progress reporter
            
            this progress reporter is a best effort implementation. it doesn't stop world to find out accurate data
            
            what this reporter care is we show start/stop background work and show things are moving or paused
            without too much cost.
            
            due to how solution cralwer calls Start/Stop (see caller of those 2), those 2 can't have a race
            and that is all we care for this reporter
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingSolutionCrawlerRegistrationService.UnitTestingSolutionCrawlerProgressReporter.GetEvaluatingScope">
            <summary>
            Allows the solution crawler to start evaluating work enqueued to it. 
            Returns an IDisposable that the caller must dispose of to indicate that it no longer needs the crawler to continue evaluating. 
            Multiple callers can call into this simultaneously. 
            Only when the last one actually disposes the scope-object will the crawler 
            actually revert back to the paused state where no work proceeds.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingSolutionCrawlerRegistrationService.UnitTestingNullReporter">
            <summary>
            reporter that doesn't do anything
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingSolutionCrawlerRegistrationService._lastReportedSolution">
            <summary>
            The last solution we've heard about from the <see cref="T:Microsoft.CodeAnalysis.LegacySolutionEvents.ILegacySolutionEventsListener"/>.  This is used by
            our <see cref="T:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingSolutionCrawlerRegistrationService.UnitTestingWorkCoordinator"/> to represent the equivalent entity that <see
            cref="P:Microsoft.CodeAnalysis.Workspace.CurrentSolution"/> normally represents.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingSolutionCrawlerRegistrationService.Register(Microsoft.CodeAnalysis.Solution)">
            <summary>
            make sure solution cralwer is registered for the given workspace.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingSolutionCrawlerRegistrationService.UnitTestingSolutionCrawlerService">
            <summary>
            nested class of <see cref="T:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingSolutionCrawlerRegistrationService"/> since it is tightly coupled with it.
            
            <see cref="T:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.IUnitTestingSolutionCrawlerService"/> is implemented by this class since WorkspaceService doesn't allow a class to implement
            more than one <see cref="T:Microsoft.CodeAnalysis.Host.IWorkspaceService"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingSolutionCrawlerRegistrationService.UnitTestingWorkCoordinator.UnitTestingIncrementalAnalyzerProcessor._logAggregator">
            <summary>
            The keys in this are either a string or a (string, Guid) tuple. See <see cref="M:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingSolutionCrawlerLogger.LogIncrementalAnalyzerProcessorStatistics(System.Int32,Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Internal.Log.CountLogAggregator{System.Object})"/>
            for what is writing this out.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingSolutionCrawlerRegistrationService.UnitTestingWorkCoordinator.UnitTestingIncrementalAnalyzerProcessor.UnitTestingNormalPriorityProcessor.Running">
            <summary>whether this processor is running or not</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingSolutionCrawlerRegistrationService.UnitTestingWorkCoordinator.UnitTestingWorkItem.SpecificAnalyzers">
            <summary>
            Non-empty if this work item is intended to be executed only for specific incremental analyzer(s).
            Otherwise, the work item is applicable to all relevant incremental analyzers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingSolutionCrawlerRegistrationService.UnitTestingWorkCoordinator.UnitTestingWorkItem.GetApplicableAnalyzers(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.IUnitTestingIncrementalAnalyzer})">
            <summary>
            Gets all the applicable analyzers to execute for this work item.
            If this work item has any specific analyzer(s), then returns the intersection of <see cref="F:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingSolutionCrawlerRegistrationService.UnitTestingWorkCoordinator.UnitTestingWorkItem.SpecificAnalyzers"/>
            and the given <paramref name="allAnalyzers"/>.
            Otherwise, returns <paramref name="allAnalyzers"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingSolutionCrawlerRegistrationService.EnqueueItem">
            <summary>
            this will be used in the unit test to indicate certain action has happened or not.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.IVSTypeScriptDiagnosticAnalyzerService.Reanalyze(Microsoft.CodeAnalysis.Workspace,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectId},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.DocumentId},System.Boolean)">
            <summary>
            Issues a request to invalidate <em>all</em> diagnostics reported to the LSP client, and have them all be
            recomputed.  This is equivalent to an LSP diagnostic refresh request.  This should be used sparingly.  For
            example: when a user changes an option controlling diagnostics.  Note: all arguments are unused and are only
            kept around for legacy binary compat purposes.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.IVSTypeScriptNavigableItem.DisplayTaggedParts">
            <summary>
            The tagged parts to display for this item. If default, the line of text from <see cref="P:Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.IVSTypeScriptNavigableItem.Document"/> is used.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.IVSTypeScriptNavigableItem.DisplayFileLocation">
            <summary>
            Return true to display the file path of <see cref="P:Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.IVSTypeScriptNavigableItem.Document"/> and the span of <see cref="P:Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.IVSTypeScriptNavigableItem.SourceSpan"/> when displaying this item.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.IVSTypeScriptNavigableItem.IsImplicitlyDeclared">
            <summary>
            his is intended for symbols that are ordinary symbols in the language sense, and may be
            used by code, but that are simply declared implicitly rather than with explicit language
            syntax.  For example, a default synthesized constructor in C# when the class contains no
            explicit constructors.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.VSTypeScriptDiagnosticData.GetLinePositionSpan(Microsoft.CodeAnalysis.Text.SourceText,System.Boolean)">
            <summary>
            Note: the <paramref name="useMapped"/> parameter is ignored.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.VSTypeScriptDocumentHighlightsServiceBase">
            <summary>
            TODO: Ideally, we would export TypeScript service and delegate to an imported TypeScript service implementation.
            However, TypeScript already exports the service so we would need to coordinate the change.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.VSTypeScriptSignatureHelpProviderBase">
            <summary>
            TODO: Ideally, we would export TypeScript service and delegate to an imported TypeScript service implementation.
            However, TypeScript already exports the service so we would need to coordinate the change.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ExternalAccess.Watch.Api.WatchHotReloadService.Status.NoChangesToApply">
            <summary>
            No significant changes made that need to be applied.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ExternalAccess.Watch.Api.WatchHotReloadService.Status.ReadyToApply">
            <summary>
            Changes can be applied either via updates or restart.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ExternalAccess.Watch.Api.WatchHotReloadService.Status.Blocked">
            <summary>
            Some changes are errors that block rebuild of the module.
            This means that the code is in a broken state that cannot be resolved by restarting the application.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExternalAccess.Watch.Api.WatchHotReloadService.Updates2.Status">
            <summary>
            Status of the updates.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExternalAccess.Watch.Api.WatchHotReloadService.Updates2.CompilationDiagnostics">
            <summary>
            Returns all diagnostics that can't be addressed by rebuilding/restarting the project.
            Syntactic, semantic and emit diagnostics.
            </summary>
            <remarks>
            <see cref="P:Microsoft.CodeAnalysis.ExternalAccess.Watch.Api.WatchHotReloadService.Updates2.Status"/> is <see cref="F:Microsoft.CodeAnalysis.ExternalAccess.Watch.Api.WatchHotReloadService.Status.Blocked"/> if these diagnostics contain any errors.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExternalAccess.Watch.Api.WatchHotReloadService.Updates2.RudeEdits">
            <summary>
            Transient diagnostics (rude edits) per project.
            All diagnostics that can be addressed by rebuilding/restarting the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExternalAccess.Watch.Api.WatchHotReloadService.Updates2.ProjectUpdates">
            <summary>
            Updates to be applied to modules. Empty if there are blocking rude edits.
            Only updates to projects that are not included in <see cref="P:Microsoft.CodeAnalysis.ExternalAccess.Watch.Api.WatchHotReloadService.Updates2.ProjectsToRebuild"/> are listed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExternalAccess.Watch.Api.WatchHotReloadService.Updates2.ProjectsToRestart">
            <summary>
            Running projects that need to be restarted due to rude edits in order to apply changes.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExternalAccess.Watch.Api.WatchHotReloadService.Updates2.ProjectsToRebuild">
            <summary>
            Projects with changes that need to be rebuilt in order to apply changes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExternalAccess.Watch.Api.WatchHotReloadService.AddImplicitDotNetCapabilities(System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
            Adds capabilities that are available by default on runtimes supported by dotnet-watch: .NET and Mono
            and not on .NET Framework (they are not in <see cref="F:Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueCapabilities.Baseline"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExternalAccess.Watch.Api.WatchHotReloadService.StartSessionAsync(Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            Starts the watcher.
            </summary>
            <param name="solution">Solution that represents sources that match the built binaries on disk.</param>
            <param name="cancellationToken">Cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExternalAccess.Watch.Api.WatchHotReloadService.CapabilitiesChanged">
            <summary>
            Invoke when capabilities have changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExternalAccess.Watch.Api.WatchHotReloadService.GetTargetFramework(Microsoft.CodeAnalysis.Project)">
            <summary>
            Returns TFM of a given project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExternalAccess.Watch.Api.WatchHotReloadService.GetUpdatesAsync(Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ExternalAccess.Watch.Api.WatchHotReloadService.RunningProjectInfo},System.Threading.CancellationToken)">
            <summary>
            Emits updates for all projects that differ between the given <paramref name="solution"/> snapshot and the one given to the previous successful call or
            the one passed to <see cref="M:Microsoft.CodeAnalysis.ExternalAccess.Watch.Api.WatchHotReloadService.StartSessionAsync(Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)"/> for the first invocation.
            </summary>
            <param name="solution">Solution snapshot.</param>
            <param name="runningProjects">Identifies projects that launched a process.</param>
            <param name="cancellationToken">Cancellation token.</param>
            <returns>
            Updates (one for each changed project) and Rude Edit diagnostics. Does not include syntax or semantic diagnostics.
            May include both updates and Rude Edits for different projects.
            </returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExtractClass.ExtractClassMemberAnalysisResult.Member">
            <summary>
            The member needs to be pulled up.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExtractClass.ExtractClassMemberAnalysisResult.MakeAbstract">
            <summary>
            Whether to make the member abstract when added to the new class
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3">
            <summary>
            Core service that tries to share as much extract-method logic across C# and VB.  Note: TStatementSyntax and
            TExecutableStatementSyntax exist to model VB's inheritance model there (where StatementSyntax is used liberally
            (including for signatures of members, while ExecutableStatementSyntax generally corresponds to a code statement
            found within a method body).  In C# these will be the same StatementSyntax type as C# has a much stronger split
            between executable code statements and symbol signatures.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.MethodExtractor.Analyzer.GetRangeVariableType(Microsoft.CodeAnalysis.IRangeVariableSymbol)">
            <summary>
            get type of the range variable symbol
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.MethodExtractor.Analyzer.ReadOnlyFieldAllowed">
            <summary>
            check whether the selection is at the placed where read-only field is allowed to be extracted out
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.MethodExtractor.Analyzer.GetIndexOfVariableInfoToUseAsReturnValue(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService{`0,`1,`2}.MethodExtractor.VariableInfo},System.Int32@,System.Int32@)">
            <summary>
            among variables that will be used as parameters at the extracted method, check whether one of the parameter can be used as return
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.MethodExtractor.Analyzer.GenerateVariableInfoMap(System.Boolean,Microsoft.CodeAnalysis.DataFlowAnalysis,Roslyn.Utilities.MultiDictionary{Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SyntaxToken},System.Boolean,System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService{`0,`1,`2}.MethodExtractor.VariableInfo}@,System.Collections.Generic.List{Microsoft.CodeAnalysis.ISymbol}@)">
            <param name="bestEffort">When false, variables whose data flow is not understood
            will be returned in <paramref name="failedVariables"/>. When true, we assume any
            variable we don't understand has <see cref="F:Microsoft.CodeAnalysis.ExtractMethod.VariableStyle.None"/></param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.MethodExtractor.AnalyzerResult.UseInstanceMember">
            <summary>
            used to determine whether static can be used
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.MethodExtractor.AnalyzerResult.ShouldBeReadOnly">
            <summary>
            Indicates whether the extracted method should have a 'readonly' modifier.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.MethodExtractor.AnalyzerResult.FlowControlInformation">
            <summary>
            Information about the flow control constructs found in the selection.  For for many purposes, including
            determining whether a final "return" statement needs to be inserted.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.MethodExtractor.AnalyzerResult.CoreReturnType">
            <summary>
            Initial computed return type for the extract method.  This does not include any wrapping in a type like
            <see cref="T:System.Threading.Tasks.Task`1"/> for async methods.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.MethodExtractor.AnalyzerResult.Status">
            <summary>
            analyzer result operation status
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.MethodExtractor.ExitPointAnnotation">
            <summary>
            Marks nodes that cause control flow to leave the extracted selection.  This is commonly constructs like <see
            langword="return"/>, <see langword="break"/>, <see langword="continue"/> and the like.  We mark these with
            annotations at the start of the extraction process so that we can find these nodes again later after they
            have been extracted to rewrite them as needed.  Specifically, constructs like <see langword="break"/>, <see
            langword="continue"/> cannot cross a method boundary.  As such, they must be translated to a <see
            langword="return"/> statement that returns a value indicating the flow control construct that should be
            executed at the callsite after the extracted method is called.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.MethodExtractor.CodeGenerator.GetNewMethodStatements(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Used to produced the set of statements that will go into the generated method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.MethodExtractor.CodeGenerator`2.CreateDeclarationStatement(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService{`0,`1,`2}.MethodExtractor.VariableInfo},`2,Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodFlowControlInformation,System.Threading.CancellationToken)">
            <summary>
            Statement we create when we are assigning variables and at least one of the variables in a new
            declaration that is being created.  <paramref name="variables"/> can be empty.  This can happen
            if we are creating a new declaration for a flow control variable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.MethodExtractor.CodeGenerator`2.CreateAssignmentExpressionStatement(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService{`0,`1,`2}.MethodExtractor.VariableInfo},`2)">
            <summary>
            Statement we create when we are assigning variables and all of the variables already exist and are just
            being assigned to. <paramref name="variables"/> must be non-empty.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.MethodExtractor.VariableInfo.CanBeCapturedByLocalFunction">
            <summary>
            Returns true, if the variable could be either passed as a parameter
            to the new local function or the local function can capture the variable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.MethodExtractor.VariableSymbol.SymbolType">
            <summary>
            Get the type of <see cref="M:Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.MethodExtractor.VariableSymbol.GetSymbol"/> to use when generating code. May contain anonymous types in it.
            Note: this is not necessarily the type symbol that can be directly accessed off of <see
            cref="M:Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.MethodExtractor.VariableSymbol.GetSymbol"/> itself.  For example, it may have had nullability information changes applied to it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.MethodExtractor.VariableSymbol.GetSymbol">
            <summary>
            The underlying symbol this points at.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.InitialSelectionInfo">
            <summary>
            Information about the initial selection the user made, prior to do any fixup on it to select a more appropriate
            range.  Kept separate from <see cref="T:Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.FinalSelectionInfo"/> to ensure different phases of the extract method
            process do not accidentally use the wrong information.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.FinalSelectionInfo">
            <summary>
            Information about the final selection we adjust the the user's selection to. Kept separate from <see
            cref="T:Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.InitialSelectionInfo"/> to ensure different phases of the extract method process do not accidentally use
            the wrong information.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.FinalSelectionInfo.With(Microsoft.CodeAnalysis.Optional{Microsoft.CodeAnalysis.ExtractMethod.OperationStatus},Microsoft.CodeAnalysis.Optional{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Optional{Microsoft.CodeAnalysis.SyntaxToken},Microsoft.CodeAnalysis.Optional{Microsoft.CodeAnalysis.SyntaxToken},Microsoft.CodeAnalysis.Optional{System.Boolean})">
            <summary>
            For VB.  C# should just use standard <c>with</c> operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.SelectionResult._dataFlowAnalysis">
            <summary>
            Cached data flow analysis result for the selected code.  Valid for both expressions and statements.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.SelectionResult._statementControlFlowAnalysis">
            <summary>
            Cached information about the control flow of the selected code.  Only valid if the selection covers one or
            more statements.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.SelectionResult.CheckNodesInSelection(System.Func{Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts,Microsoft.CodeAnalysis.SyntaxNode,System.Boolean})">
            <summary>
            Checks all of the nodes within the user's selection to see if any of them satisfy the supplied <paramref
            name="predicate"/>. Will not descend into local functions or lambdas.
            </summary>
            <param name="predicate"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.SelectionResult.GetFlowAnalysisNodeRange">
            <summary>f
            convert text span to node range for the flow analysis API
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.SelectionResult.AddAnnotations(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{System.ValueTuple{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxAnnotation}})">
            <summary>
            create a new root node from the given root after adding annotations to the tokens
            
            tokens should belong to the given root
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`3.SelectionResult.AddAnnotations(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{System.ValueTuple{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxAnnotation}})">
            <summary>
            create a new root node from the given root after adding annotations to the nodes
            
            nodes should belong to the given root
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.Extensions.GetTokenWithAnnotation(Microsoft.CodeAnalysis.SemanticDocument,Microsoft.CodeAnalysis.SyntaxAnnotation)">
            <summary>
            get tokens with given annotation in current document
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.Extensions.ResolveType``1(Microsoft.CodeAnalysis.SemanticModel,``0)">
            <summary>
            resolve the given symbol against compilation this snapshot has
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.Extensions.HasDiagnostics(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            check whether node contains error for itself but not from its child node
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodFlowControlInformation">
            <summary>
            Holds onto fine-grained information about the types of flow control constructs seen in a selection being extracted.
            If there are two or more different flow control types seen, then information about that flow control is will need to
            be passed out from the extracted method to the caller.  If this is the case, then <see cref="M:Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodFlowControlInformation.NeedsControlFlowValue"
            /> will return true.  When <see langword="true"/> the type needed to pass back that information will be exposed in
            <see cref="F:Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodFlowControlInformation.ControlFlowValueType"/>.  When <see langword="false"/> the type will be <see cref="T:System.Void"/>.
            <para/> A mapping between flow control kind and a specific flow control value to use to represent it will be
            created.  That mapping can be queried using the <see cref="M:Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodFlowControlInformation.TryGetBreakFlowValue(System.Object@)"/> helper (and siblings).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodFlowControlInformation.HasUniformControlFlow">
            <summary>
            Returns <see langword="true"/> if the selection returns the same way across all paths.  For example,
            'continue'ing across all paths, or `return`ing across all paths.  In this case, the extracted method doesn't
            need to actually return a flow control value, and the caller can uniformly execute that same control flow
            construct after calling the extracted method..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodResult.Succeeded">
            <summary>
            True if the extract method operation succeeded.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodResult.Reasons">
            <summary>
            The reasons why the extract method operation did not succeed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ExtractMethod.ITriviaSavedResult">
            <summary>
            contains information to restore trivia later on to the annotated tree
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ExtractMethod.ITriviaSavedResult.Root">
            <summary>
            root node of the annotated tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.ITriviaSavedResult.RestoreTrivia(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ExtractMethod.AnnotationResolver,Microsoft.CodeAnalysis.ExtractMethod.TriviaResolver)">
            <summary>
            restore saved trivia to given tree
            </summary>
            <param name="root">root node to the annotated tree</param>
            <param name="annotationResolver">it provides a custom way of resolving annotations to retrieve right tokens to attach trivia</param>
            <param name="triviaResolver">it provides a custom way of creating trivia list between two tokens</param>
            <returns>root node to a trivia restored tree</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ExtractMethod.ISyntaxTriviaService">
            <summary>
            syntax trivia related services
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.ISyntaxTriviaService.SaveTriviaAroundSelection(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            save trivia around span and let user restore trivia later
            </summary>
            <param name="root">root node of a tree</param>
            <param name="textSpan">selection whose trivia around its edges will be saved</param>
            <returns>object that holds onto enough information to restore trivia later</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.OperationStatus.Create``1(Microsoft.CodeAnalysis.ExtractMethod.OperationStatus,``0)">
            <summary>
            create operation status with the given data
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ExtractMethod.OperationStatus`1">
            <summary>
            operation status paired with data
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ExtractMethod.OperationStatus`1.#ctor(Microsoft.CodeAnalysis.ExtractMethod.OperationStatus,`0)">
            <summary>
            operation status paired with data
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindUsages.AbstractFindUsagesService.DefinitionTrackingContext">
            <summary>
            Forwards <see cref="T:Microsoft.CodeAnalysis.FindUsages.IFindUsagesContext"/> notifications to an underlying <see cref="T:Microsoft.CodeAnalysis.FindUsages.IFindUsagesContext"/>
            while also keeping track of the <see cref="T:Microsoft.CodeAnalysis.FindUsages.DefinitionItem"/> definitions reported.
            
            These can then be used by <see cref="M:Microsoft.CodeAnalysis.FindUsages.AbstractFindUsagesService.GetThirdPartyDefinitionsAsync(Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.FindUsages.DefinitionItem},System.Threading.CancellationToken)"/> to report the
            definitions found to third parties in case they want to add any additional definitions
            to the results we present.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindUsages.AbstractFindUsagesService.DefinitionTrackingContext.#ctor(Microsoft.CodeAnalysis.FindUsages.IFindUsagesContext)">
            <summary>
            Forwards <see cref="T:Microsoft.CodeAnalysis.FindUsages.IFindUsagesContext"/> notifications to an underlying <see cref="T:Microsoft.CodeAnalysis.FindUsages.IFindUsagesContext"/>
            while also keeping track of the <see cref="T:Microsoft.CodeAnalysis.FindUsages.DefinitionItem"/> definitions reported.
            
            These can then be used by <see cref="M:Microsoft.CodeAnalysis.FindUsages.AbstractFindUsagesService.GetThirdPartyDefinitionsAsync(Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.FindUsages.DefinitionItem},System.Threading.CancellationToken)"/> to report the
            definitions found to third parties in case they want to add any additional definitions
            to the results we present.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindUsages.AbstractFindUsagesService.FindLiteralsProgressAdapter">
            <summary>
            Forwards <see cref="T:Microsoft.CodeAnalysis.FindSymbols.IStreamingFindLiteralReferencesProgress"/> calls to an
            <see cref="T:Microsoft.CodeAnalysis.FindUsages.IFindUsagesContext"/> instance.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindUsages.AbstractFindUsagesService.FindLiteralsProgressAdapter.#ctor(Microsoft.CodeAnalysis.FindUsages.IFindUsagesContext,Microsoft.CodeAnalysis.OptionsProvider{Microsoft.CodeAnalysis.Classification.ClassificationOptions},Microsoft.CodeAnalysis.FindUsages.DefinitionItem)">
            <summary>
            Forwards <see cref="T:Microsoft.CodeAnalysis.FindSymbols.IStreamingFindLiteralReferencesProgress"/> calls to an
            <see cref="T:Microsoft.CodeAnalysis.FindUsages.IFindUsagesContext"/> instance.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindUsages.AbstractFindUsagesService.FindReferencesProgressAdapter">
            <summary>
            Forwards IFindReferencesProgress calls to an IFindUsagesContext instance.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindUsages.AbstractFindUsagesService.FindReferencesProgressAdapter.#ctor(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.FindUsages.IFindUsagesContext,Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchOptions,Microsoft.CodeAnalysis.OptionsProvider{Microsoft.CodeAnalysis.Classification.ClassificationOptions})">
            <summary>
            Forwards IFindReferencesProgress calls to an IFindUsagesContext instance.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindUsages.AbstractFindUsagesService.FindReferencesProgressAdapter._definitionToItem">
            <summary>
            We will hear about definition symbols many times while performing FAR.  We'll
            here about it first when the FAR engine discovers the symbol, and then for every
            reference it finds to the symbol.  However, we only want to create and pass along
            a single instance of <see cref="T:Microsoft.CodeAnalysis.Navigation.INavigableItem" /> for that definition no matter
            how many times we see it.
            
            This dictionary allows us to make that mapping once and then keep it around for
            all future callbacks.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindUsages.AbstractFindUsagesService.FindSymbolReferencesAsync(Microsoft.CodeAnalysis.FindUsages.IFindUsagesContext,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.OptionsProvider{Microsoft.CodeAnalysis.Classification.ClassificationOptions},System.Threading.CancellationToken)">
            <summary>
            Public helper that we use from features like ObjectBrowser which start with a symbol
            and want to push all the references to it into the Streaming-Find-References window.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindUsages.AssemblyLocation">
            <summary>
            Describes an assembly (source or metadata) that contains a found symbol definition or usage.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindUsages.AssemblyLocation.#ctor(System.String,System.Version,System.String)">
            <summary>
            Describes an assembly (source or metadata) that contains a found symbol definition or usage.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindUsages.DefaultExternalDefinitionItemProvider.GetThirdPartyDefinitionItemAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.FindUsages.DefinitionItem,System.Threading.CancellationToken)">
            <summary>
            Provides an extension point that allows for other workspace layers to add additional
            results to the results found by the FindReferences engine.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindUsages.DefinitionItem">
            <summary>
            Information about a symbol's definition that can be displayed in an editor
            and used for navigation.
            
            Standard implementations can be obtained through the various <see cref="T:Microsoft.CodeAnalysis.FindUsages.DefinitionItem"/>.Create overloads.
            
            Subclassing is also supported for scenarios that fall outside the bounds of
            these common cases.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindUsages.DefinitionItem.Primary">
            <summary>
            The definition item corresponding to the initial symbol the user was trying to find. This item should get
            prominent placement in the final UI for the user.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindUsages.DefinitionItem.MetadataSymbolKey">
            <summary>
            For metadata symbols we encode information in the <see cref="P:Microsoft.CodeAnalysis.FindUsages.DefinitionItem.Properties"/> so we can 
            retrieve the symbol later on when navigating.  This is needed so that we can go to
            metadata-as-source for metadata symbols.  We need to store the <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/>
            for the symbol and the project ID that originated the symbol.  With these we can correctly recover the symbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindUsages.DefinitionItem.NonNavigable">
            <summary>
            If this item is something that cannot be navigated to.  We store this in our
            <see cref="P:Microsoft.CodeAnalysis.FindUsages.DefinitionItem.Properties"/> to act as an explicit marker that navigation is not possible.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.DefinitionItem.Tags">
            <summary>
            Descriptive tags from <see cref="T:Microsoft.CodeAnalysis.Tags.WellKnownTags"/>. These tags may influence how the 
            item is displayed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.DefinitionItem.Properties">
            <summary>
            Additional properties that can be attached to the definition for clients that want to
            keep track of additional data.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.DefinitionItem.DisplayableProperties">
            <summary>
            Additional displayable properties that can be attached to the definition for clients that want to display
            additional data.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.DefinitionItem.NameDisplayParts">
            <summary>
            The DisplayParts just for the name of this definition.  Generally used only for 
            error messages.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.DefinitionItem.DisplayParts">
            <summary>
            The full display parts for this definition.  Displayed in a classified 
            manner when possible.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.DefinitionItem.SourceSpans">
            <summary>
            Additional locations to present in the UI.  A definition may have multiple locations 
            for cases like partial types/members.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.DefinitionItem.ClassifiedSpans">
            <summary>
            Precomputed classified spans for the corresponding <see cref="P:Microsoft.CodeAnalysis.FindUsages.DefinitionItem.SourceSpans"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.DefinitionItem.MetadataLocations">
            <summary>
            Identities of assemblies that contain the metadata for this definition.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.DefinitionItem.DisplayIfNoReferences">
            <summary>
            Whether or not this definition should be presented if we never found any references to
            it.  For example, when searching for a property, the FindReferences engine will cascade
            to the accessors in case any code specifically called those accessors (can happen in 
            cross-language cases).  However, in the normal case where there were no calls specifically
            to the accessor, we would not want to display them in the UI.  
            
            For most definitions we will want to display them, even if no references were found.  
            This property allows for this customization in behavior.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindUsages.DefinitionItem.DefaultDefinitionItem">
            <summary>
            Implementation of a <see cref="T:Microsoft.CodeAnalysis.FindUsages.DefinitionItem"/> that sits on top of a 
            <see cref="T:Microsoft.CodeAnalysis.DocumentSpan"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindUsages.DefinitionItem.DefaultDefinitionItem.#ctor(System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.TaggedText},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.TaggedText},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DocumentSpan},System.Collections.Immutable.ImmutableArray{System.Nullable{Microsoft.CodeAnalysis.Classification.ClassifiedSpansAndHighlightSpan}},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.FindUsages.AssemblyLocation},System.Collections.Immutable.ImmutableDictionary{System.String,System.String},System.Collections.Immutable.ImmutableArray{System.ValueTuple{System.String,System.String}},System.Boolean)">
            <summary>
            Implementation of a <see cref="T:Microsoft.CodeAnalysis.FindUsages.DefinitionItem"/> that sits on top of a 
            <see cref="T:Microsoft.CodeAnalysis.DocumentSpan"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindUsages.DefinitionsAndReferences">
            <summary>
            A collection of <see cref="T:Microsoft.CodeAnalysis.FindUsages.DefinitionItem"/>s and <see cref="T:Microsoft.CodeAnalysis.FindUsages.SourceReferenceItem"/>s
            that can be presented in an editor and used to navigate to the defintions and
            references found for a symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.DefinitionsAndReferences.Definitions">
            <summary>
            All the definitions to show.  Note: not all definitions may have references.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.DefinitionsAndReferences.References">
            <summary>
            All the references to show.  Note: every <see cref="P:Microsoft.CodeAnalysis.FindUsages.SourceReferenceItem.Definition"/> 
            should be in <see cref="P:Microsoft.CodeAnalysis.FindUsages.DefinitionsAndReferences.Definitions"/> 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindUsages.FindUsagesHelpers.GetRelevantSymbolAndProjectAtPositionAsync(Microsoft.CodeAnalysis.Document,System.Int32,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Common helper for both the synchronous and streaming versions of FAR. It returns the symbol we want to search
            for and the solution we should be searching.
            <para/> Note that the <see cref="T:Microsoft.CodeAnalysis.Solution"/> returned may absolutely *not* be the same as
            <c>document.Project.Solution</c>.  This is because there may be symbol mapping involved (for example in
            Metadata-As-Source scenarios).
            </summary>
            <param name="preferPrimaryConstructor">Whether the named type or primary constructor should be preferred if the
            position is on a type-header fof a type declaration that has primary constructor parameters.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.IFindUsagesContext.ProgressTracker">
            <summary>
            Used for clients that are finding usages to push information about how far along they
            are in their search.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindUsages.IFindUsagesContext.ReportNoResultsAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Report a message that the find operation returned no results.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindUsages.IFindUsagesContext.ReportMessageAsync(System.String,Microsoft.CodeAnalysis.Notification.NotificationSeverity,System.Threading.CancellationToken)">
            <summary>
            Report a message to be displayed to the user. This may appear to the user in the results
            UI in some fashion (for example: in an info-bar).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindUsages.IFindUsagesContext.SetSearchTitleAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Set the title of the window that results are displayed in.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindUsages.IFindUsagesLSPService.FindReferencesAsync(Microsoft.CodeAnalysis.FindUsages.IFindUsagesContext,Microsoft.CodeAnalysis.Document,System.Int32,Microsoft.CodeAnalysis.OptionsProvider{Microsoft.CodeAnalysis.Classification.ClassificationOptions},System.Threading.CancellationToken)">
            <summary>
            Finds the references for the symbol at the specific position in the document,
            pushing the results into the context instance.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindUsages.IFindUsagesLSPService.FindImplementationsAsync(Microsoft.CodeAnalysis.FindUsages.IFindUsagesContext,Microsoft.CodeAnalysis.Document,System.Int32,Microsoft.CodeAnalysis.OptionsProvider{Microsoft.CodeAnalysis.Classification.ClassificationOptions},System.Threading.CancellationToken)">
            <summary>
            Finds the implementations for the symbol at the specific position in the document,
            pushing the results into the context instance.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindUsages.IFindUsagesService.FindReferencesAsync(Microsoft.CodeAnalysis.FindUsages.IFindUsagesContext,Microsoft.CodeAnalysis.Document,System.Int32,Microsoft.CodeAnalysis.OptionsProvider{Microsoft.CodeAnalysis.Classification.ClassificationOptions},System.Threading.CancellationToken)">
            <summary>
            Finds the references for the symbol at the specific position in the document,
            pushing the results into the context instance.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindUsages.IFindUsagesService.FindImplementationsAsync(Microsoft.CodeAnalysis.FindUsages.IFindUsagesContext,Microsoft.CodeAnalysis.Document,System.Int32,Microsoft.CodeAnalysis.OptionsProvider{Microsoft.CodeAnalysis.Classification.ClassificationOptions},System.Threading.CancellationToken)">
            <summary>
            Finds the implementations for the symbol at the specific position in the document,
            pushing the results into the context instance.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindUsages.SourceReferenceItem">
            <summary>
            Information about a symbol's reference that can be used for display and 
            navigation in an editor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.SourceReferenceItem.Definition">
            <summary>
            The definition this reference corresponds to.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.SourceReferenceItem.SourceSpan">
            <summary>
            The location of the source item.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.SourceReferenceItem.ClassifiedSpans">
            <summary>
            Precomputed classified spans for the corresponding <see cref="P:Microsoft.CodeAnalysis.FindUsages.SourceReferenceItem.SourceSpan"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.SourceReferenceItem.IsWrittenTo">
            <summary>
            If this reference is a location where the definition is written to.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.SourceReferenceItem.SymbolUsageInfo">
            <summary>
            Symbol usage info associated with the reference.
            This entry indicates that the reference has additional usage information, such as
            it is a read/write reference for 'a++'.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindUsages.SourceReferenceItem.AdditionalProperties">
            <summary>
            Additional properties for the reference.
            For example, { "ContainingTypeInfo" } = { "MyClass" }
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.INewDocumentFormattingProvider.FormatNewDocumentAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.CodeCleanup.CodeCleanupOptions,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Formatting.INewDocumentFormattingService.FormatNewDocumentAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.CodeCleanup.CodeCleanupOptions,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.INewDocumentFormattingService.FormatNewDocumentAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.CodeCleanup.CodeCleanupOptions,System.Threading.CancellationToken)">
            <summary>
            Formats a new document that is being added to a project from the Add New Item dialog.
            </summary>
            <param name="document">The document to format.</param>
            <param name="hintDocument">An optional additional document that can be used to inform the formatting operation.</param>
            <param name="cancellationToken">A cancellation token.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.GenerateConstructors.AbstractGenerateConstructorsCodeRefactoringProvider">
            <summary>
            This <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider"/> is responsible for allowing a user to pick a set of members from a class
            or struct, and then generate a constructor for that takes in matching parameters and assigns them to those members.
            The members can be picked using a actual selection in the editor, or they can be picked using a picker control that
            will then display all the viable members and allow the user to pick which ones they want to use.
            <para/>
            This <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider"/> also gives users a way to generate constructors for a derived type that
            delegate to a base type.  For all accessible constructors in the base type, the user will be offered to create a
            constructor in the derived type with the same signature if they don't already have one.  This way, a user can
            override a type and easily create all the forwarding constructors.
            <para/>
            Importantly, this type is not responsible for generating constructors when the user types something like "new
            MyType(x, y, z)".
            </summary>
            <remarks>
            For testing purposes only.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GenerateConstructors.AbstractGenerateConstructorsCodeRefactoringProvider.#ctor(Microsoft.CodeAnalysis.PickMembers.IPickMembersService)">
            <summary>
            This <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider"/> is responsible for allowing a user to pick a set of members from a class
            or struct, and then generate a constructor for that takes in matching parameters and assigns them to those members.
            The members can be picked using a actual selection in the editor, or they can be picked using a picker control that
            will then display all the viable members and allow the user to pick which ones they want to use.
            <para/>
            This <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider"/> also gives users a way to generate constructors for a derived type that
            delegate to a base type.  For all accessible constructors in the base type, the user will be offered to create a
            constructor in the derived type with the same signature if they don't already have one.  This way, a user can
            override a type and easily create all the forwarding constructors.
            <para/>
            Importantly, this type is not responsible for generating constructors when the user types something like "new
            MyType(x, y, z)".
            </summary>
            <remarks>
            For testing purposes only.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.AbstractGenerateEqualsAndGetHashCodeService.FormatLargeBinaryExpressionRule">
            <summary>
            Specialized formatter for the "return a == obj.a &amp;&amp; b == obj.b &amp;&amp; c == obj.c &amp;&amp; ...
            code that we spit out.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.AbstractGenerateEqualsAndGetHashCodeService.FormatLargeBinaryExpressionRule.#ctor(Microsoft.CodeAnalysis.LanguageService.ISyntaxFactsService)">
            <summary>
            Specialized formatter for the "return a == obj.a &amp;&amp; b == obj.b &amp;&amp; c == obj.c &amp;&amp; ...
            code that we spit out.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.AbstractGenerateEqualsAndGetHashCodeService.FormatLargeBinaryExpressionRule.GetAdjustNewLinesOperation(Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.Formatting.Rules.NextGetAdjustNewLinesOperation@)">
            <summary>
            Wrap the large &amp;&amp; expression after every &amp;&amp; token.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.AbstractGenerateEqualsAndGetHashCodeService.FormatLargeBinaryExpressionRule.AddIndentBlockOperations(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Formatting.Rules.NextIndentBlockOperationAction@)">
            <summary>
            Align all the wrapped parts of the expression with the token after 'return'.
            That way we get:
            
            return a == obj.a &amp;&amp;
                   b == obj.b &amp;&amp;
                   ...
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.IGenerateEqualsAndGetHashCodeService">
            <summary>
            Service that can be used to generate <see cref="M:System.Object.Equals(System.Object)"/> and
            <see cref="M:System.Object.GetHashCode"/> overloads for use from other IDE features.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.IGenerateEqualsAndGetHashCodeService.FormatDocumentAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptions,System.Threading.CancellationToken)">
            <summary>
            Formats only the members in the provided document that were generated by this interface.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.IGenerateEqualsAndGetHashCodeService.GenerateEqualsMethodAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISymbol},System.String,System.Threading.CancellationToken)">
            <summary>
            Generates an override of <see cref="M:System.Object.Equals(System.Object)"/> that works by comparing the
            provided <paramref name="members"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.IGenerateEqualsAndGetHashCodeService.GenerateEqualsMethodThroughIEquatableEqualsAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Generates an override of <see cref="M:System.Object.Equals(System.Object)"/> that works by delegating to
            <see cref="M:System.IEquatable`1.Equals(`0)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.IGenerateEqualsAndGetHashCodeService.GenerateIEquatableEqualsMethodAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISymbol},Microsoft.CodeAnalysis.INamedTypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Generates an implementation of <see cref="M:System.IEquatable`1.Equals(`0)"/> that works by
            comparing the provided <paramref name="members"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.IGenerateEqualsAndGetHashCodeService.GenerateGetHashCodeMethodAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISymbol},System.Threading.CancellationToken)">
            <summary>
            Generates an override of <see cref="M:System.Object.GetHashCode"/> that computes a reasonable
            hash based on the provided <paramref name="members"/>.  The generated function will
            defer to HashCode.Combine if it exists.  Otherwise, it will determine if it should
            generate code directly in-line to compute the hash, or defer to something like
            <see cref="M:System.ValueTuple.GetHashCode"/> to provide a reasonable alternative.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GenerateFromMembers.GenerateFromMembersHelpers.DetermineParameters(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingRule})">
            <summary>
            Returns an array of parameter symbols that correspond to selected member symbols.
            If a selected member symbol has an empty base identifier name, the parameter symbol will not be added.
            </summary>
            <param name="selectedMembers"></param>
            <param name="rules"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GoToBase.IGoToBaseService.FindBasesAsync(Microsoft.CodeAnalysis.FindUsages.IFindUsagesContext,Microsoft.CodeAnalysis.Document,System.Int32,Microsoft.CodeAnalysis.OptionsProvider{Microsoft.CodeAnalysis.Classification.ClassificationOptions},System.Threading.CancellationToken)">
            <summary>
            Finds the base members overridden or implemented by the symbol at the specific position in the document,
            pushing the results into the context instance.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GoToDefinition.IGoToDefinitionSymbolService.GetTargetIfControlFlowAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SemanticModel,System.Int32,System.Threading.CancellationToken)">
            <summary>
            If the position is on a control flow keyword (continue, break, yield, return , etc), returns the relevant position in the corresponding control flow statement.
            Otherwise, returns null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Highlighting.IHighlightingService.AddHighlights(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Collections.Generic.List{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
            <summary>
            Adds all the relevant highlihts to <paramref name="highlights"/> given the specified
            <paramref name="position"/> in the tree.
            <para/>
            Highlights will be unique and will be in sorted order. All highlights will be non-empty.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImplementInterface.AbstractImplementInterfaceService`1.ImplementInterfaceGenerator.AttributesToRemove(Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Lists compiler attributes that we want to remove.
            The TupleElementNames attribute is compiler generated (it is used for naming tuple element names).
            We never want to place it in source code.
            Same thing for the Dynamic attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ImplementInterface.ImplementInterfaceInfo.ClassOrStructType">
            <summary>
            The class or struct that is implementing the interface.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ImplementInterface.ImplementInterfaceInfo.ContextNode">
            <summary>
            The specific declaration node for <see cref="P:Microsoft.CodeAnalysis.ImplementInterface.ImplementInterfaceInfo.ClassOrStructType"/> that the interface implementations should be
            added to.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ImplementInterface.ImplementInterfaceInfo.InterfaceTypes">
            <summary>
            Set of interfaces to implement.  Normally a single interface (when a user invokes the code action on a single
            entry in the interface-list for a type).  However, it may be multiple in the VB case where a user presses
            'enter' at the end of the interfaces list, where we'll implement all the missing members for all listed interfaces.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImplementInterface.IImplementInterfaceService.ImplementInterfaceMember(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.ImplementInterface.ImplementInterfaceInfo,Microsoft.CodeAnalysis.ImplementType.ImplementTypeOptions,Microsoft.CodeAnalysis.ImplementInterface.ImplementInterfaceConfiguration,Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Produces the symbol that implements that provided <paramref name="interfaceMember"/> within the corresponding
            <see cref="P:Microsoft.CodeAnalysis.ImplementInterface.ImplementInterfaceInfo.ClassOrStructType"/>, based on the provided <paramref name="options"/> and
            <paramref name="configuration"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.InheritanceMargin.AbstractInheritanceMarginService.GetMembers(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Given the syntax nodes to search,
            get all the method, event, property and type declaration syntax nodes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.InheritanceMargin.AbstractInheritanceMarginService.GetDeclarationToken(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Get the token that represents declaration node.
            e.g. Identifier for method/property/event and this keyword for indexer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.InheritanceMargin.AbstractInheritanceMarginService.GetImplementingSymbolsForTypeMemberAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)">
            <summary>
            For the <param name="memberSymbol"/>, get all the implementing symbols.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.InheritanceMargin.AbstractInheritanceMarginService.GetOverriddenSymbols(Microsoft.CodeAnalysis.ISymbol,System.Boolean)">
            <summary>
            Get overridden members the <param name="memberSymbol"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.InheritanceMargin.AbstractInheritanceMarginService.GetDerivedTypesAndImplementationsAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Get the derived interfaces and derived classes for <param name="typeSymbol"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.InheritanceMargin.AbstractInheritanceMarginService.ToSlimDefinitionItem(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution)">
            <summary>
            Create the DefinitionItem based on the numbers of locations for <paramref name="symbol"/>.
            If there is only one location, create the DefinitionItem contains only the documentSpan or symbolKey to save memory.
            Because in such case, when clicking InheritanceMarginGlpph, it will directly navigate to the symbol.
            Otherwise, create the full non-classified DefinitionItem. Because in such case we want to display all the locations to the user
            by reusing the FAR window.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.InheritanceMargin.IInheritanceMarginService.GetInheritanceMemberItemsAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Boolean,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Get information about
            1. The inheritance chain of the member in given span.
            2. The global imports for the document.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InheritanceMargin.InheritanceMarginItem.LineNumber">
            <summary>
            Line number used to show the margin for the member.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InheritanceMargin.InheritanceMarginItem.TopLevelDisplayText">
            <summary>
            Special display text to show when showing the 'hover' tip for a margin item.  Used to override the default
            text we show that says "'X' is inherited".  Used currently for showing information about top-level-imports.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InheritanceMargin.InheritanceMarginItem.DisplayTexts">
            <summary>
            Display texts for this member.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InheritanceMargin.InheritanceMarginItem.Glyph">
            <summary>
            Member's glyph.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InheritanceMargin.InheritanceMarginItem.TargetItems">
            <summary>
            An array of the implementing/implemented/overriding/overridden targets for this member.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.InheritanceMargin.InheritanceRelationship">
            <summary>
            Indicate the relationship between the member and its inheritance target
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InheritanceMargin.InheritanceRelationship.None">
            <summary>
            A default case that should not be used.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InheritanceMargin.InheritanceRelationship.ImplementedInterface">
            <summary>
            Implented interfaces for class or struct. Shown as I
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InheritanceMargin.InheritanceRelationship.BaseType">
            <summary>
            Base type for class or struct. Shown as O
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InheritanceMargin.InheritanceRelationship.DerivedType">
            <summary>
            Derived type for class or struct. Shown as O
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InheritanceMargin.InheritanceRelationship.InheritedInterface">
            <summary>
            Inherited interface for interface. Shown as I
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InheritanceMargin.InheritanceRelationship.ImplementingType">
            <summary>
            Implementing class, struct and interface for interface. Shown as I
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InheritanceMargin.InheritanceRelationship.ImplementedMember">
            <summary>
            Implemented member for member in class or structure. Shown as I
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InheritanceMargin.InheritanceRelationship.OverriddenMember">
            <summary>
            Overridden member for member in class or structure. Shown as O
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InheritanceMargin.InheritanceRelationship.OverridingMember">
            <summary>
            Overrrding member for member in class or structure. Shown as O
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InheritanceMargin.InheritanceRelationship.ImplementingMember">
            <summary>
            Implmenting member for member in interface. Shown as I
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InheritanceMargin.InheritanceRelationship.InheritedImport">
            <summary>
            An import directive inherited from the global scope.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.InheritanceMargin.InheritanceTargetItem">
            <summary>
            Information used to decided the margin image and responsible for performing navigations
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InheritanceMargin.InheritanceTargetItem.RelationToMember">
            <summary>
            Indicate the inheritance relationship between the target and member.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InheritanceMargin.InheritanceTargetItem.DefinitionItem">
            <summary>
            DefinitionItem used to display the additional information and performs navigation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InheritanceMargin.InheritanceTargetItem.Glyph">
            <summary>
            The glyph for this target.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InheritanceMargin.InheritanceTargetItem.LanguageGlyph">
            <summary>
            The glyph for source language. Used to disambiguate results when multiple targets have the same name.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InheritanceMargin.InheritanceTargetItem.DisplayName">
            <summary>
            The display name used in margin.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InheritanceMargin.InheritanceTargetItem.ProjectName">
            <summary>
            Name of the project the symbol is defined in (if known).  Used to disambiguate results when multiple targets
            have the same name and same language.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.InitializeParameter.AbstractAddParameterCheckCodeRefactoringProvider`6.TryFindParameterCheckStatement(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.IParameterSymbol,Microsoft.CodeAnalysis.Operations.IBlockOperation,System.Threading.CancellationToken)">
            <summary>
            Tries to find an if-statement that looks like it is checking the provided parameter
            in some way.  If we find a match, we'll place our new check statement before/after
            this statement as appropriate.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.InlineHints.IInlineParameterNameHintsService">
            <summary>
            Gets inline hints for type locations.  This is an internal service only for C# and VB.  Use <see
            cref="T:Microsoft.CodeAnalysis.InlineHints.IInlineHintsService"/> for other languages.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.InlineHints.IInlineTypeHintsService">
            <summary>
            Gets inline hints for type locations.  This is an internal service only for C# and VB.  Use <see
            cref="T:Microsoft.CodeAnalysis.InlineHints.IInlineHintsService"/> for other languages.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.InlineHints.InlineHint.GetDescriptionAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Gets a description for the inline hint, suitable to show when a user hovers over the editor adornment.  The
            <paramref name="document"/> will represent the file at the time this hint was created.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.InlineHints.InlineHintsConstants">
            <summary>
            Used as a tiebreaker to position coincident type and parameter hints.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InlineHints.InlineHintsConstants.ParameterRanking">
            <summary>
            Parameter hints will always appear first.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InlineHints.InlineHintsConstants.TypeRanking">
            <summary>
            Type hints will always appear second.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4.TemporaryName">
            <summary>
            A preferred name used to generated a declaration when the
            inline method's body is not a valid expression in ExpressionStatement
            Example:
            void Caller()
            {
                Callee();
            }
            int Callee()
            {
                return 1;
            };
            After it should be:
            void Caller()
            {
                int temp = 1;
            }
            int Callee()
            {
                return 1;
            };
            '1' is not a valid expression in ExpressionStatement so a declaration is needed to be generated.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4.IsValidExpressionUnderExpressionStatement(`2)">
            <summary>
            Check if <paramref name="expressionNode"/> could be used as an Expression in ExpressionStatement
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4.CanBeReplacedByThrowExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Check if <paramref name="syntaxNode"/> could be replaced by ThrowExpression.
            For VB it always return false because ThrowExpression doesn't exist.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4.InlineMethodContext.StatementsToInsertBeforeInvocationOfCallee">
            <summary>
            Statements that should be inserted to before the invocation location of callee.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4.InlineMethodContext.InlineExpression">
            <summary>
            Inline content for the callee method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4.InlineMethodContext.ContainsAwaitExpression">
            <summary>
            Indicate if <see cref="P:Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4.InlineMethodContext.InlineExpression"/> has AwaitExpression in it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4.ComputeReplacementTable(Microsoft.CodeAnalysis.IMethodSymbol,System.Collections.Immutable.ImmutableArray{System.ValueTuple{Microsoft.CodeAnalysis.IParameterSymbol,System.String}},System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.IParameterSymbol,`2},Microsoft.CodeAnalysis.Editing.SyntaxGenerator,System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ISymbol,System.String})">
            <summary>
            Generate a dictionary which key is the symbol in Callee (include local variable and parameter), value
            is the replacement syntax node for all its occurence.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4.MethodParametersInfo">
            <summary>
            Information about the callee method parameters to compute <see cref="T:Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4.InlineMethodContext"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4.MethodParametersInfo.#ctor(System.Collections.Immutable.ImmutableArray{System.ValueTuple{Microsoft.CodeAnalysis.IParameterSymbol,System.String}},System.Collections.Immutable.ImmutableArray{System.ValueTuple{Microsoft.CodeAnalysis.IParameterSymbol,`2}},System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.IParameterSymbol,`2},System.Boolean)">
            <summary>
            Information about the callee method parameters to compute <see cref="T:Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4.InlineMethodContext"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4.MethodParametersInfo.ParametersWithVariableDeclarationArgument">
             <summary>
             Parameters map to variable declaration argument's name.
             This is only used for C# to support the 'out' variable declaration. For VB it should always be empty.
             Before:
             void Caller()
             {
                 Callee(out var x);
             }
             void Callee(out int i) => i = 100;
            
             After:
             void Caller()
             {
                 int x = 100;
             }
             void Callee(out int i) => i = 100;
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4.MethodParametersInfo.ParametersToGenerateFreshVariablesFor">
            <summary>
            Operations that represent Parameter has argument but the argument is not identifier or literal.
            For these parameters they are considered to be put into a declaration statement after inlining.
            Note: params array could maps to multiple/zero arguments.
            Example:
            Before:
            void Caller(bool x)
            {
                Callee(Foo(), x ? Foo() : Bar())
            }
            void Callee(int a, int b)
            {
                DoSomething(a, b);
            }
            After:
            void Caller(bool x)
            {
                int a = Foo();
                int b = x ? Foo() : Bar();
                DoSomething(a, b);
            }
            void Callee(int a, int b)
            {
                DoSomething(a, b);
            }
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4.MethodParametersInfo.ParametersToReplace">
            <summary>
            A dictionary that contains Parameter that should be directly replaced. Key is the parameter and Value is the replacement exprssion
            It includes
            1. Parameter mapping to literal expression
            2. Parameter that has default value, and it has no argument. It should be replaced by the default value.
            3. Parameter mapping to identifier expression
            Before:
            void Caller(int i, int j, bool[] k)
            {
                Callee(i, j, k);
            }
            void Callee(int a, int b, params bool[] c)
            {
                DoSomething(a, b, c);
            }
            After:
            void Caller(int i, int j, bool[] k)
            {
                DoSomething(i, j, k);
            }
            void Callee(int a, int b, params bool[] c)
            {
                DoSomething(a, b, c);
            }
            4. A special case, the parameter is only read once in the callee method body
            Before:
            void Caller(bool x)
            {
                Callee(Foo(), Bar())
            }
            void Callee(int a, int b)
            {
                DoSomething(a, b);
            }
            After:
            void Caller(bool x)
            {
                DoSomething(Foo(), Bar());
            }
            void Callee(int a, int b)
            {
                DoSomething(a, b);
            }
            In this case, parameters 'a' and 'b' should just be replaced by the argument expression.
            Note: this might cause semantics changes. It is by design.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4.MethodParametersInfo.MergeInlineContentAndVariableDeclarationArgument">
            <summary>
            Indicate should inline expression and variable declaration be merged into one line.
            Example:
            Before:
            void Caller()
            {
                Callee(out var x);
            }
            void Callee(out int i) => i = 100;
            After:
            (Correct version)
            void Caller()
            {
                int x = 100;
            }
            void Callee(out int i) => i = 100;
            (Wrong version)
            void Caller()
            {
                int x;
                x = 100;
            }
            void Callee(out int i) => i = 100;
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4.GetArgumentsReadOnlyOnceAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Operations.IArgumentOperation},`0,System.Threading.CancellationToken)">
            <summary>
            Check if the parameter is referenced only once, and it is referenced as 'read'.
            Determine a special case for a parameter that should be replaced by the argument instead of generating a declaration
            for it.
            Example:
            Before:
            void Caller(bool x)
            {
                Callee(Foo(), Bar())
            }
            void Callee(int a, int b)
            {
                DoSomething(a, b);
            }
            After:
            void Caller(bool x)
            {
                DoSomething(Foo(), Bar());
            }
            void Callee(int a, int b)
            {
                DoSomething(a, b);
            }
            Parameters 'a' and 'b' are used only once in the Callee, and their value are read not write.
            For this case just use the argument to replace the parameter.
            Note: This might cause a semantic change. In the previous example, if it is
            void Caller(bool x)
            {
                Callee(Foo(), Bar())
            }
            void Callee(int a, int b)
            {
                DoSomething(b, a);
            }
            Then this operation will change the order of evaluation but is acceptable for a refactoring
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4.ShouldMergeInlineContentAndVariableDeclarationArgumentAsync(Microsoft.CodeAnalysis.Document,`3,System.Collections.Immutable.ImmutableArray{System.ValueTuple{Microsoft.CodeAnalysis.IParameterSymbol,System.String}},`2,System.Threading.CancellationToken)">
             <summary>
             Check if there is only one variable declaration argument and it is used for assignment
             in the method body. In this case, the method body and argument will be merged into one statement.
             For example:
             Before:
             void Caller()
             {
                 Callee(out var x);
             }
             void Callee(out int i) => i = 100;
            
             After:
             void Caller()
             {
                 int x = 100;
             }
             void Callee(out int i) => i = 100;
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.InternalLanguageNames">
            <summary>
            A class that provides constants for internal partner language names.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IntroduceParameter.AbstractIntroduceParameterCodeRefactoringProvider`5.GetActionsAsync(Microsoft.CodeAnalysis.Document,`0,Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Creates new code actions for each introduce parameter possibility.
            Does not create actions for overloads/trampoline if there are optional parameters or if the methodSymbol
            is a constructor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IntroduceParameter.AbstractIntroduceParameterCodeRefactoringProvider`5.ShouldExpressionDisplayCodeActionAsync(Microsoft.CodeAnalysis.Document,`0,System.Threading.CancellationToken)">
            <summary>
            Determines if the expression is something that should have code actions displayed for it.
            Depends upon the identifiers in the expression mapping back to parameters.
            Does not handle params parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IntroduceParameter.AbstractIntroduceParameterCodeRefactoringProvider`5.IntroduceParameterAsync(Microsoft.CodeAnalysis.Document,`0,Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.Document,System.Collections.Generic.List{`0}},System.Boolean,Microsoft.CodeAnalysis.IntroduceParameter.AbstractIntroduceParameterCodeRefactoringProvider{`0,`1,`2,`3,`4}.IntroduceParameterCodeActionKind,System.Threading.CancellationToken)">
            <summary>
            Introduces a new parameter and refactors all the call sites based on the selected code action.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IntroduceParameter.AbstractIntroduceParameterCodeRefactoringProvider`5.FindCallSitesAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.IMethodSymbol,System.Threading.CancellationToken)">
            <summary>
            Locates all the call sites of the method that introduced the parameter
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IntroduceParameter.AbstractIntroduceParameterCodeRefactoringProvider`5.IntroduceParameterDocumentRewriter.MapExpressionToParametersAsync(System.Threading.CancellationToken)">
            <summary>
            Ties the identifiers within the expression back to their associated parameter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IntroduceParameter.AbstractIntroduceParameterCodeRefactoringProvider`5.IntroduceParameterDocumentRewriter.GetNewParameterNameAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the parameter name, if the expression's grandparent is a variable declarator then it just gets the
            local declarations name. Otherwise, it generates a name based on the context of the expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IntroduceParameter.AbstractIntroduceParameterCodeRefactoringProvider`5.IntroduceParameterDocumentRewriter.ShouldRemoveVariableDeclaratorContainingExpression(System.String@,Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            Determines if the expression's grandparent is a variable declarator and if so,
            returns the name
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IntroduceParameter.AbstractIntroduceParameterCodeRefactoringProvider`5.IntroduceParameterDocumentRewriter.GetInsertionIndex(Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Goes through the parameters of the original method to get the location that the parameter
            and argument should be introduced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IntroduceParameter.AbstractIntroduceParameterCodeRefactoringProvider`5.IntroduceParameterDocumentRewriter.ModifyDocumentInvocationsTrampolineOverloadAndIntroduceParameterAsync(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.Document,System.Collections.Generic.List{`0},System.Int32,System.Threading.CancellationToken)">
            <summary>
            For the trampoline case, it goes through the invocations and adds an argument which is a 
            call to the extracted method.
            Introduces a new method overload or new trampoline method.
            Updates the original method site with a newly introduced parameter.
            
            ****Trampoline Example:****
            public void M(int x, int y)
            {
                int f = [|x * y|];
                Console.WriteLine(f);
            }
            
            public void InvokeMethod()
            {
                M(5, 6);
            }
            
            ---------------------------------------------------->
            
            public int GetF(int x, int y) // Generated method
            {
                return x * y;
            }
            
            public void M(int x, int y, int f)
            {
                Console.WriteLine(f);
            }
            
            public void InvokeMethod()
            {
                M(5, 6, GetF(5, 6)); //Fills in with call to generated method
            }
            
            -----------------------------------------------------------------------
            ****Overload Example:****
            public void M(int x, int y)
            {
                int f = [|x * y|];
                Console.WriteLine(f);
            }
            
            public void InvokeMethod()
            {
                M(5, 6);
            }
            
            ---------------------------------------------------->
            
            public void M(int x, int y) // Generated overload
            {
                M(x, y, x * y)
            }
            
            public void M(int x, int y, int f)
            {
                Console.WriteLine(f);
            }
            
            public void InvokeMethod()
            {
                M(5, 6);
            }
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IntroduceParameter.AbstractIntroduceParameterCodeRefactoringProvider`5.IntroduceParameterDocumentRewriter.ExtractMethodAsync(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IParameterSymbol},System.String,Microsoft.CodeAnalysis.Editing.SyntaxGenerator,System.Threading.CancellationToken)">
            <summary>
            Generates a method declaration containing a return expression of the highlighted expression.
            Example:
            public void M(int x, int y)
            {
                int f = [|x * y|];
            }
            
            ---------------------------------------------------->
            
            public int GetF(int x, int y)
            {
                return x * y;
            }
            
            public void M(int x, int y)
            {
                int f = x * y;
            }
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IntroduceParameter.AbstractIntroduceParameterCodeRefactoringProvider`5.IntroduceParameterDocumentRewriter.GenerateNewMethodOverloadAsync(System.Int32,Microsoft.CodeAnalysis.Editing.SyntaxGenerator,System.Threading.CancellationToken)">
            <summary>
            Generates a method declaration containing a call to the method that introduced the parameter.
            Example:
            
            ***This is an intermediary step in which the original function has not be updated yet
            public void M(int x, int y)
            {
                int f = [|x * y|];
            }
            
            ---------------------------------------------------->
            
            public void M(int x, int y) // Generated overload
            {
                M(x, y, x * y);
            }
            
            public void M(int x, int y) // Original function (which will be mutated in a later step)
            {
                int f = x * y;
            }
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IntroduceParameter.AbstractIntroduceParameterCodeRefactoringProvider`5.IntroduceParameterDocumentRewriter.ModifyDocumentInvocationsAndIntroduceParameterAsync(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.Document,System.Int32,System.Collections.Generic.List{`0},System.Threading.CancellationToken)">
            <summary>
            This method goes through all the invocation sites and adds a new argument with the expression to be added.
            It also introduces a parameter at the original method site.
            
            Example:
            public void M(int x, int y)
            {
                int f = [|x * y|];
            }
            
            public void InvokeMethod()
            {
                M(5, 6);
            }
            
            ---------------------------------------------------->
            
            public void M(int x, int y, int f) // parameter gets introduced
            {
            }
            
            public void InvokeMethod()
            {
                M(5, 6, 5 * 6); // argument gets added to callsite
            }
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IntroduceParameter.AbstractIntroduceParameterCodeRefactoringProvider`5.IntroduceParameterDocumentRewriter.CreateNewArgumentExpression(Microsoft.CodeAnalysis.Editing.SyntaxEditor,System.Collections.Generic.Dictionary{`3,Microsoft.CodeAnalysis.IParameterSymbol},System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.IParameterSymbol,System.Int32},Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            This method iterates through the variables in the expression and maps the variables back to the parameter
            it is associated with. It then maps the parameter back to the argument at the invocation site and gets the
            index to retrieve the updated arguments at the invocation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IntroduceParameter.AbstractIntroduceParameterCodeRefactoringProvider`5.IntroduceParameterDocumentRewriter.AddArgumentToArgumentList(Microsoft.CodeAnalysis.SeparatedSyntaxList{`4},Microsoft.CodeAnalysis.SyntaxNode,System.String,System.Int32,System.Boolean)">
            <summary>
            If the parameter is optional and the invocation does not specify the parameter, then
            a named argument needs to be introduced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IntroduceParameter.AbstractIntroduceParameterCodeRefactoringProvider`5.IntroduceParameterDocumentRewriter.UpdateExpressionInOriginalFunctionAsync(Microsoft.CodeAnalysis.Editing.SyntaxEditor,System.Threading.CancellationToken)">
            <summary>
            Gets the matches of the expression and replaces them with the identifier.
            Special case for the original matching expression, if its parent is a LocalDeclarationStatement then it can
            be removed because assigning the local dec variable to a parameter is repetitive. Does not need a rename
            annotation since the user has already named the local declaration.
            Otherwise, it needs to have a rename annotation added to it because the new parameter gets a randomly
            generated name that the user can immediately change.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IntroduceParameter.AbstractIntroduceParameterCodeRefactoringProvider`5.IntroduceParameterDocumentRewriter.FindMatchesAsync(System.Threading.CancellationToken)">
            <summary>
            Finds the matches of the expression within the same block.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IntroduceUsingStatement.AbstractIntroduceUsingStatementCodeRefactoringProvider`4.IsLegalUsingStatementType(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Up to date with C# 7.3. Pattern-based disposal is likely to be added to C# 8.0,
            in which case accessible instance and extension methods will need to be detected.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IntroduceUsingStatement.AbstractIntroduceUsingStatementCodeRefactoringProvider`4.AddReferencedLocalVariables(System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.ISymbol},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.ISymbol},Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.LanguageService.ISyntaxFactsService,System.Threading.CancellationToken)">
            <summary>
            Adds local variables that are being referenced within a statement to a set of symbols.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.InvertLogical.AbstractInvertLogicalCodeRefactoringProvider`3">
            <summary>
            Code refactoring to help convert code like `!a || !b` to `!(a &amp;&amp; b)`
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.InvertLogical.AbstractInvertLogicalCodeRefactoringProvider`3.s_annotation">
            <summary>
            See comment in <see cref="M:Microsoft.CodeAnalysis.InvertLogical.AbstractInvertLogicalCodeRefactoringProvider`3.InvertLogicalAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)"/> to understand the need for this annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.AbstractSymbolDisplayService.AbstractSymbolDescriptionBuilder.AddCaptures(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            If the symbol is a local or anonymous function (lambda or delegate), adds the variables captured
            by that local or anonymous function to the "Captures" group.
            </summary>
            <param name="symbol"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.AbstractSymbolDisplayService.AbstractSymbolDescriptionBuilder.AddCaptures(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Given the body of a local or an anonymous function (lambda or delegate), add the variables captured
            by that local or anonymous function to the "Captures" group.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LegacySolutionEvents.ILegacySolutionEventsAggregationService">
            <summary>
            This is a legacy api intended only for existing SolutionCrawler partners to continue to function (albeit with
            ownership of that crawling task now belonging to the partner team, not roslyn).  It should not be used for any
            new services.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LegacySolutionEvents.ILegacySolutionEventsListener">
            <summary>
            This is a legacy api intended only for existing SolutionCrawler partners to continue to function (albeit with
            ownership of that crawling task now belonging to the partner team, not roslyn).  It should not be used for any
            new services.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LegacySolutionEvents.IRemoteLegacySolutionEventsAggregationService">
            <summary>
            This is a legacy api intended only for existing SolutionCrawler partners to continue to function (albeit with
            ownership of that crawling task now belonging to the partner team, not roslyn).  It should not be used for any
            new services.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LegacySolutionEvents.IRemoteLegacySolutionEventsAggregationService.OnWorkspaceChangedAsync(Microsoft.CodeAnalysis.Checksum,Microsoft.CodeAnalysis.Checksum,Microsoft.CodeAnalysis.WorkspaceChangeKind,Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.DocumentId,System.Threading.CancellationToken)">
            <param name="oldSolutionChecksum"><inheritdoc cref="P:Microsoft.CodeAnalysis.WorkspaceChangeEventArgs.OldSolution"/></param>
            <param name="newSolutionChecksum"><inheritdoc cref="P:Microsoft.CodeAnalysis.WorkspaceChangeEventArgs.NewSolution"/></param>
            <param name="kind"><inheritdoc cref="P:Microsoft.CodeAnalysis.WorkspaceChangeEventArgs.Kind"/></param>
            <param name="projectId"><inheritdoc cref="P:Microsoft.CodeAnalysis.WorkspaceChangeEventArgs.ProjectId"/></param>
            <param name="documentId"><inheritdoc cref="P:Microsoft.CodeAnalysis.WorkspaceChangeEventArgs.DocumentId"/></param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MapCode.IMapCodeService">
            <summary>
            A service to identify, map, and integrate code snippets obtained from the AI model into a target document. 
            A Mapper's primary responsibility is twofold:
            <list>
             <item>Replace existing code. The mapper should determine if the code provided by the model already exists in the target and needs to be replaced.</item>
             <item>Insert new code. The mapper should recognize new code and identify the correct location for its insertion in the target document.</item> 
            </list>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MapCode.IMapCodeService.MapCodeAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{System.ValueTuple{Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan}},System.Threading.CancellationToken)">
            <summary>
            Map code snippets into the target document.
            </summary>
            <param name="document">Target document for mapping.</param>
            <param name="contents">Code snippets that we we are attempting to map into the target document.</param>
            <param name="prioritizedFocusLocations">Prioritized Locations to be used when applying heuristics. For example, cursor location, related classes (in other documents), viewport, etc. Earlier items should be considered higher priority.</param>
            <returns>Resulting text changes from mapping code snippets into the document; or <see langword="null"/> if mapping failed.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataAsSource.AbstractMetadataAsSourceService.CompatAbstractMetadataFormattingRule.AddSuppressOperationsSlow(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.Formatting.Rules.SuppressOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Formatting.Rules.NextSuppressOperationAction@)">
            <summary>
            Returns SuppressWrappingIfOnSingleLineOperations under a node either by itself or by
            filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataAsSource.AbstractMetadataAsSourceService.CompatAbstractMetadataFormattingRule.AddAnchorIndentationOperationsSlow(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.AnchorIndentationOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Formatting.Rules.NextAnchorIndentationOperationAction@)">
            <summary>
            returns AnchorIndentationOperations under a node either by itself or by filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataAsSource.AbstractMetadataAsSourceService.CompatAbstractMetadataFormattingRule.AddIndentBlockOperationsSlow(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Formatting.Rules.NextIndentBlockOperationAction@)">
            <summary>
            returns IndentBlockOperations under a node either by itself or by filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataAsSource.AbstractMetadataAsSourceService.CompatAbstractMetadataFormattingRule.AddAlignTokensOperationsSlow(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Formatting.Rules.NextAlignTokensOperationAction@)">
            <summary>
            returns AlignTokensOperations under a node either by itself or by filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataAsSource.AbstractMetadataAsSourceService.CompatAbstractMetadataFormattingRule.GetAdjustNewLinesOperationSlow(Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.Formatting.Rules.NextGetAdjustNewLinesOperation@)">
            <summary>
            returns AdjustNewLinesOperation between two tokens either by itself or by filtering/replacing a operation returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataAsSource.AbstractMetadataAsSourceService.CompatAbstractMetadataFormattingRule.GetAdjustSpacesOperationSlow(Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.Formatting.Rules.NextGetAdjustSpacesOperation@)">
            <summary>
            returns AdjustSpacesOperation between two tokens either by itself or by filtering/replacing a operation returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataAsSource.AbstractMetadataAsSourceService.GetFormattingRules(Microsoft.CodeAnalysis.Document)">
            <summary>
            provide formatting rules to be used when formatting MAS file
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataAsSource.AbstractMetadataAsSourceService.AddAssemblyInfoRegionAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)">
            <summary>
            Prepends a region directive at the top of the document with a name containing
            information about the assembly and a comment inside containing the path to the
            referenced assembly.  The containing assembly may not have a path on disk, in which case
            a string similar to "location unknown" will be placed in the comment inside the region
            instead of the path.
            </summary>
            <param name="document">The document to generate source into</param>
            <param name="symbolCompilation">The <see cref="T:Microsoft.CodeAnalysis.Compilation"/> in which symbol is resolved.</param>
            <param name="symbol">The symbol to generate source for</param>
            <param name="cancellationToken">To cancel document operations</param>
            <returns>The updated document</returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataAsSource.DecompilationMetadataAsSourceFileProvider._gate">
            <summary>
            Guards access to <see cref="F:Microsoft.CodeAnalysis.MetadataAsSource.DecompilationMetadataAsSourceFileProvider._openedDocumentIds"/> and workspace updates when opening / closing documents.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataAsSource.DecompilationMetadataAsSourceFileProvider._keyToInformation">
            <summary>
            Accessed only in <see cref="M:Microsoft.CodeAnalysis.MetadataAsSource.DecompilationMetadataAsSourceFileProvider.GetGeneratedFileAsync(Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceWorkspace,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.ISymbol,System.Boolean,Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceOptions,System.String,Microsoft.CodeAnalysis.MetadataAsSource.TelemetryMessage,System.Threading.CancellationToken)"/> and <see cref="M:Microsoft.CodeAnalysis.MetadataAsSource.DecompilationMetadataAsSourceFileProvider.CleanupGeneratedFiles(Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceWorkspace)"/>, both of which
            are called under a lock in <see cref="T:Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceFileService"/>.  So this is safe as a plain
            dictionary.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataAsSource.DecompilationMetadataAsSourceFileProvider._generatedFilenameToInformation">
            <summary>
            Accessed both in <see cref="M:Microsoft.CodeAnalysis.MetadataAsSource.DecompilationMetadataAsSourceFileProvider.GetGeneratedFileAsync(Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceWorkspace,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.ISymbol,System.Boolean,Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceOptions,System.String,Microsoft.CodeAnalysis.MetadataAsSource.TelemetryMessage,System.Threading.CancellationToken)"/> and in UI thread operations.  Those should not
            generally run concurrently.  However, to be safe, we make this a concurrent dictionary to be safe to that
            potentially happening.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataAsSource.DecompilationMetadataAsSourceFileProvider._openedDocumentIds">
            <summary>
            Only accessed and mutated from UI thread.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataAsSource.DecompilationMetadataAsSourceFileProvider.UniqueDocumentKey._filePath">
            <summary>
            The path to the assembly. Null in the case of in-memory assemblies, where we then use assembly identity.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataAsSource.DecompilationMetadataAsSourceFileProvider.UniqueDocumentKey._assemblyIdentity">
            <summary>
            Assembly identity. Only non-null if <see cref="F:Microsoft.CodeAnalysis.MetadataAsSource.DecompilationMetadataAsSourceFileProvider.UniqueDocumentKey._filePath"/> is null, where it's an in-memory assembly.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataAsSource.ExportMetadataAsSourceFileProviderAttribute">
            <summary>
            Use this attribute to export a <see cref="T:Microsoft.CodeAnalysis.MetadataAsSource.IMetadataAsSourceFileProvider"/> so that it will
            be found and used by the <see cref="T:Microsoft.CodeAnalysis.MetadataAsSource.IMetadataAsSourceFileService"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataAsSource.ExportMetadataAsSourceFileProviderAttribute.#ctor(System.String)">
            <summary>
            Use this attribute to export a <see cref="T:Microsoft.CodeAnalysis.MetadataAsSource.IMetadataAsSourceFileProvider"/> so that it will
            be found and used by the <see cref="T:Microsoft.CodeAnalysis.MetadataAsSource.IMetadataAsSourceFileService"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataAsSource.IMetadataAsSourceFileProvider.GetGeneratedFileAsync(Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceWorkspace,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.ISymbol,System.Boolean,Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceOptions,System.String,Microsoft.CodeAnalysis.MetadataAsSource.TelemetryMessage,System.Threading.CancellationToken)">
            <summary>
            Generates a file from metadata. Will be called under a lock to prevent concurrent access.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataAsSource.IMetadataAsSourceFileProvider.CleanupGeneratedFiles(Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceWorkspace)">
            <summary>
            Called to clean up any state. Will be called under a lock to prevent concurrent access.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataAsSource.IMetadataAsSourceFileProvider.TryAddDocumentToWorkspace(Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceWorkspace,System.String,Microsoft.CodeAnalysis.Text.SourceTextContainer,Microsoft.CodeAnalysis.DocumentId@)">
            <summary>
            Called when the file returned from <see cref="M:Microsoft.CodeAnalysis.MetadataAsSource.IMetadataAsSourceFileProvider.GetGeneratedFileAsync(Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceWorkspace,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.ISymbol,System.Boolean,Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceOptions,System.String,Microsoft.CodeAnalysis.MetadataAsSource.TelemetryMessage,System.Threading.CancellationToken)"/> needs to be added to the workspace,
            to be opened.  Will be called on the main thread of the workspace host.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataAsSource.IMetadataAsSourceFileProvider.TryRemoveDocumentFromWorkspace(Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceWorkspace,System.String)">
            <summary>
            Called when the file is being closed, and so needs to be removed from the workspace.  Will be called on the
            main thread of the workspace host.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataAsSource.IMetadataAsSourceFileProvider.ShouldCollapseOnOpen(Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceWorkspace,System.String,Microsoft.CodeAnalysis.Structure.BlockStructureOptions)">
            <summary>
            Called to determine if the file should be collapsed by default when opened for the first time.  Will be
            called on the main thread of the workspace host.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataAsSource.IMetadataAsSourceFileProvider.MapDocument(Microsoft.CodeAnalysis.Document)">
            <summary>
            Maps from a document to its project for the purposes of symbol mapping via <see cref="T:Microsoft.CodeAnalysis.SymbolMapping.ISymbolMappingService"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataAsSource.IMetadataAsSourceFileService.GetGeneratedFileAsync(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.ISymbol,System.Boolean,Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceOptions,System.Threading.CancellationToken)">
            <summary>
            Generates a file on disk containing general information about the symbol's containing assembly, and the
            formatted source code for the public, protected, and protected-or-internal interface of which the given
            ISymbol is or is a part of.
            </summary>
            <param name="sourceWorkspace">The workspace that <paramref name="sourceProject"/> came from.</param>
            <param name="sourceProject">The project from which the symbol to generate source for came from.</param>
            <param name="symbol">The symbol whose interface to generate source for</param>
            <param name="signaturesOnly"><see langword="false"/> to allow a decompiler or other technology to show a
            representation of the original sources; otherwise <see langword="true"/> to only show member
            signatures.</param>
            <param name="options">Options to use when navigating. See <see cref="T:Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceOptions"/> for details.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataAsSource.IMetadataAsSourceFileService.TryAddDocumentToWorkspace(System.String,Microsoft.CodeAnalysis.Text.SourceTextContainer,Microsoft.CodeAnalysis.DocumentId@)">
            <summary>
            Checks if the given file path is a metadata as source file and adds to the metadata workspace if it is.
            Callers must ensure this is only called serially.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataAsSource.IMetadataAsSourceFileService.TryRemoveDocumentFromWorkspace(System.String)">
            <summary>
            Checks if the given file path is a metadata as source file and removes from the metadata workspace if it is.
            Callers must ensure this is only called serially.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataAsSource.IMetadataAsSourceService.AddSourceToAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptions,System.Threading.CancellationToken)">
            <summary>
            Generates formatted source code containing general information about the symbol's
            containing assembly, and the public, protected, and protected-or-internal interface of
            which the given ISymbol is or is a part of into the given document
            </summary>
            <param name="document">The document to generate source into</param>
            <param name="symbolCompilation">The <see cref="T:Microsoft.CodeAnalysis.Compilation"/> in which <paramref name="symbol"/> is resolved.</param>
            <param name="symbol">The symbol to generate source for</param>
            <param name="formattingOptions">Options to use to format the generated document, or null to use the <paramref name="document"/>'s options.</param>
            
            <returns>The updated document</returns>
            <param name="cancellationToken">To cancel document operations</param>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceFileService._providers">
            <summary>
            Set of providers that can be used to generate source for a symbol (for example, by decompiling, or by
            extracting it from a pdb).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceFileService._workspace">
            <summary>
            Workspace created the first time we generate any metadata for any symbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceFileService._gate">
            <summary>
            A lock to ensure we initialize <see cref="F:Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceFileService._workspace"/> and cleanup stale data only once.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceFileService._mutex">
            <summary>
            We create a mutex so other processes can see if our directory is still alive.  As long as we own the mutex, no
            other VS instance will try to delete our _rootTemporaryPathWithGuid folder.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceGeneratedFileInfo.GetProjectInfoAndDocumentId(Microsoft.CodeAnalysis.Host.SolutionServices,System.Boolean)">
            <summary>
            Creates a ProjectInfo to represent the fake project created for metadata as source documents.
            </summary>
            <param name="services">Solution services.</param>
            <param name="loadFileFromDisk">Whether the source file already exists on disk and should be included. If
            this is a false, a document is still created, but it's not backed by the file system and thus we won't
            try to load it.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceHelpers">
            <summary>
            Helpers shared by both the text service and the editor service
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceOptions">
            <summary>
            Options for metadata as source navigation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceOptions.#ctor">
            <summary>
            Options for metadata as source navigation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceOptions.NavigateToDecompiledSources">
            <summary>
            <see langword="false"/> to disallow decompiling code, which may
            result in signagures only being returned if there is no other non-decompilation option available
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceOptions.AlwaysUseDefaultSymbolServers">
            <summary>
            Whether navigation should try to use the default Microsoft and
            Nuget symbol servers regardless of debugger settings
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceOptions.NavigateToSourceLinkAndEmbeddedSources">
            <summary>
            <see langword="false"/> to disallow downloading PDBs and trying to find source from
            Source Link or embedded source.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MoveStaticMembers.MoveStaticMembersWithDialogCodeAction.GetNewTypeKind(Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Finds what type kind new type should be. Currently, we just select whatever type the source is.
            This means always a class for C#, and a module for VB iff we moved from a module
            This functionality can later be expanded or moved to language-specific implementations
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MoveStaticMembers.MoveStaticMembersWithDialogCodeAction.RefactorAndMoveAsync(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Immutable.ImmutableArray{System.Int32},Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.DocumentId,System.Threading.CancellationToken)">
            <summary>
            Finds references, refactors them, then moves the selected members to the destination.
            Used when the destination type/file already exists.
            </summary>
            <param name="selectedMembers">selected member symbols</param>
            <param name="oldMemberNodes">nodes corresponding to those symbols in the old solution, should have been annotated</param>
            <param name="oldSolution">solution without any members moved/refactored</param>
            <param name="newType">the type to move to, should be inserted into a document already</param>
            <param name="typeArgIndices">generic type arg indices to keep when refactoring generic class access to the new type. Empty if not relevant</param>
            <param name="sourceDocId">Id of the document where the mebers are being moved from</param>
            <returns>The solution with references refactored and members moved to the newType</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.MoveToNamespace.MoveToNamespaceCodeAction.Tags">
            <summary>
            This code action does notify clients about the rename it performs.  However, this is an optional part of
            this work, that happens after the move has happened.  As such, this does not require non document changes
            and can run in all our hosts.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.NavigateTo.AbstractNavigateToSearchService.s_cachedIndexMap">
            <summary>
            Cached map from document key to the (potentially stale) syntax tree index for it we use prior to the 
            full solution becoming available.  Once the full solution is available, this will be dropped
            (set to <see langword="null"/>) to release all cached data.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.NavigateTo.AbstractNavigateToSearchService.s_stringTable">
            <summary>
            String table we use to dedupe common values while deserializing <see cref="T:Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeIndex"/>s.  Once the 
            full solution is available, this will be dropped (set to <see langword="null"/>) to release all cached data.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.NavigateTo.INavigateToSearcherHost">
            <summary>
            Host interface abstracting over all the external functionality the <see cref="T:Microsoft.CodeAnalysis.NavigateTo.NavigateToSearcher"/> needs. This
            provide an easy entry point for swapping out functionality of the host, including for testing purposes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.NavigateTo.INavigateToSearcherHost.IsFullyLoadedAsync(System.Threading.CancellationToken)">
            <summary>
            Returns the fully loaded state for both the project system and the remote host.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.NavigateTo.DefaultNavigateToSearchHost.s_gate">
            <summary>
            Single task used to both hydrate the remote host with the initial workspace solution,
            and track if that work completed.  Prior to it completing, we will try to get all
            navigate-to requests from our caches.  Once it is populated though, we can attempt to
            use the latest data instead.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.NavigateTo.DefaultNavigateToSearchHost.GetRemoteHostHydrateTask">
            <summary>
            If we're in a solution that is using OOP, this kicks off a task to get the oop side in
            sync with us.  Until that happens, we'll continue to use the cached results from prior
            sessions so that we can get results very quickly right after launch without forcing the
            user to wait for OOP to hydrate the entire solution over.  This strikes a good balance
            of speed and accuracy as most of the time cached results will be fast and good enough,
            and eventually (usually within dozens of seconds, even for large projects) we will
            switch over to full and accurate results which can also come back quickly.
            </summary>
            <remarks>
            If we do report cached data, we inform the user of this so they know the results may be
            incomplete or inaccurate and that they can try again later if necessary.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.NavigateTo.NavigateToSearchResultHelpers.GetMatches(Microsoft.CodeAnalysis.NavigateTo.INavigateToSearchResult)">
            <summary>
            Helper to bridge from old api that only returned one pattern match, to new API which can return many.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.NavigateTo.INavigateToSearchService.SearchProjectsAsync(Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Project},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Document},System.String,System.Collections.Immutable.IImmutableSet{System.String},Microsoft.CodeAnalysis.Document,System.Func{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.NavigateTo.INavigateToSearchResult},System.Threading.Tasks.Task},System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
            Searches the documents inside <paramref name="projects"/> for symbols that matches <paramref
            name="searchPattern"/>. <paramref name="priorityDocuments"/> is an optional subset of the documents from
            <paramref name="projects"/> that can be used to prioritize work.  Generates files should not be searched.
            Results should be up to date with the actual document contents for the requested project.
            </summary>
            <remarks>
            All the projects passed are guaranteed to be for the language this <see cref="T:Microsoft.CodeAnalysis.NavigateTo.INavigateToSearchService"/>
            belongs to.  Similarly, all the <paramref name="priorityDocuments"/> belong to these projects.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.NavigateTo.IAdvancedNavigateToSearchService">
            <summary>
            Optional expanded API for Navigate-To.  Allows languages to just implement a simpler set of methods if they don't
            offer this extra functionality.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.NavigateTo.IAdvancedNavigateToSearchService.SearchCachedDocumentsAsync(Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Project},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Document},System.String,System.Collections.Immutable.IImmutableSet{System.String},Microsoft.CodeAnalysis.Document,System.Func{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.NavigateTo.INavigateToSearchResult},System.Threading.Tasks.Task},System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
            Searches the documents inside <paramref name="projects"/> for symbols that matches <paramref
            name="searchPattern"/>. Results should be reported from a previous computed cache (even if that cache is out of
            date) to produce results as quickly as possible.
            </summary>
            <remarks>
            All the projects passed are guaranteed to be for the language this <see cref="T:Microsoft.CodeAnalysis.NavigateTo.INavigateToSearchService"/>
            belongs to.  Similarly, all the <paramref name="priorityDocuments"/> belong to these projects.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.NavigateTo.IAdvancedNavigateToSearchService.SearchGeneratedDocumentsAsync(Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Project},System.String,System.Collections.Immutable.IImmutableSet{System.String},Microsoft.CodeAnalysis.Document,System.Func{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.NavigateTo.INavigateToSearchResult},System.Threading.Tasks.Task},System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
            Searches the generated documents inside <paramref name="projects"/> for symbols that matches <paramref
            name="searchPattern"/>.
            </summary>
            <remarks>
            All the projects passed are guaranteed to be for the language this <see cref="T:Microsoft.CodeAnalysis.NavigateTo.INavigateToSearchService"/>
            belongs to.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.NavigateTo.NavigateToSearcher.Create(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListener,Microsoft.CodeAnalysis.NavigateTo.INavigateToSearchCallback,System.String,System.Collections.Immutable.IImmutableSet{System.String},System.Threading.CancellationToken)">
            <summary>
            Creates a searcher using the default host.
            </summary>
            <param name="disposalToken">Disposal token normally provided by <see
            cref="T:Microsoft.CodeAnalysis.Editor.Shared.Utilities.IThreadingContext.DisposalToken"/>.  Used to control
            the lifetime of internal async work within the default host.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.NavigateTo.NavigateToSearcher.GetOrderedProjectsToProcess">
            <summary>
            Returns a sequence of groups of projects to process.  The sequence is in priority order, and all projects in
            a particular group should be processed before the next group.  This allows us to associate CPU resources in
            likely areas the user wants, while also still allowing for good parallelization.  Specifically, we consider
            the active-document the most important to get results for, as some users use navigate-to to navigate within
            the doc they are editing.  So we want those results to appear as quick as possible, without the search for
            them contending with the searches for other projects for CPU time.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.NavigateTo.NavigateToSearcher.GetPriorityDocuments(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Project})">
            <summary>
            Given a search within a particular project, this returns any documents within that project that should take
            precedence when searching.  This allows results to get to the user more quickly for common cases (like using
            nav-to to find results in the file you currently have open
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.NavigateTo.NavigateToSearchResultComparer">
            <summary>
            Comparer that considers to navigate to results the same if they will navigate to the same document and span.
            This ensures that we don't see tons of results for the same symbol when a file is linked into many projects.
            <para/>
            This also has the impact that a linked file (say from a shared project) will only show up for a single project
            that it is linked into. This is believed to actually be desirable as showing multiple hits for effectively the
            same symbol, just for different projects just feels like clutter in the UI without real benefit for the user
            (since navigating will just take the user to the same location).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.NavigateTo.RoslynNavigateToItem">
            <summary>
            Data about a navigate to match.  Only intended for use by C# and VB.  Carries enough rich information to
            rehydrate everything needed quickly on either the host or remote side.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.NavigateTo.RoslynNavigateToItem.#ctor(System.Boolean,Microsoft.CodeAnalysis.Storage.DocumentKey,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ProjectId},Microsoft.CodeAnalysis.FindSymbols.DeclaredSymbolInfo,System.String,Microsoft.CodeAnalysis.NavigateTo.NavigateToMatchKind,System.Boolean,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.PatternMatching.PatternMatch})">
            <summary>
            Data about a navigate to match.  Only intended for use by C# and VB.  Carries enough rich information to
            rehydrate everything needed quickly on either the host or remote side.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.NavigateTo.RoslynNavigateToItem.Kind">
            <summary>
            Will be one of the values from <see cref="T:Microsoft.CodeAnalysis.NavigateTo.NavigateToItemKind"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.NavigateTo.RoslynNavigateToItem.NavigateToSearchResult._itemDocument">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.Document"/> that <see cref="F:Microsoft.CodeAnalysis.NavigateTo.RoslynNavigateToItem.NavigateToSearchResult._item"/> is contained within.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.NavigateTo.RoslynNavigateToItem.NavigateToSearchResult._activeDocument">
            <summary>
            The document the user was editing when they invoked the navigate-to operation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.NavigateTo.RoslynNavigateToItem.NavigateToSearchResult.Microsoft#CodeAnalysis#Navigation#INavigableItem#IsImplicitlyDeclared">
            <summary>
            DeclaredSymbolInfos always come from some actual declaration in source.  So they're
            never implicitly declared.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.NavigationBar.RoslynNavigationBarItem">
            <summary>
            Base type of all C#/VB navigation bar items.  Only for use internally to roslyn.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.NavigationBar.RoslynNavigationBarItem.ActionlessItem">
            <summary>
            An item that is displayed and can be chosen but which has no action.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.NavigationBar.RoslynNavigationBarItem.ActionlessItem.#ctor(System.String,Microsoft.CodeAnalysis.Glyph,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.NavigationBar.RoslynNavigationBarItem},System.Int32,System.Boolean,System.Boolean)">
            <summary>
            An item that is displayed and can be chosen but which has no action.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.NavigationBar.RoslynNavigationBarItem.SymbolItemLocation.InDocumentInfo">
            <summary>
            The entity spans and navigation span in the originating document where this symbol was found.  Any time
            the caret is within any of the entity spans, the item should be appropriately 'selected' in whatever UI
            is displaying these.  The navigation span is the location in the starting document that should be
            navigated to when this item is selected If this symbol's location is in another document then this will
            be <see langword="null"/>.
            </summary>
            <remarks>Exactly one of <see cref="F:Microsoft.CodeAnalysis.NavigationBar.RoslynNavigationBarItem.SymbolItemLocation.InDocumentInfo"/> and <see cref="F:Microsoft.CodeAnalysis.NavigationBar.RoslynNavigationBarItem.SymbolItemLocation.OtherDocumentInfo"/> will be
            non-null.</remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.NavigationBar.RoslynNavigationBarItem.SymbolItemLocation.OtherDocumentInfo">
            <summary>
            The document and navigation span this item should navigate to when the definition is not in the
            originating document. This is used for partial symbols where a child symbol is declared in another file,
            but should still be shown in the UI when in a part in a different file.
            </summary>
            <remarks>Exactly one of <see cref="F:Microsoft.CodeAnalysis.NavigationBar.RoslynNavigationBarItem.SymbolItemLocation.InDocumentInfo"/> and <see cref="F:Microsoft.CodeAnalysis.NavigationBar.RoslynNavigationBarItem.SymbolItemLocation.OtherDocumentInfo"/> will be
            non-null.</remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Navigation.ICrossLanguageSymbolNavigationService">
            <summary>
            Service to allow 3rd party languages to handle navigating to some metadata symbol.  For example, this can allow
            a language like F# to navigate to its source definition of a symbol that roslyn views as a metadata symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Navigation.ICrossLanguageSymbolNavigationService.TryGetNavigableLocationAsync(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Attempts to get location that can be navigated to for a particular symbol id.  The symbol id format is
            defined at: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/xmldoc/#id-strings.  Should
            return <see langword="null"/> if the 3rd party language cannot navigate to this particular symbol.
            </summary>
            <param name="assemblyName">The name of the assembly the symbol was defined in. Can be used by the
            receiver to quickly filter down to the project/compilation search for the symbol.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Navigation.IDefinitionLocationService">
            <summary>
            Service used by "go to definition" and "ctrl-click on symbol" to find the symbol definition location and navigate to
            it. Specifically, services that do not intend to show any interesting UI for the symbol definition, they just intend
            to navigate to it.  If richer information is desired (like determining what to display for the symbol name), then 
            <see cref="T:Microsoft.CodeAnalysis.Navigation.INavigableItemsService"/> should be used instead.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Navigation.IDefinitionLocationService.GetDefinitionLocationAsync(Microsoft.CodeAnalysis.Document,System.Int32,System.Threading.CancellationToken)">
            <summary>
            If the supplied <paramref name="position"/> is on a code construct with a navigable location, then this
            returns that <see cref="T:Microsoft.CodeAnalysis.Navigation.INavigableLocation"/>.  The <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> returned in the span of the
            symbol in the code that references that navigable location.  e.g. the full identifier token that the
            position is within.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Navigation.DefinitionLocation">
            <summary>
            The result of a <see cref="M:Microsoft.CodeAnalysis.Navigation.IDefinitionLocationService.GetDefinitionLocationAsync(Microsoft.CodeAnalysis.Document,System.Int32,System.Threading.CancellationToken)"/> call.
            </summary>
            <param name="Location">The location where the symbol is actually defined at.  Can be used to then navigate to that
            symbol.
            </param>
            <param name="Span">The <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> returned in the span of the symbol in the code that references that
            navigable location.  e.g. the full identifier token that the position is within.  Can be used to highlight/underline
            that text in the document in some fashion.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Navigation.DefinitionLocation.#ctor(Microsoft.CodeAnalysis.Navigation.INavigableLocation,Microsoft.CodeAnalysis.DocumentSpan)">
            <summary>
            The result of a <see cref="M:Microsoft.CodeAnalysis.Navigation.IDefinitionLocationService.GetDefinitionLocationAsync(Microsoft.CodeAnalysis.Document,System.Int32,System.Threading.CancellationToken)"/> call.
            </summary>
            <param name="Location">The location where the symbol is actually defined at.  Can be used to then navigate to that
            symbol.
            </param>
            <param name="Span">The <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> returned in the span of the symbol in the code that references that
            navigable location.  e.g. the full identifier token that the position is within.  Can be used to highlight/underline
            that text in the document in some fashion.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Navigation.DefinitionLocation.Location">
            <summary>The location where the symbol is actually defined at.  Can be used to then navigate to that
            symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Navigation.DefinitionLocation.Span">
            <summary>The <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> returned in the span of the symbol in the code that references that
            navigable location.  e.g. the full identifier token that the position is within.  Can be used to highlight/underline
            that text in the document in some fashion.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Navigation.IDocumentNavigationService.CanNavigateToSpanAsync(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.TextSpan,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Determines whether it is possible to navigate to the given position in the specified document.
            </summary>
            <remarks>Legal to call from any thread.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Navigation.IDocumentNavigationService.CanNavigateToPositionAsync(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.DocumentId,System.Int32,System.Int32,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Determines whether it is possible to navigate to the given virtual position in the specified document.
            </summary>
            <remarks>Legal to call from any thread.</remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Navigation.INavigableItem.DisplayTaggedParts">
            <summary>
            The tagged parts to display for this item. If default, the line of text from <see
            cref="P:Microsoft.CodeAnalysis.Navigation.INavigableItem.Document"/> is used.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Navigation.INavigableItem.DisplayFileLocation">
            <summary>
            Return true to display the file path of <see cref="P:Microsoft.CodeAnalysis.Navigation.INavigableItem.Document"/> and the span of <see
            cref="P:Microsoft.CodeAnalysis.Navigation.INavigableItem.SourceSpan"/> when displaying this item.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Navigation.INavigableItem.IsImplicitlyDeclared">
            <summary>
            his is intended for symbols that are ordinary symbols in the language sense, and may be
            used by code, but that are simply declared implicitly rather than with explicit language
            syntax.  For example, a default synthesized constructor in C# when the class contains no
            explicit constructors.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Navigation.INavigableItem.IsStale">
            <summary>
            True if this search result represents an item that existed in the past, but which may
            not exist currently, or which may have moved to a different location.  Consumers should
            be resilient to that being the case and not being able to necessarily navigate to the
            <see cref="P:Microsoft.CodeAnalysis.Navigation.INavigableItem.SourceSpan"/> provided.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Navigation.INavigableItem.NavigableDocument.GetRequiredDocumentAsync(Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            Get the <see cref="T:Microsoft.CodeAnalysis.Document"/> within <paramref name="solution"/> which is referenced by
            this navigable item. The document is required to exist within the solution, e.g. a case where the
            navigable item was constructed during a Find Symbols operation on the same solution instance.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Navigation.INavigableItem.NavigableDocument.GetTextAsync(Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            Get the <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> of the <see cref="T:Microsoft.CodeAnalysis.Document"/> within
            <paramref name="solution"/> which is referenced by this navigable item. The document is required to
            exist within the solution, e.g. a case where the navigable item was constructed during a Find Symbols
            operation on the same solution instance.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Navigation.INavigableItemsService">
            <summary>
            Service used for features that want to find all the locations to potentially navigate to for a symbol or its type
            at a particular location, with enough information provided to display those locations in a rich fashion. Differs
            from <see cref="T:Microsoft.CodeAnalysis.Navigation.IDefinitionLocationService"/> in that this can show a rich display of the items, not just navigate
            to them.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Navigation.INavigableItemsService.GetNavigableItemsAsync(Microsoft.CodeAnalysis.Document,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Finds the definitions for the symbol at the specific position in the document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Navigation.INavigableItemsService.GetNavigableItemsAsync(Microsoft.CodeAnalysis.Document,System.Int32,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Finds the definitions for the symbol or its type at the specific position in the document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Navigation.INavigableLocation.NavigateToAsync(Microsoft.CodeAnalysis.Navigation.NavigationOptions,System.Threading.CancellationToken)">
            <summary>
            Navigates to a location opening or presenting it in a UI if necessary.  This work must happen quickly. Any
            expensive async work must be done by whatever component creates this value. This method is async only to
            allow final clients to call this from a non-UI thread while allowing the navigation to jump to the UI
            thread.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Navigation.ISymbolNavigationService.GetNavigableLocationAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)">
            <summary>
            Navigate to the first source location of a given symbol.
            </summary>
            <param name="project">A project context with which to generate source for symbol
            if it has no source locations</param>
            <param name="symbol">The symbol to navigate to</param>
            <param name="cancellationToken">The token to check for cancellation</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Navigation.ISymbolNavigationService.TrySymbolNavigationNotifyAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)">
            <returns>True if the navigation was handled, indicating that the caller should not 
            perform the navigation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Navigation.ISymbolNavigationService.GetExternalNavigationSymbolLocationAsync(Microsoft.CodeAnalysis.FindUsages.DefinitionItem,System.Threading.CancellationToken)">
            <summary>Returns the location file and position we would navigate to for the given <see cref="T:Microsoft.CodeAnalysis.FindUsages.DefinitionItem"/>.</summary>
            <returns>Non-null if the navigation would be handled.</returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Navigation.NavigableItemFactory.SymbolLocationNavigableItem._lazyDocument">
            <summary>
            Lazily-initialized backing field for <see cref="P:Microsoft.CodeAnalysis.Navigation.NavigableItemFactory.SymbolLocationNavigableItem.Document"/>.
            </summary>
            <seealso cref="M:Roslyn.Utilities.InterlockedOperations.Initialize``2(System.Runtime.CompilerServices.StrongBox{``0}@,System.Func{``1,``0},``1)"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Navigation.NavigationOptions">
            <summary>
            Navigation options.
            </summary>
            <param name="PreferProvisionalTab">
            This option can be passed to the <see cref="T:Microsoft.CodeAnalysis.Navigation.IDocumentNavigationService"/> APIs to request that a provisional (or preview) tab 
            be used for any document that needs to be opened, if one is available.
            </param>
            <param name="ActivateTab">
            This option can be passed to the <see cref="T:Microsoft.CodeAnalysis.Navigation.IDocumentNavigationService"/> APIs to request that the navigation should activate the tab.
            The default for the platform is to activate the tab, so turning the option off tells the platform to not activate the tab.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Navigation.NavigationOptions.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Navigation options.
            </summary>
            <param name="PreferProvisionalTab">
            This option can be passed to the <see cref="T:Microsoft.CodeAnalysis.Navigation.IDocumentNavigationService"/> APIs to request that a provisional (or preview) tab 
            be used for any document that needs to be opened, if one is available.
            </param>
            <param name="ActivateTab">
            This option can be passed to the <see cref="T:Microsoft.CodeAnalysis.Navigation.IDocumentNavigationService"/> APIs to request that the navigation should activate the tab.
            The default for the platform is to activate the tab, so turning the option off tells the platform to not activate the tab.
            </param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Navigation.NavigationOptions.PreferProvisionalTab">
            <summary>
            This option can be passed to the <see cref="T:Microsoft.CodeAnalysis.Navigation.IDocumentNavigationService"/> APIs to request that a provisional (or preview) tab 
            be used for any document that needs to be opened, if one is available.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Navigation.NavigationOptions.ActivateTab">
            <summary>
            This option can be passed to the <see cref="T:Microsoft.CodeAnalysis.Navigation.IDocumentNavigationService"/> APIs to request that the navigation should activate the tab.
            The default for the platform is to activate the tab, so turning the option off tells the platform to not activate the tab.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Notification.INotificationService.SendNotification(System.String,System.String,Microsoft.CodeAnalysis.Notification.NotificationSeverity)">
            <summary>
            Displays a message box with an OK button to the user.
            </summary>
            <param name="message">The message shown within the message box.</param>
            <param name="title">The title bar to be shown in the message box. May be ignored by some implementations.</param>
            <param name="severity">The severity of the message.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Notification.INotificationService.ConfirmMessageBox(System.String,System.String,Microsoft.CodeAnalysis.Notification.NotificationSeverity)">
            <summary>
            Displays a message box with a yes/no question to the user.
            </summary>
            <param name="message">The message shown within the message box.</param>
            <param name="title">The title bar to be shown in the message box. May be ignored by some implementations.</param>
            <param name="severity">The severity of the message.</param>
            <returns>true if yes was clicked, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IEditorConfigOptionsEnumerator.GetOptions(System.Boolean)">
            <summary>
            Returns all editorconfig options defined by the implementing language, grouped by feature.
            </summary>
            <param name="includeUnsupported">True to include undocumented options that the user can set in editorconfig file but we provide no support for them.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.OrganizeImports.OrganizeImportsCodeRefactoringProvider.ComputeRequestPriority">
            <summary>
            Matches 'remove unnecessary imports' code fix.  This way we don't show 'sort imports' above it.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.OrganizeImports.OrganizeImportsCodeRefactoringProvider.Cleanup">
            <summary>
            This refactoring provider touches syntax only.  So we can speed up fix all by having it only clean syntax
            and not semantics.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Organizing.IOrganizingService">
            <summary>
            internal interface used to use language specific service from common service layer
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Organizing.IOrganizingService.GetDefaultOrganizers">
            <summary>
            return default organizers
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Organizing.IOrganizingService.OrganizeAsync(Microsoft.CodeAnalysis.Document,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Organizing.Organizers.ISyntaxOrganizer},System.Threading.CancellationToken)">
            <summary>
            Organize document
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Organizing.Organizers.ISyntaxOrganizer.SyntaxNodeTypes">
            <summary>
            syntax node types this organizer is applicable to
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Organizing.Organizers.ISyntaxOrganizer.OrganizeNode(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            organize given node
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Organizing.OrganizingService.OrganizeAsync(Microsoft.CodeAnalysis.Document,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Organizing.Organizers.ISyntaxOrganizer},System.Threading.CancellationToken)">
            <summary>
            Organize the whole document.
            
            Optionally you can provide your own organizers. otherwise, default will be used.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PdbSourceDocument.DocumentDebugInfoReader">
            <summary>
            Gets information from DLL and/or PDB files needed for navigating to source documents
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PdbSourceDocument.IImplementationAssemblyLookupService.TryFindImplementationAssemblyPath(System.String,System.String@)">
            <summary>
            Uses various heuristics to try to find the implementation assembly for a reference assembly without
            loading 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PdbSourceDocument.IImplementationAssemblyLookupService.FollowTypeForwards(Microsoft.CodeAnalysis.ISymbol,System.String,Microsoft.CodeAnalysis.PdbSourceDocument.IPdbSourceDocumentLogger)">
            <summary>
            Given an implementation assembly path, follows any type forwards that might be in place
            for the containing type of <paramref name="symbol"/>, to ensure the right implementation
            assembly will be found.
            </summary>
            <remarks>
            To avoid mutiple reads of a single DLL this method caches all type forwards found in any
            DLL it loads.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PdbSourceDocument.IImplementationAssemblyLookupService.Clear">
            <summary>
            Clears any cached type forward information
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PdbSourceDocument.SourceFileInfo">
            <param name="FilePath">The path to the source file on disk</param>
            <param name="SourceDescription">Localized description of where the file came from, for the document tab, eg. Source Link, Embedded, On Disk</param>
            <param name="Loader">The text loader to use</param>
            <param name="ChecksumAlgorithm">Algorithm to use for content checksum.</param>
            <param name="FromRemoteLocation">Whether the source files came from a remote location, and therefore their existence should be used to indicate that future requests can wait longer</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PdbSourceDocument.SourceFileInfo.#ctor(System.String,System.String,Microsoft.CodeAnalysis.TextLoader,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm,System.Boolean)">
            <param name="FilePath">The path to the source file on disk</param>
            <param name="SourceDescription">Localized description of where the file came from, for the document tab, eg. Source Link, Embedded, On Disk</param>
            <param name="Loader">The text loader to use</param>
            <param name="ChecksumAlgorithm">Algorithm to use for content checksum.</param>
            <param name="FromRemoteLocation">Whether the source files came from a remote location, and therefore their existence should be used to indicate that future requests can wait longer</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PdbSourceDocument.SourceFileInfo.FilePath">
            <summary>The path to the source file on disk</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PdbSourceDocument.SourceFileInfo.SourceDescription">
            <summary>Localized description of where the file came from, for the document tab, eg. Source Link, Embedded, On Disk</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PdbSourceDocument.SourceFileInfo.Loader">
            <summary>The text loader to use</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PdbSourceDocument.SourceFileInfo.ChecksumAlgorithm">
            <summary>Algorithm to use for content checksum.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PdbSourceDocument.SourceFileInfo.FromRemoteLocation">
            <summary>Whether the source files came from a remote location, and therefore their existence should be used to indicate that future requests can wait longer</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PdbSourceDocument.IPdbSourceDocumentLogger">
            <summary>
            Logs messages when navigating to external sources (eg. SourceLink, embedded) so that users can
            troubleshoot issues that might prevent it working (authentication, checksum errors, etc.)
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PdbSourceDocument.PdbFilePathResult">
            <summary>
            The result of findding a PDB file
            </summary>
            <param name="PdbFilePath">The path to the PDB file in the debugger cache</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PdbSourceDocument.PdbFilePathResult.#ctor(System.String)">
            <summary>
            The result of findding a PDB file
            </summary>
            <param name="PdbFilePath">The path to the PDB file in the debugger cache</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PdbSourceDocument.PdbFilePathResult.PdbFilePath">
            <summary>The path to the PDB file in the debugger cache</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PdbSourceDocument.SourceFilePathResult">
            <summary>
            The result of finding a source file via SourceLink
            </summary>
            <param name="SourceFilePath">The path to the source file in the debugger cache</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PdbSourceDocument.SourceFilePathResult.#ctor(System.String)">
            <summary>
            The result of finding a source file via SourceLink
            </summary>
            <param name="SourceFilePath">The path to the source file in the debugger cache</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PdbSourceDocument.SourceFilePathResult.SourceFilePath">
            <summary>The path to the source file in the debugger cache</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PdbSourceDocument.PdbSourceDocumentLoaderService._sourceLinkService">
            <summary>
            Lazy import ISourceLinkService because it can cause debugger 
            binaries to be eagerly loaded even if they are never used.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PdbSourceDocument.PdbSourceDocumentMetadataAsSourceFileProvider._gate">
            <summary>
            Lock to guard access to workspace updates when opening / closing documents.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PdbSourceDocument.PdbSourceDocumentMetadataAsSourceFileProvider._assemblyToProjectMap">
            <summary>
            Accessed only in <see cref="M:Microsoft.CodeAnalysis.PdbSourceDocument.PdbSourceDocumentMetadataAsSourceFileProvider.GetGeneratedFileAsync(Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceWorkspace,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.ISymbol,System.Boolean,Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceOptions,System.String,Microsoft.CodeAnalysis.MetadataAsSource.TelemetryMessage,System.Threading.CancellationToken)"/> and <see cref="M:Microsoft.CodeAnalysis.PdbSourceDocument.PdbSourceDocumentMetadataAsSourceFileProvider.CleanupGeneratedFiles(Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceWorkspace)"/>, both of which
            are called under a lock in <see cref="T:Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceFileService"/>.  So this is safe as a plain
            dictionary.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PdbSourceDocument.PdbSourceDocumentMetadataAsSourceFileProvider._sourceLinkEnabledProjects">
            <summary>
            Accessed only in <see cref="M:Microsoft.CodeAnalysis.PdbSourceDocument.PdbSourceDocumentMetadataAsSourceFileProvider.GetGeneratedFileAsync(Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceWorkspace,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.ISymbol,System.Boolean,Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceOptions,System.String,Microsoft.CodeAnalysis.MetadataAsSource.TelemetryMessage,System.Threading.CancellationToken)"/> and <see cref="M:Microsoft.CodeAnalysis.PdbSourceDocument.PdbSourceDocumentMetadataAsSourceFileProvider.CleanupGeneratedFiles(Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceWorkspace)"/>, both of which
            are called under a lock in <see cref="T:Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceFileService"/>.  So this is safe as a plain
            set.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PdbSourceDocument.PdbSourceDocumentMetadataAsSourceFileProvider._fileToDocumentInfoMap">
            <summary>
            Accessed both in <see cref="M:Microsoft.CodeAnalysis.PdbSourceDocument.PdbSourceDocumentMetadataAsSourceFileProvider.GetGeneratedFileAsync(Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceWorkspace,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.ISymbol,System.Boolean,Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceOptions,System.String,Microsoft.CodeAnalysis.MetadataAsSource.TelemetryMessage,System.Threading.CancellationToken)"/> and in UI thread operations.  Those should not
            generally run concurrently.  However, to be safe, we make this a concurrent dictionary to be safe to that
            potentially happening.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PdbSourceDocument.PdbSourceDocumentMetadataAsSourceFileProvider._openedDocumentIds">
            <summary>
            Only accessed and mutated in serial calls either from the UI thread or LSP queue.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PickMembers.PickMembersResult.SelectedAll">
            <summary>
            <see langword="true"/> if 'Select All' was chosen.  <see langword="false"/> if 'Deselect All' was chosen.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ProjectManagement.IProjectManagementService">
            <summary>
            This service provides a way to extract all the folders under a given project, or find the default namespace if it exists.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PullMemberUp.MemberAnalysisResult.Member">
            <summary>
            The member needs to be pulled up.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PullMemberUp.MemberAnalysisResult.ChangeOriginalToPublic">
            <summary>
            Indicate whether this member needs to be changed to public so it won't cause error after it is pulled up to destination.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PullMemberUp.MemberAnalysisResult.ChangeOriginalToNonStatic">
            <summary>
            Indicate whether this member needs to be changed to non-static so it won't cause error after it is pulled up to destination.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PullMemberUp.MemberAnalysisResult.MakeMemberDeclarationAbstract">
            <summary>
            Indicate whether this member's declaration in destination needs to be made to abstract. It is only used by the dialog UI.
            If this property is true, then pull a member up to a class will only generate a abstract declaration in the destination.
            It will always be false if the refactoring is triggered from Quick Action.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PullMemberUp.MemberAnalysisResult.ChangeDestinationTypeToAbstract">
            <summary>
            Indicate whether pulling this member up would change the destination to abstract. It will be true if:
            1. Pull an abstract member to a non-abstract class
            2. The 'Make abstract' check box of a member is checked, and the destination is a non-abstract class
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PullMemberUp.MemberAnalysisResult.PullMemberUpNeedsToDoExtraChanges">
            <summary>
            Indicate whether it would cause error if we directly pull Member into destination.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PullMemberUp.PullMembersUpOptions">
            <summary>
            This class contains all the operations needs to be done on members and destination to complete the pull up operation.
            If user clicked the cancel button, it will be null.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PullMemberUp.PullMembersUpOptions.Destination">
            <summary>
            Destination of where members should be pulled up to.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PullMemberUp.PullMembersUpOptions.MemberAnalysisResults">
            <summary>
            All the members involved in this pull up operation,
            and the other changes (in adddition to pull up) needed so that this pull up operation won't cause error.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PullMemberUp.PullMembersUpOptions.PullUpOperationNeedsToDoExtraChanges">
            <summary>
            Indicate whether it would cause error if we directly pull all members in MemberAnalysisResults up to destination.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.QuickInfo.AbstractEmbeddedLanguageQuickInfoProvider.EmbeddedLanguageProviderFeatureService">
            <summary>
            A derivation of <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.AbstractEmbeddedLanguageFeatureService`1"/> so we can fetch providers. Normally, our providers implement an interface,
            and the combined provider directly inherits from <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.AbstractEmbeddedLanguageFeatureService`1"/>. Unfortunately Quick Info is a bit different:
            there is a class (not an interface) and a private base class that also defines some logic that we need to reuse. Since we don't
            have multiple inheritance, we'll create a separate class here and delegate to the protected methods. We can remove this if we
            switch Quick Info over to a pattern like the rest of our features.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.QuickInfo.CommonSemanticQuickInfoProvider.TokenInformation.ShowAwaitReturn">
            <summary>
            True if this quick info came from hovering over an 'await' keyword, which we show the return
            type of with special text.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.QuickInfo.CommonSemanticQuickInfoProvider.TokenInformation.NullabilityInfo">
            <summary>
            The nullability info to show in Quick Info; will have <see cref="F:Microsoft.CodeAnalysis.NullableFlowState.None"/> to show nothing.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.QuickInfo.ExportQuickInfoProviderAttribute">
            <summary>
            Use this attribute to export a <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoProvider"/> so that it will
            be found and used by the per language associated <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoService"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.QuickInfo.ExportQuickInfoProviderAttribute.#ctor(System.String,System.String)">
            <summary>
            Use this attribute to export a <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoProvider"/> so that it will
            be found and used by the per language associated <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoService"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.QuickInfo.IEmbeddedLanguageQuickInfoProvider.GetQuickInfo(Microsoft.CodeAnalysis.QuickInfo.QuickInfoContext,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoItem"/> for the position in an embedded language.
            </summary>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoItem"/> or null if no item is available.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.QuickInfo.IndentationHelper.GetSpansWithAlignedIndentation(Microsoft.CodeAnalysis.Text.SourceText,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},System.Int32)">
            <summary>
            Recomputes span segments so that all text lines appear to have the same reduction in indentation.
            This operation is typically used to align text for display when the initial span does not include all of the first line's indentation.
            This operation will potentially split spans that cover multiple lines into separate spans.
            </summary>
            <param name="text"></param>
            <param name="classifiedSpans">The initial set of spans to align.</param>
            <param name="tabSize">The number of spaces to </param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.QuickInfo.OnTheFlyDocsInfo">
            <summary>
            Represents the data needed to provide on-the-fly documentation from the symbol.
            </summary>
            <param name="symbolSignature">formatted string representation of a symbol/></param>
            <param name="declarationCode">the symbol's declaration code</param>
            <param name="language">the language of the symbol</param>
            <param name="hasComments">whether the symbol has comments</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.QuickInfo.OnTheFlyDocsInfo.#ctor(System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.QuickInfo.OnTheFlyDocsRelevantFileInfo},System.String,System.Boolean,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.QuickInfo.OnTheFlyDocsRelevantFileInfo},System.Boolean)">
            <summary>
            Represents the data needed to provide on-the-fly documentation from the symbol.
            </summary>
            <param name="symbolSignature">formatted string representation of a symbol/></param>
            <param name="declarationCode">the symbol's declaration code</param>
            <param name="language">the language of the symbol</param>
            <param name="hasComments">whether the symbol has comments</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.QuickInfo.Presentation.QuickInfoClassifiedTextStyle">
            <summary>
            The text style for a <see cref="T:Microsoft.CodeAnalysis.QuickInfo.Presentation.QuickInfoClassifiedTextRun"/>.
            </summary>
            
            <remarks>
            By default, text is displayed using tooltip preferences, but colorized using
            text editor colors in order to make tooltips that look visually like UI, but
            match the semantic colorization of the code.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.QuickInfo.Presentation.QuickInfoClassifiedTextStyle.Plain">
            <summary>
            Plain text.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.QuickInfo.Presentation.QuickInfoClassifiedTextStyle.Bold">
            <summary>
            Bolded text.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.QuickInfo.Presentation.QuickInfoClassifiedTextStyle.Italic">
            <summary>
            Italic text.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.QuickInfo.Presentation.QuickInfoClassifiedTextStyle.Underline">
            <summary>
            Underlined text.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.QuickInfo.Presentation.QuickInfoClassifiedTextStyle.UseClassificationFont">
            <summary>
            Use the font specified by the classification.
            </summary>
            
            <remarks>
            If applied, the classification's code font is used instead of the default tooltip font.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.QuickInfo.Presentation.QuickInfoClassifiedTextStyle.UseClassificationStyle">
            <summary>
            Use the style specified by the classification.
            </summary>
            
            <remarks>
            If applied, the classification's bold, italic, and underline settings are used
            instead of the default tooltip style. Note that additional styles can be layered
            on top of the classification's style by adding <see cref="F:Microsoft.CodeAnalysis.QuickInfo.Presentation.QuickInfoClassifiedTextStyle.Bold"/>, <see cref="F:Microsoft.CodeAnalysis.QuickInfo.Presentation.QuickInfoClassifiedTextStyle.Italic"/>,
            or <see cref="F:Microsoft.CodeAnalysis.QuickInfo.Presentation.QuickInfoClassifiedTextStyle.Underline"/>.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.QuickInfo.Presentation.QuickInfoContainerStyle">
            <summary>
            The layout style for a <see cref="T:Microsoft.CodeAnalysis.QuickInfo.Presentation.QuickInfoContainerElement"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.QuickInfo.Presentation.QuickInfoContainerStyle.Wrapped">
            <summary>
            Contents are end-to-end, and wrapped when the control becomes too wide.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.QuickInfo.Presentation.QuickInfoContainerStyle.Stacked">
            <summary>
            Contents are stacked vertically.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.QuickInfo.Presentation.QuickInfoContainerStyle.VerticalPadding">
            <summary>
            Additional padding above and below content.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.QuickInfo.Presentation.TaggedTextExtensions.TextElementBuilder.AsRef(Microsoft.CodeAnalysis.QuickInfo.Presentation.TaggedTextExtensions.TextElementBuilder@)">
            <summary>
            Gets a mutable reference to a <see cref="T:Microsoft.CodeAnalysis.QuickInfo.Presentation.TaggedTextExtensions.TextElementBuilder"/> stored in a <c>using</c> variable.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoContext">
            <summary>
            The context presented to a <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoProvider"/> when providing quick info.
            </summary>
            <remarks>
            Creates a <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoContext"/> instance.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.QuickInfo.QuickInfoContext.#ctor(Microsoft.CodeAnalysis.Document,System.Int32,Microsoft.CodeAnalysis.LanguageService.SymbolDescriptionOptions,System.Threading.CancellationToken)">
            <summary>
            The context presented to a <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoProvider"/> when providing quick info.
            </summary>
            <remarks>
            Creates a <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoContext"/> instance.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.QuickInfo.QuickInfoContext.Document">
            <summary>
            The document that quick info was requested within.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.QuickInfo.QuickInfoContext.Position">
            <summary>
            The caret position where quick info was requested from.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.QuickInfo.QuickInfoContext.CancellationToken">
            <summary>
            The cancellation token to use for this operation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.QuickInfo.QuickInfoItem.Span">
            <summary>
            The span of the document that the item is based on.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.QuickInfo.QuickInfoItem.Tags">
            <summary>
            Descriptive tags from the <see cref="T:Microsoft.CodeAnalysis.Tags.WellKnownTags"/> type.
            These tags may influence how the item is displayed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.QuickInfo.QuickInfoItem.Sections">
            <summary>
            One or more <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoSection"/> describing the item.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.QuickInfo.QuickInfoItem.RelatedSpans">
            <summary>
            Alternate regions of the document that help describe the item.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoProvider">
            <summary>
            A provider that produces <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoItem"/>'s. 
            Providers are used with some <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoService"/> implementations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.QuickInfo.QuickInfoProvider.GetQuickInfoAsync(Microsoft.CodeAnalysis.QuickInfo.QuickInfoContext)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoItem"/> for the position.
            </summary>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoItem"/> or null if no item is available.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoProviderNames">
            <summary>
            Some of the known <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoProvider"/> names in use.
            Names are used for ordering providers with the <see cref="T:Microsoft.CodeAnalysis.ExtensionOrderAttribute"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoSection">
            <summary>
            Sections are used to make up a <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoItem"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.QuickInfo.QuickInfoSection.Kind">
            <summary>
            The kind of this section. Use <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoSectionKinds"/> for the most common kinds.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.QuickInfo.QuickInfoSection.TaggedParts">
            <summary>
            The individual tagged parts of this section.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.QuickInfo.QuickInfoSection.Create(System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.TaggedText})">
            <summary>
            Creates a new instance of <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoSection"/>.
            </summary>
            <param name="kind">The kind of the section. Use <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoSectionKinds"/> for the most common kinds.</param>
            <param name="taggedParts">The individual tagged parts of the section.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.QuickInfo.QuickInfoSection.Text">
            <summary>
            The text of the section without tags.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoSectionKinds">
            <summary>
            The set of well known kinds used for the <see cref="P:Microsoft.CodeAnalysis.QuickInfo.QuickInfoSection.Kind"/> property.
            These tags influence the presentation of quick info section.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoService">
            <summary>
            A service that is used to determine the appropriate quick info for a position in a document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.QuickInfo.QuickInfoService.GetService(Microsoft.CodeAnalysis.Document)">
            <summary>
            Gets the appropriate <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoService"/> for the specified document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.QuickInfo.QuickInfoService.GetQuickInfoAsync(Microsoft.CodeAnalysis.Document,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoItem"/> associated with position in the document.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoServiceWithProviders">
            <summary>
            Base class for <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoService"/>'s that delegate to <see cref="T:Microsoft.CodeAnalysis.QuickInfo.QuickInfoProvider"/>'s.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.QuickInfo.QuickInfoUtilities.s_nullableDisplayFormat">
            <summary>
            Display variable name only.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RelatedDocuments.IRelatedDocumentsService.GetRelatedDocumentIdsAsync(Microsoft.CodeAnalysis.Document,System.Int32,System.Func{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DocumentId},System.Threading.CancellationToken,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken)">
            <summary>
            Given an document, and an optional position in that document, streams a unique list of documents Ids that the
            language think are "related".  It is up to the language to define what "related" means.  However, common
            examples might be checking to see which symbols are used at that particular location and prioritizing documents
            those symbols are defined in.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SemanticSearch.AbstractSemanticSearchService.s_queryKindByParameterType">
            <summary>
            Mapping from the parameter type of the <c>Find</c> method to the <see cref="T:Microsoft.CodeAnalysis.SemanticSearch.QueryKind"/> value.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SemanticSearch.ExecuteQueryResult">
            <summary>
            The result of Semantic Search query execution.
            </summary>
            <param name="ErrorMessage">An error message if the execution failed.</param>
            <param name="ErrorMessageArgs">
            Arguments to be substituted to <paramref name="ErrorMessage"/>.
            Use when the values may contain PII that needs to be obscured in telemetry.
            Otherwise, <paramref name="ErrorMessage"/> should contain the formatted message.
            </param>
            <param name="ExecutionTime">Time it took to execute the query.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticSearch.ExecuteQueryResult.#ctor(System.String,System.String[],System.TimeSpan)">
            <summary>
            The result of Semantic Search query execution.
            </summary>
            <param name="ErrorMessage">An error message if the execution failed.</param>
            <param name="ErrorMessageArgs">
            Arguments to be substituted to <paramref name="ErrorMessage"/>.
            Use when the values may contain PII that needs to be obscured in telemetry.
            Otherwise, <paramref name="ErrorMessage"/> should contain the formatted message.
            </param>
            <param name="ExecutionTime">Time it took to execute the query.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SemanticSearch.ExecuteQueryResult.ErrorMessage">
            <summary>An error message if the execution failed.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SemanticSearch.ExecuteQueryResult.ErrorMessageArgs">
            <summary>
            Arguments to be substituted to <paramref name="ErrorMessage"/>.
            Use when the values may contain PII that needs to be obscured in telemetry.
            Otherwise, <paramref name="ErrorMessage"/> should contain the formatted message.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SemanticSearch.ExecuteQueryResult.ExecutionTime">
            <summary>Time it took to execute the query.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SemanticSearch.CompileQueryResult">
            <summary>
            The result of Semantic Search query compilation.
            </summary>
            <param name="QueryId">Id of the compiled query if the compilation was successful.</param>
            <param name="CompilationErrors">Compilation errors.</param>
            <param name="EmitTime">Time it took to emit the query compilation.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticSearch.CompileQueryResult.#ctor(Microsoft.CodeAnalysis.SemanticSearch.CompiledQueryId,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SemanticSearch.QueryCompilationError},System.TimeSpan)">
            <summary>
            The result of Semantic Search query compilation.
            </summary>
            <param name="QueryId">Id of the compiled query if the compilation was successful.</param>
            <param name="CompilationErrors">Compilation errors.</param>
            <param name="EmitTime">Time it took to emit the query compilation.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SemanticSearch.CompileQueryResult.QueryId">
            <summary>Id of the compiled query if the compilation was successful.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SemanticSearch.CompileQueryResult.CompilationErrors">
            <summary>Compilation errors.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SemanticSearch.CompileQueryResult.EmitTime">
            <summary>Time it took to emit the query compilation.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticSearch.ISemanticSearchService.CompileQuery(Microsoft.CodeAnalysis.Host.SolutionServices,System.String,System.String,System.Diagnostics.TraceSource,System.Threading.CancellationToken)">
            <summary>
            Compiles a query. The query has to be executed or discarded.
            </summary>
            <param name="query">Query (top-level code).</param>
            <param name="referenceAssembliesDir">Directory that contains reference assemblies to be used for compilation of the query.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticSearch.ISemanticSearchService.ExecuteQueryAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.SemanticSearch.CompiledQueryId,Microsoft.CodeAnalysis.SemanticSearch.ISemanticSearchResultsObserver,System.Diagnostics.TraceSource,System.Threading.CancellationToken)">
            <summary>
            Executes given query against <paramref name="solution"/> and discards it.
            </summary>
            <param name="solution">The solution snapshot.</param>
            <param name="queryId">Id of a compiled query.</param>
            <param name="observer">Observer of the found symbols.</param>
            <param name="cancellationToken">Cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticSearch.ISemanticSearchService.DiscardQuery(Microsoft.CodeAnalysis.SemanticSearch.CompiledQueryId)">
            <summary>
            Discards resources associated with compiled query.
            Only call if the query is not executed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SemanticSearch.SemanticSearchCopilotContext">
            <summary>
            Context necessary to generate Copilot prompt for semantic search query.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SemanticSearch.SemanticSearchCopilotContext.AvailablePackages">
            <summary>
            List of package names and versions that to include in the prompt.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SemanticSearch.SemanticSearchCopilotGeneratedQuery.Text">
            <summary>
            The generated code or an error message.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SemanticSearch.SemanticSearchCopilotGeneratedQuery.IsError">
            <summary>
            True if <see cref="P:Microsoft.CodeAnalysis.SemanticSearch.SemanticSearchCopilotGeneratedQuery.Text"/> is an error message.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticSearch.SemanticModelGetter.GetSemanticModelAsync(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Returns <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/> for any <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> in the <see cref="T:Microsoft.CodeAnalysis.Solution"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions2.GetAppropriateDocumentationComment(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken)">
            <summary>
            Returns the <see cref="T:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment"/> for a symbol, even if it involves going to other symbols to find it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTokenListExtensions.GetValueText(Microsoft.CodeAnalysis.SyntaxTokenList)">
            <summary>
            Gets the concatenated value text for the token list.
            </summary>
            <returns>The concatenated value text, or an empty string if there are no tokens in the list.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.NamingExtensions.GetNamingRulesAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Gets the set of naming rules the user has set for this document.  Will include a set of default naming rules
            that match if the user hasn't specified any for a particular symbol type.  The are added at the end so they
            will only be used if the user hasn't specified a preference.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.AnnotatedSymbolMapping.SymbolToDeclarationAnnotationMap">
            <summary>
            Used to map a symbol to the annotation that was added at the beginning of it's definition. Use the 
            annotation the symbol declaration again across edits.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.AnnotatedSymbolMapping.AnnotatedSolution">
            <summary>
            The original solution that modifications made to annotate the symbol declarations
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.AnnotatedSymbolMapping.DocumentIdsToSymbolMap">
            <summary>
            A map of the document ids that were used and what symbols are in them. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.AnnotatedSymbolMapping.TypeNodeAnnotation">
            <summary>
            The annotation added to the type declaration that was passed in to create the mapping
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.AnnotatedSymbolMapping.CreateAsync(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ISymbol},Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.Shared.Utilities.AnnotatedSymbolMapping"/> where the first token of each symbol is annotated
            and added to a map to keep track. This allows modification of the trees and later lookup of symbols
            based on the original annotations added. Assumes each symbol only has one location.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.IUIContextActivationService.ExecuteWhenActivated(System.Guid,System.Action)">
            <summary>
            Executes the specified action when the UIContext first becomes active, or immediately if it is already active
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.LinkedFilesSymbolEquivalenceComparer">
            <summary>
            For completion and quickinfo in linked files, we compare symbols from different documents
            to determine if they are similar enough for us to suppress the platform dependence
            warning icon. We consider symbols equivalent if they have the same name.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.HashCodeAnalyzer">
            <summary>
            Helper code to support analysis of HashCode methods
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.HashCodeAnalyzer.#ctor(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Helper code to support analysis of HashCode methods
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.HashCodeAnalyzer.GetHashedMembers(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Analyzes the containing <c>GetHashCode</c> method to determine which fields and
            properties were combined to form a hash code for this type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.HashCodeAnalyzer.IsLiteralNumber(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Matches positive and negative numeric literals.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.HashCodeAnalyzer.OperationDeconstructor">
            <summary>
            Breaks down complex <see cref="T:Microsoft.CodeAnalysis.IOperation"/> trees, looking for particular
            <see cref="M:System.Object.GetHashCode"/> patterns and extracting out the field and property
            symbols use to compute the hash.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.HashCodeAnalyzer.OperationDeconstructor.#ctor(Microsoft.CodeAnalysis.Shared.Utilities.HashCodeAnalyzer,Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.ILocalSymbol)">
            <summary>
            Breaks down complex <see cref="T:Microsoft.CodeAnalysis.IOperation"/> trees, looking for particular
            <see cref="M:System.Object.GetHashCode"/> patterns and extracting out the field and property
            symbols use to compute the hash.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.HashCodeAnalyzer.OperationDeconstructor.TryAddHashedSymbol(Microsoft.CodeAnalysis.IOperation,System.Boolean)">
            <summary>
            Recursive function that decomposes <paramref name="value"/>, looking for particular
            forms that VS or ReSharper generate to hash fields in the containing type.
            </summary>
            <param name="seenHash">'seenHash' is used to determine if we actually saw something
            that indicates that we really hashed a field/property and weren't just simply
            referencing it.  This is used as we recurse down to make sure we've seen a
            pattern we explicitly recognize by the time we hit a field/prop.</param>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Naming.FallbackNamingRules.Default">
            <summary>
            Standard symbol names if the user doesn't have any existing naming rules.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Naming.FallbackNamingRules.CompletionFallbackRules">
            <summary>
            Standard name rules for name suggestion/completion utilities. These are fallback rules that run if a user
            hasn't provided any other naming rule matching the scenario.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Naming.FallbackNamingRules.CompletionSupplementaryRules">
            <summary>
            Standard name rules for name suggestion/completion utilities. These are supplementary rules that run in
            addition to any other rules defined by the user in order to provide additional valid suggestions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.ISignatureHelpProvider.TriggerCharacters">
            <summary>
            The set of characters that might trigger a Signature Help session,
            e.g. '(' and ',' for method invocations 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.ISignatureHelpProvider.RetriggerCharacters">
            <summary>
            The set of characters that might end a Signature Help session,
            e.g. ')' for method invocations.  
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SignatureHelp.ISignatureHelpProvider.GetItemsAsync(Microsoft.CodeAnalysis.Document,System.Int32,Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpTriggerInfo,Microsoft.CodeAnalysis.MemberDisplayOptions,System.Threading.CancellationToken)">
            <summary>
            Returns valid signature help items at the specified position in the document.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpItem.IsVariadic">
            <summary>
            True if this signature help item can have an unbounded number of arguments passed to it.
            If it is variadic then the last parameter will be considered selected, even if the
            selected parameter index strictly goes past the number of defined parameters for this
            item.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpItems.Items">
            <summary>
            The list of items to present to the user.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpItems.ApplicableSpan">
            <summary>
            The span this session applies to.
            
            Navigation outside this span will cause signature help to be dismissed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpItems.SemanticParameterIndex">
            <summary>
            Returns the specified <em>parameter</em> index that the provided position is at in the current document.  This 
            index may be greater than the number of actual syntactic arguments in the selected <see cref="T:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpItem"/>.
            </summary>
            <remarks>
            This relates to the original semantic symbol that was used to create a particular item.  In other words,
            it may be using
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpItems.SyntacticArgumentCount">
            <summary>
            Returns the total number of arguments that have been typed in the current document.  This may be 
            greater than the ArgumentIndex if there are additional arguments after the provided position.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpItems.ArgumentName">
            <summary>
            Returns the name of specified argument at the current position in the document.  
            This only applies to languages that allow the user to provide named arguments.
            If no named argument exists at the current position, then null should be returned. 
            
            This value is used to determine which documentation comment should be provided for the current
            parameter.  Normally this is determined simply by determining the parameter by index.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpItems.SelectedItemIndex">
            <summary>
            The item to select by default.  If this is <see langword="null"/> then the controller will
            pick the first item that has enough arguments to be viable based on what argument 
            position the user is currently inside of.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpSymbolParameter">
            <summary>
            Used for C#/VB sig help providers so they can build up information using SymbolDisplayParts.
            These parts will then by used to properly replace anonymous type information in the parts.
            Once that it done, this will be converted to normal SignatureHelpParameters which only 
            point to TaggedText parts.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpSymbolParameter.#ctor(System.String,System.Boolean,System.Func{System.Threading.CancellationToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.TaggedText}},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SymbolDisplayPart},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SymbolDisplayPart},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SymbolDisplayPart},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SymbolDisplayPart})">
            <summary>
            Used for C#/VB sig help providers so they can build up information using SymbolDisplayParts.
            These parts will then by used to properly replace anonymous type information in the parts.
            Once that it done, this will be converted to normal SignatureHelpParameters which only 
            point to TaggedText parts.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpSymbolParameter.Name">
            <summary>
            The name of this parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpSymbolParameter.DocumentationFactory">
            <summary>
            Documentation for this parameter.  This should normally be presented to the user when
            this parameter is selected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpSymbolParameter.PrefixDisplayParts">
            <summary>
            Display parts to show before the normal display parts for the parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpSymbolParameter.SuffixDisplayParts">
            <summary>
            Display parts to show after the normal display parts for the parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpSymbolParameter.DisplayParts">
            <summary>
            Display parts for this parameter.  This should normally be presented to the user as part
            of the entire signature display.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpSymbolParameter.IsOptional">
            <summary>
            True if this parameter is optional or not.  Optional parameters may be presented in a
            different manner to users.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpSymbolParameter.SelectedDisplayParts">
            <summary>
            Display parts for this parameter that should be presented to the user when this
            parameter is selected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpParameter.Name">
            <summary>
            The name of this parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpParameter.DocumentationFactory">
            <summary>
            Documentation for this parameter.  This should normally be presented to the user when
            this parameter is selected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpParameter.PrefixDisplayParts">
            <summary>
            Display parts to show before the normal display parts for the parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpParameter.SuffixDisplayParts">
            <summary>
            Display parts to show after the normal display parts for the parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpParameter.DisplayParts">
            <summary>
            Display parts for this parameter.  This should normally be presented to the user as part
            of the entire signature display.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpParameter.IsOptional">
            <summary>
            True if this parameter is optional or not.  Optional parameters may be presented in a
            different manner to users.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpParameter.SelectedDisplayParts">
            <summary>
            Display parts for this parameter that should be presented to the user when this
            parameter is selected.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpService">
            <summary>
            A service that is used to determine the appropriate signature help for a position in a document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpService.#ctor(System.Collections.Generic.IEnumerable{System.Lazy{Microsoft.CodeAnalysis.SignatureHelp.ISignatureHelpProvider,Microsoft.CodeAnalysis.Host.Mef.OrderableLanguageMetadata}})">
            <summary>
            A service that is used to determine the appropriate signature help for a position in a document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpService.GetSignatureHelpAsync(Microsoft.CodeAnalysis.Document,System.Int32,Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpTriggerInfo,System.Threading.CancellationToken)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.SignatureHelp.ISignatureHelpProvider"/> and <see cref="T:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpItems"/> associated with
            the position in the document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpService.GetSignatureHelpAsync(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SignatureHelp.ISignatureHelpProvider},Microsoft.CodeAnalysis.Document,System.Int32,Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpTriggerInfo,System.Threading.CancellationToken)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.SignatureHelp.ISignatureHelpProvider"/> and <see cref="T:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpItems"/> associated with
            the position in the document.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpTriggerReason.InvokeSignatureHelpCommand">
            <summary>
            Signature Help was triggered through the 'Invoke Signature Help' command
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpTriggerReason.TypeCharCommand">
            <summary>
            Signature Help was triggered through the 'Type Char' command.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpTriggerReason.RetriggerCommand">
            <summary>
            Signature Help was triggered through typing a closing brace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SimplifyTypeNames.SimplifyTypeNamesDiagnosticAnalyzerBase`2.IsIgnoredCodeBlock(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Determine if a code block is eligible for analysis by <see cref="M:Microsoft.CodeAnalysis.SimplifyTypeNames.SimplifyTypeNamesDiagnosticAnalyzerBase`2.AnalyzeCodeBlock(Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext,Microsoft.CodeAnalysis.SyntaxNode)"/>.
            </summary>
            <param name="codeBlock">The syntax node provided via <see cref="P:Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext.CodeBlock"/>.</param>
            <returns><see langword="true"/> if the code block should be analyzed by <see cref="M:Microsoft.CodeAnalysis.SimplifyTypeNames.SimplifyTypeNamesDiagnosticAnalyzerBase`2.AnalyzeCodeBlock(Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext,Microsoft.CodeAnalysis.SyntaxNode)"/>;
            otherwise, <see langword="false"/> to skip analysis of the block. If a block is skipped, one or more child
            blocks may be analyzed by <see cref="M:Microsoft.CodeAnalysis.SimplifyTypeNames.SimplifyTypeNamesDiagnosticAnalyzerBase`2.AnalyzeCodeBlock(Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext,Microsoft.CodeAnalysis.SyntaxNode)"/>, and any remaining spans can be analyzed by
            <see cref="M:Microsoft.CodeAnalysis.SimplifyTypeNames.SimplifyTypeNamesDiagnosticAnalyzerBase`2.AnalyzeSemanticModel(Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Shared.Collections.TextSpanMutableIntervalTree)"/>.</returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SimplifyTypeNames.SimplifyTypeNamesDiagnosticAnalyzerBase`2.AnalyzerImpl._codeBlockIntervals">
             <summary>
             Tracks the analysis state of syntax trees in a compilation. Each syntax tree has the properties:
             <list type="bullet">
             <item><description>
             <para><c>completed</c>: <see langword="true"/> to indicate that <c>intervalTree</c> has been obtained
             for use in a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext"/> callback; otherwise, <see langword="false"/> to
             indicate that <c>intervalTree</c> may be updated by adding a new non-overlapping <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/>
             for analysis performed by a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext"/> callback.</para>
            
             <para>This field also serves as the lock object for updating both <c>completed</c> and
             <c>intervalTree</c>.</para>
             </description></item>
             <item><description>
             <para><c>intervalTree</c>: the set of intervals analyzed by <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext"/>
             callbacks, and therefore do not need to be analyzed again by a
             <see cref="T:Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext"/> callback.</para>
            
             <para>This field may only be accessed while <c>completed</c> is locked, and is not valid after
             <c>completed</c> is <see langword="true"/>.</para>
             </description></item>
             </list>
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Snippets.AbstractSnippetService.GetSnippetProvider(System.String)">
            <summary>
            This should never be called prior to GetSnippetsAsync because it gets populated
            at that point in time.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Snippets.AbstractSnippetService.GetSnippets(Microsoft.CodeAnalysis.Snippets.SnippetContext,System.Threading.CancellationToken)">
            <summary>
            Iterates through all providers and determines if the snippet 
            can be added to the Completion list at the corresponding position.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Snippets.CommonSnippetIdentifiers">
            <summary>
            Contains language-neutral snippet identifiers,
            which can theoretically be used in a snippet provider regardless its target language
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Snippets.InlineExpressionInfo">
            <summary>
            Information about inline expression for inline statement snippets
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Snippets.InlineExpressionInfo.#ctor(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.TypeInfo)">
            <summary>
            Information about inline expression for inline statement snippets
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Snippets.InlineExpressionInfo.Node">
            <summary>
            Right-hand side of an accessing expression.
            Must be an expression node.
            Do NOT use it to obtain semantic info.
            If you need type information about this node use <see cref="P:Microsoft.CodeAnalysis.Snippets.InlineExpressionInfo.TypeInfo" /> property
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Snippets.InlineExpressionInfo.TypeInfo">
            <summary>
            Type information of an accessing expression
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Snippets.ISnippetService.GetSnippets(Microsoft.CodeAnalysis.Snippets.SnippetContext,System.Threading.CancellationToken)">
            <summary>
            Retrieves all possible types of snippets for a particular position
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Snippets.ISnippetService.GetSnippetProvider(System.String)">
            <summary>
            Gets the corresponding provider from a snippet identifier.
            Called upon by the AbstractSnippetCompletionProvider
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Snippets.RoslynLSPSnippetConverter.GenerateLSPSnippetAsync(Microsoft.CodeAnalysis.Document,System.Int32,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Snippets.SnippetPlaceholder},Microsoft.CodeAnalysis.Text.TextChange,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Extends the TextChange to encompass all placeholder positions as well as caret position.
            Generates a LSP formatted snippet from a TextChange, list of placeholders, and caret position.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Snippets.RoslynLSPSnippetConverter.ConvertToLSPSnippetString(Microsoft.CodeAnalysis.Text.TextChange,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Snippets.SnippetPlaceholder},System.Int32)">
            <summary>
            Iterates through every index in the snippet string and determines where the
            LSP formatted chunks should be inserted for each placeholder.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Snippets.RoslynLSPSnippetConverter.PopulateMapOfSpanStartsToLSPStringItem(System.Collections.Generic.Dictionary{System.Int32,System.ValueTuple{System.String,System.Int32}},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Snippets.SnippetPlaceholder},System.Int32)">
            <summary>
            Preprocesses the list of placeholders into a dictionary that maps the insertion position
            in the string to the placeholder's identifier and the priority associated with it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Snippets.RoslynLSPSnippetConverter.ExtendSnippetTextChangeAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextChange,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Snippets.SnippetPlaceholder},System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            We need to extend the snippet's TextChange if any of the placeholders or
            if the caret position comes before or after the span of the TextChange.
            If so, then find the new string that encompasses all of the placeholders
            and caret position.
            This is important for the cases in which the document does not determine the TextChanges from
            the original document accurately.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Snippets.RoslynLSPSnippetConverter.GetUpdatedTextSpan(Microsoft.CodeAnalysis.Text.TextChange,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Snippets.SnippetPlaceholder},System.Int32,System.Int32)">
            <summary>
            Iterates through the placeholders and determines if any of the positions
            come before or after what is indicated by the snippet's TextChange.
            If so, adjust the starting and ending position accordingly.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Snippets.SnippetChange">
            <summary>
            Encapsulates the information that makes up a Snippet.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Snippets.SnippetChange.TextChanges">
            <summary>
            The TextChange's associated with introducing a snippet into a document
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Snippets.SnippetChange.Placeholders">
            <summary>
            The items that we will want to rename as well as the ordering
            in which to visit those items.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Snippets.SnippetChange.FinalCaretPosition">
            <summary>
            The position that the caret should end up on
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Snippets.SnippetContext">
            <summary>
            The context presented to a <see cref="T:Microsoft.CodeAnalysis.Snippets.SnippetProviders.ISnippetProvider"/> when providing completions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Snippets.SnippetContext.Document">
            <summary>
            The document that the snippet was invoked within.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Snippets.SnippetContext.Position">
            <summary>
            The caret position when the snippet was triggered.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Snippets.SnippetContext.SemanticModel">
            <summary>
            The semantic model of the document.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Snippets.SnippetData">
            <summary>
            Stores only the data needed for the creation of a CompletionItem.
            Avoids using the Snippet and creating a TextChange/finding cursor
            position before we know it was the selected CompletionItem.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Snippets.SnippetData.#ctor(System.String,System.String,System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
            Stores only the data needed for the creation of a CompletionItem.
            Avoids using the Snippet and creating a TextChange/finding cursor
            position before we know it was the selected CompletionItem.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Snippets.SnippetPlaceholder.Text">
            <summary>
            Editable text in the snippet.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Snippets.SnippetPlaceholder.StartingPositions">
            <summary>
            The positions associated with the identifier that will need to
            be converted into LSP formatted strings.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Snippets.SnippetPlaceholder.#ctor(System.String,System.Collections.Immutable.ImmutableArray{System.Int32})">
            <summary>
            <example> 
            For loop would have two placeholders:
            <code>
                for (var {1:i} = 0; {1:i} &lt; {2:length}; {1:i}++)
            </code>
            Text: <c>i</c>, 3 associated positions <br/>
            Text: <c>length</c>, 1 associated position <br/>
            </example>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Snippets.SnippetPlaceholder.#ctor(System.String,System.Int32)">
            <summary>
            Initialize a placeholder with a single position
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Snippets.SnippetProviders.AbstractConditionalBlockSnippetProvider`2">
            <summary>
            Base class for "if" and "while" snippet providers
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Snippets.SnippetProviders.AbstractInlineStatementSnippetProvider`1">
            <summary>
            Base class for snippets, that can be both executed as normal statement snippets
            or constructed from a member access expression when accessing members of a specific type
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Snippets.SnippetProviders.AbstractInlineStatementSnippetProvider`1.IsValidAccessingType(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Tells if accessing type of a member access expression is valid for that snippet
            </summary>
            <param name="type">Type of right-hand side of an accessing expression</param>
            <param name="compilation">Current compilation instance</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Snippets.SnippetProviders.AbstractInlineStatementSnippetProvider`1.GenerateStatement(Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.SyntaxContext,Microsoft.CodeAnalysis.Snippets.InlineExpressionInfo)">
            <summary>
            Generate statement node
            </summary>
            <param name="inlineExpressionInfo">Information about inline expression or <see langword="null"/> if snippet is executed in normal statement context</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Snippets.SnippetProviders.AbstractInlineStatementSnippetProvider`1.ConstructedFromInlineExpression">
            <summary>
            Tells whether the original snippet was constructed from member access expression.
            Can be used by snippet providers to not mark that expression as a placeholder
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Snippets.SnippetProviders.AbstractPropertySnippetProvider`1.GenerateSnippetSyntaxAsync(Microsoft.CodeAnalysis.Document,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Generates the property syntax.
            Requires language specificity for the TypeSyntax as well as the
            type of the PropertySyntax.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Snippets.SnippetProviders.ISnippetProvider.Identifier">
            <summary>
            What we use to identify each SnippetProvider on the completion list
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Snippets.SnippetProviders.ISnippetProvider.Description">
            <summary>
            What is being displayed for the inline-description of the snippet as well as the title on the tool-tip.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Snippets.SnippetProviders.ISnippetProvider.AdditionalFilterTexts">
            <summary>
            Additional filter texts for snippet completion item
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Snippets.SnippetProviders.ISnippetProvider.IsValidSnippetLocation(Microsoft.CodeAnalysis.Snippets.SnippetContext,System.Threading.CancellationToken)">
            <summary>
            Determines if a snippet can exist at a particular location.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Snippets.SnippetProviders.ISnippetProvider.GetSnippetChangeAsync(Microsoft.CodeAnalysis.Document,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Gets the Snippet change from the corresponding snippet provider.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Snippets.AbstractConsoleSnippetProvider`4.GetTargetCaretPosition(`1,Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Tries to get the location after the open parentheses in the argument list.
            If it can't, then we default to the end of the snippet's span.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Snippets.AbstractSnippetProvider`1.IsValidSnippetLocationCore(Microsoft.CodeAnalysis.Snippets.SnippetContext,System.Threading.CancellationToken)">
            <summary>
            Implemented by each SnippetProvider to determine if that particular position is a valid
            location for the snippet to be inserted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Snippets.AbstractSnippetProvider`1.GenerateSnippetTextChangesAsync(Microsoft.CodeAnalysis.Document,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Generates the new snippet's TextChanges that are being inserted into the document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Snippets.AbstractSnippetProvider`1.GetTargetCaretPosition(`0,Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Gets the position that we want the caret to be at after all of the indentation/formatting has been done.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Snippets.AbstractSnippetProvider`1.GetPlaceHolderLocationsList(`0,Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts,System.Threading.CancellationToken)">
            <summary>
            Method to find the locations that must be renamed and where tab stops must be inserted into the snippet.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Snippets.AbstractSnippetProvider`1.GetSnippetChangeAsync(Microsoft.CodeAnalysis.Document,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Handles all the work to generate the Snippet.
            Reformats the document with the snippet TextChange and annotates 
            appropriately for the cursor to get the target cursor position.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Snippets.AbstractSnippetProvider`1.GenerateElasticTriviaForSyntax(Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Descends into the inserted snippet to add back trivia on every token.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Snippets.AbstractSnippetProvider`1.GetDocumentWithSnippetAndTriviaAsync(Microsoft.CodeAnalysis.Document,System.Int32,Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts,System.Threading.CancellationToken)">
            <summary>
            Locates the snippet that was inserted. Generates trivia for every token in that SyntaxNode.
            Replaces the SyntaxNodes and gets back the new document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Snippets.AbstractSnippetProvider`1.AnnotateNodesToReformatAsync(Microsoft.CodeAnalysis.Document,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Method to added formatting annotations to the created snippet.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Snippets.AbstractSnippetProvider`1.AddIndentationToDocumentAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Certain snippets require more indentation - snippets with blocks.
            The SyntaxGenerator does not insert this space for us nor does the LSP Snippet Expander.
            We need to manually add that spacing to snippets containing blocks.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SnippetFunctionService.SwitchCaseFormat">
            <summary>
            Language specific format for switch cases.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SnippetFunctionService.SwitchDefaultCaseForm">
            <summary>
            Language specific format for default switch case.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SnippetFunctionService.GetContainingClassNameAsync(Microsoft.CodeAnalysis.Document,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Gets the name of the class that contains the specified position.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SnippetFunctionService.GetSimplifiedTypeNameAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.String,Microsoft.CodeAnalysis.Simplification.SimplifierOptions,System.Threading.CancellationToken)">
            <summary>
            For a specified snippet field, replace it with the fully qualified name then simplify in the context of the document
            in order to retrieve the simplified type name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SnippetFunctionService.GetSwitchExpansionAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Simplification.SimplifierOptions,System.Threading.CancellationToken)">
            <summary>
            For a document with the default switch snippet inserted, generate the expanded set of cases based on the value
            of the field currently inserted into the switch statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SnippetFunctionService.TryGetSnippetFunctionInfo(System.String,System.String@,System.String@)">
            <summary>
            Parse the XML snippet function attribute to determine the function name and parameter.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SpellCheck.ISpellCheckSpanService">
            <summary>
            Service for individual languages to provide the regions of their code that should be spell checked.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SplitOrMergeIfStatements.IIfLikeStatementGenerator">
            <summary>
            When querying the syntax, C# else if chains are "flattened" and modeled to look like VB else-if clauses,
            so an "ifOrElseIf" can be followed a sequence of else-if clauses and an optional final else clause.
            These else-if clauses are treated as independent when removing or inserting.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SplitOrMergeIfStatements.IIfLikeStatementGenerator.GetRootIfStatement(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns the topmost if statement for an else-if clause.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SplitOrMergeIfStatements.IIfLikeStatementGenerator.GetElseIfAndElseClauses(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns the list of subsequent else-if clauses and a final else clause (if present).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SplitOrMergeIfStatements.IIfLikeStatementGenerator.ToIfStatement(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Converts an else-if clause to an if statement, preserving its subsequent else-if and else clauses.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SplitOrMergeIfStatements.IIfLikeStatementGenerator.ToElseIfClause(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Convert an if statement to an else-if clause, discarding any of its else-if and else clauses.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SplitOrMergeIfStatements.IIfLikeStatementGenerator.InsertElseIfClause(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Inserts <paramref name="elseIfClause"/> as a new else-if clause directly below
            <paramref name="afterIfOrElseIf"/>, between it and any of its existing else-if clauses.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SplitOrMergeIfStatements.IIfLikeStatementGenerator.RemoveElseIfClause(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Removes <paramref name="elseIfClause"/> from a sequence of else-if clauses, preserving any subsequent clauses.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.StackTraceExplorer.DotnetStackFrameParser.TryParseLine(Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence,Microsoft.CodeAnalysis.StackTraceExplorer.ParsedFrame@)">
            <summary>
            Uses <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameParser"/> to parse a line if possible
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.StackTraceExplorer.IStackTraceExplorerService.GetDocumentAndLine(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.StackTraceExplorer.ParsedFrame)">
            <summary>
            If the <paramref name="frame"/> has file information, attempts to map it to existing documents
            in a solution. Looks for an exact filepath match first, then defaults to 
            a best guess.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.StackTraceExplorer.ParsedStackFrame">
            <summary>
            A line from <see cref="M:Microsoft.CodeAnalysis.StackTraceExplorer.StackTraceAnalyzer.Parse(System.String,System.Threading.CancellationToken)"/> that
            was parsed by <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameParser"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.StackTraceExplorer.ParsedStackFrame.#ctor(Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameTree)">
            <summary>
            A line from <see cref="M:Microsoft.CodeAnalysis.StackTraceExplorer.StackTraceAnalyzer.Parse(System.String,System.Threading.CancellationToken)"/> that
            was parsed by <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameParser"/>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.StackTraceExplorer.StackFrameSymbolPart">
            <summary>
            Determines what type of symbol to look for
            when mapping a <see cref="T:Microsoft.CodeAnalysis.StackTraceExplorer.ParsedStackFrame"/> to
            a location.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.StackTraceExplorer.StackFrameSymbolPart.Method">
            <summary>
            The intended lookup is to find a method symbol associated 
            with a <see cref="T:Microsoft.CodeAnalysis.StackTraceExplorer.ParsedStackFrame"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.StackTraceExplorer.StackFrameSymbolPart.ContainingType">
            <summary>
            The intended lookup is to find a type symbol associated
            with a <see cref="T:Microsoft.CodeAnalysis.StackTraceExplorer.ParsedStackFrame"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.StackTraceExplorer.StackTraceAnalyzer.s_parsers">
            <summary>
            List of parsers to use. Order is important because
            take the result from the first parser that returns 
            success.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.StringIndentation.StringIndentationRegion.IndentSpan">
            <summary>
            The entire span of the indent region.  Given code like:
            
            <code>
            var x = """
                    x
                    y
                    """;
            </code>
            
            The span will be the region between the ^'s in:
            
            <code>
            ^var x = """
                    x
                    y
                    ^""";
            </code>
            
            The span must be on the start and end lines of the string literal as those are the only lines with content
            known to exist.  In other words, the lines with content on them may be entire empty (or still shorter than
            the indent column), so there's no actual position to associate the span with.
            
            The start of the span should be the start of the line that the string literal starts on.  The end of the
            span should be at the start of the ending quotes of the literal.
            
            The tagger can then use this span to draw a line like so:
            
            <code>
            var x = """
                   |x
                   |y
                    """;
            </code>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.StringIndentation.StringIndentationRegion.OrderedHoleSpans">
            <summary>
            Regions of the literal that count as 'code holes' and which the lines of the tagger should not draw through.
            For example, given code like:
            
            <code>
            var x = $"""
                    x
                    {
                        1 + 1
                    } xcont
                    y
                    {
                        2 + 2
                    } ycont
                    z
                    """;
            </code>
            
            Then there will be two holes demarcated by the ^'s in the following:
            
            <code>
            var x = $"""
                    x
                    ^{
                        1 + 1
                    }^ xcont
                    y
                    ^{
                        2 + 2
                    }^ ycont
                    z
                    """;
            </code>
            
            If the line draw were to intersect one of these spans it will not be drawn, causing the following to be
            presented:
            
            <code>
            var x = $"""
                   |x
                   |{
                        1 + 1
                    } xcont
                   |y
                   |{
                        2 + 2
                    } ycont
                   |z
                    """;
            </code>
            
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Structure.BlockSpan.IsCollapsible">
            <summary>
            Whether or not this span can be collapsed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Structure.BlockSpan.TextSpan">
            <summary>
            The span of text to collapse.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Structure.BlockSpan.HintSpan">
            <summary>
            The span of text to display in the hint on mouse hover.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Structure.BlockSpan.SubHeadings">
            <summary>
            Gets the optional span of the primary header of the code block represented by this tag. For example, in the
            following snippet of code:
            <code>
                if (condition1)
                {
                    //something;
                }
                else
                {
                    // something else;
                }
            </code>
            The primary span representing "else" statement block would be the same as the <see cref="P:Microsoft.CodeAnalysis.Structure.BlockSpan.TextSpan"/> of
            block span for the  "if" block. This allows structure visualizing features to provide more useful context
            when visualizing "else" structure blocks.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Structure.BlockSpan.BannerText">
            <summary>
            The text to display inside the collapsed region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Structure.BlockSpan.AutoCollapse">
            <summary>
            Whether or not this region should be automatically collapsed when the 'Collapse to Definitions' command is invoked.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Structure.BlockSpan.IsDefaultCollapsed">
            <summary>
            Whether this region should be collapsed by default when a file is opened the first time.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Structure.BlockSpan.Type">
            <summary>
            A string defined from <see cref="T:Microsoft.CodeAnalysis.Structure.BlockTypes"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Structure.BlockStructureService.GetService(Microsoft.CodeAnalysis.Document)">
            <summary>
            Gets the service corresponding to the specified document.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Structure.BlockStructureService.Language">
            <summary>
            The language from <see cref="T:Microsoft.CodeAnalysis.LanguageNames"/> this service corresponds to.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Structure.BlockStructureServiceWithProviders.GetBuiltInProviders">
            <summary>
            Returns the providers always available to the service.
            This does not included providers imported via MEF composition.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Structure.AbstractBlockStructureProvider">
            <summary>
            Note: this type is for subclassing by the VB and C# provider only.
            It presumes that the language supports Syntax Trees.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolMapping.ISymbolMappingService.MapSymbolAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SymbolKey,System.Threading.CancellationToken)">
            <summary>
            Given a <cref see="SymbolId"/> and the document whence the corresponding <cref see="ISymbol"/>
            came, locate an identical symbol in the correct solution for performing common symbol operations
            (e.g. find references) as defined by this service.
            </summary>
            <param name="document">The document whence the symbol came</param>
            <param name="symbolId">The id of the symbol to map</param>
            <param name="cancellationToken">To cancel symbol resolution</param>
            <returns>The matching symbol from the correct solution or null</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolMapping.ISymbolMappingService.MapSymbolAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)">
            <summary>
            Given an <cref see="ISymbol"/> and the document whence the corresponding <cref see="ISymbol"/>
            came, locate an identical symbol in the correct solution for performing common symbol operations
            (e.g. find references) as defined by this service.
            </summary>
            <param name="document">The document whence the symbol came</param>
            <param name="symbol">The symbol to map</param>
            <param name="cancellationToken">To cancel symbol resolution</param>
            <returns>The matching symbol from the correct solution or null</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolSearch.SymbolSearchOptions.SearchReferencedProjectSymbols">
            <summary>
            Search for symbols contained in the starting project/compilation.  These are source or metadata symbols that can
            be referenced just by adding a using/import.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolSearch.SymbolSearchOptions.SearchUnreferencedProjectSourceSymbols">
            <summary>
            Search for source symbols in non-referenced projects.  These are source symbols that can be referenced by adding
            a project reference as well as a using/import.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolSearch.SymbolSearchOptions.SearchUnreferencedMetadataSymbols">
            <summary>
            Search for source symbols in non-referenced metadata assemblies (that are referenced by other projects).  These
            are source symbols that can be referenced by adding a metadata reference as well as a using/import.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolSearch.SymbolSearchOptions.SearchReferenceAssemblies">
            <summary>
            Search for well known symbols in the common set of .Net reference assemblies.  We have an index for these and
            they are common enough to want to always search.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolSearch.SymbolSearchOptions.SearchNuGetPackages">
            <summary>
            Search for symbols in the NuGet package index.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolSearch.IDelayService">
            <summary>
            Used so we can mock out how the search service delays work for testing purposes.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolSearch.IDelayService.UpdateSucceededDelay">
            <summary>
            The time to wait after a successful update (default = 1 day).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolSearch.IDelayService.ExpectedFailureDelay">
            <summary>
            The time to wait after a simple expected sort of failure (i.e. IO exceptions, 
            network exceptions, etc).  Things we can recover from and would expect would 
            be transient.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolSearch.IDelayService.CatastrophicFailureDelay">
            <summary>
            The time to wait after a catastrophic failed update (default = 1 day).  For
            example, if we download the full DB xml from the server and we cannot parse
            it.  Retrying soon after will not help.  We'll just have to wait until proper
            data is on the server for us to query.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolSearch.IDelayService.FileWriteDelay">
            <summary>
            The time to wait after writing to disk fails (default = 10 seconds).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SymbolSearch.IDelayService.CachePollDelay">
            <summary>
            How long to wait between each poll of the cache (default = 1 minute).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolSearch.IFileDownloaderFactory">
            <summary>
            Used so we can mock out the remote control service in unit tests.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolSearch.IIOService">
            <summary>
            Used so we can mock out how the search service does IO for testing purposes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolSearch.IPatchService">
            <summary>
            Used so we can mock out patching in unit tests.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolSearch.NativePatching">
            <summary>
            Wrapper around the msdelta api so we can consume patches produced by the Elfie service.
            Pinvokes and code provided by Dan Thompson
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolSearch.SymbolSearchUpdateEngine">
            <summary>
            A service which enables searching for packages matching certain criteria.
            It works against a <see cref="N:Microsoft.CodeAnalysis.Elfie"/> database to find results.
            
            This implementation also spawns a task which will attempt to keep that database up to
            date by downloading patches on a daily basis.
            </summary>
            <summary>
            A service which enables searching for packages matching certain criteria.
            It works against a <see cref="N:Microsoft.CodeAnalysis.Elfie"/> database to find results.
            
            This implementation also spawns a task which will attempt to keep that database up to
            date by downloading patches on a daily basis.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolSearch.SymbolSearchUpdateEngine.#ctor(Microsoft.CodeAnalysis.SymbolSearch.IFileDownloaderFactory)">
            <summary>
            Don't call directly. Use <see cref="T:Microsoft.CodeAnalysis.SymbolSearch.SymbolSearchUpdateEngineFactory"/> instead.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolSearch.SymbolSearchUpdateEngine.#ctor(Microsoft.CodeAnalysis.SymbolSearch.IFileDownloaderFactory,Microsoft.CodeAnalysis.SymbolSearch.IDelayService,Microsoft.CodeAnalysis.SymbolSearch.IIOService,Microsoft.CodeAnalysis.SymbolSearch.IPatchService,Microsoft.CodeAnalysis.SymbolSearch.IDatabaseFactoryService,System.Func{System.Exception,System.Threading.CancellationToken,System.Boolean})">
            <summary>
            For testing purposes only.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolSearch.SymbolSearchUpdateEngine.s_logs">
            <summary>
            Logged messages kept in memory to help us diagnose what was going on previously if a crash occurs.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolSearch.SymbolSearchUpdateEngine.UpdateContinuouslyAsync(System.String,System.String,System.Threading.CancellationToken)">
            <param name="cancellationToken">
            Cancellation support for the task we use to keep the local database up to date.
            Currently used only in tests so we can shutdown gracefully.  In normal VS+OOP scenarios
            we don't care about this and we just get torn down when the OOP process goes down.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolSearch.SymbolSearchUpdateEngine.Updater.UpdateInBackgroundAsync(System.Threading.CancellationToken)">
            <summary>
            Internal for testing purposes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolSearch.SymbolSearchUpdateEngine.Updater.UpdateDatabaseInBackgroundWorkerAsync(System.Threading.CancellationToken)">
            <returns>The timespan the caller should wait until calling this method again.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolSearch.SymbolSearchUpdateEngine.Updater.CreateAndSetInMemoryDatabase(System.Byte[],System.Boolean)">
            <summary>
            Creates a database instance with the bytes passed in.  If creating the database succeeds,
            then it will be set as the current in memory version.  In the case of failure (which 
            indicates that our data is corrupt), the exception will bubble up and must be appropriately
            dealt with by the caller.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolSearch.SymbolSearchUpdateEngine.Updater.TryDownloadFileAsync(Microsoft.CodeAnalysis.SymbolSearch.IFileDownloader,System.Threading.CancellationToken)">
            <summary>Returns 'null' if download is not available and caller should keep polling.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolSearch.SymbolSearchUpdateEngineFactory">
            <summary>
            Factory that will produce the <see cref="T:Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchUpdateEngine"/>.  The default
            implementation produces an engine that will run in-process.  Implementations at
            other layers can behave differently (for example, running the engine out-of-process).
            </summary>
            <remarks>
            This returns an No-op engine on non-Windows OS, because the backing storage depends on Windows APIs.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolSearch.SymbolSearchUpdateEngineFactory.CreateEngineInProcess(Microsoft.CodeAnalysis.SymbolSearch.IFileDownloaderFactory)">
            <summary>
            This returns a No-op engine if called on non-Windows OS, because the backing storage depends on Windows APIs.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyncNamespaces.AbstractSyncNamespacesService`2.SyncNamespacesAsync(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Project},System.IProgress{Microsoft.CodeAnalysis.CodeAnalysisProgress},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyncNamespaces.ISyncNamespacesService.SyncNamespacesAsync(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Project},System.IProgress{Microsoft.CodeAnalysis.CodeAnalysisProgress},System.Threading.CancellationToken)">
            <summary>
            This will update documents in the specified projects so that their namespace matches the RootNamespace
            and their relative folder path.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UnusedReferences.IReferenceCleanupService.GetProjectReferencesAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Return the set of direct Project and Package references for the given project. This
            is used to get the initial state of the TreatAsUsed attribute for each reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UnusedReferences.IReferenceCleanupService.TryUpdateReferenceAsync(System.String,Microsoft.CodeAnalysis.UnusedReferences.ReferenceUpdate,System.Threading.CancellationToken)">
            <summary>
            Updates the projects reference by removing or marking references as
            TreatAsUsed in the project file.
            </summary>
            <returns>True, if the reference was updated.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UnusedReferences.ProjectAssets.ProjectAssetsReader.AddDependencyHierarchies(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.UnusedReferences.ReferenceInfo},Microsoft.CodeAnalysis.UnusedReferences.ProjectAssets.ProjectAssetsFile)">
            <summary>
            Enhances references with the assemblies they bring into the compilation and their dependency hierarchy.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.UnusedReferences.ReferenceInfo.ReferenceType">
            <summary>
            Indicates the type of reference.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.UnusedReferences.ReferenceInfo.ItemSpecification">
            <summary>
            Uniquely identifies the reference.
            </summary>
            <remarks>
            Should match the Include or Name attribute used in the project file.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.UnusedReferences.ReferenceInfo.TreatAsUsed">
            <summary>
            Indicates that this reference should be treated as if it were used.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.UnusedReferences.ReferenceInfo.CompilationAssemblies">
            <summary>
            The full assembly paths that this reference directly adds to the compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.UnusedReferences.ReferenceInfo.Dependencies">
            <summary>
            The dependencies that this reference transitively brings in to the compilation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.UnusedReferences.ReferenceType.Unknown">
            <summary>
            Unknown reference type
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.UnusedReferences.ReferenceType.Assembly">
            <summary>
            Individual assembly reference `&lt;Reference ... /&gt;`
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.UnusedReferences.ReferenceType.Package">
            <summary>
            NuGet package reference `&lt;PackageReference ... /&gt;`
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.UnusedReferences.ReferenceType.Project">
            <summary>
            Project reference `&lt;ProjectReference ... /&gt;`
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.UnusedReferences.ReferenceUpdate.Action">
            <summary>
            Indicates action to perform on the reference.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.UnusedReferences.ReferenceUpdate.ReferenceInfo">
            <summary>
            Gets the reference to be updated.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.UnusedReferences.UpdateAction.None">
            <summary>
            No action needs to be performed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.UnusedReferences.UpdateAction.TreatAsUsed">
            <summary>
            Indicates the reference should be marked as used.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.UnusedReferences.UpdateAction.TreatAsUnused">
            <summary>
            Indicates the reference should be marked as unused
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.UnusedReferences.UpdateAction.Remove">
            <summary>
            Indicates the reference should be removed from the project.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.UseAutoProperty.AbstractUseAutoPropertyAnalyzer`7.s_analysisResultPool">
            <summary>
            ConcurrentStack as that's the only concurrent collection that supports 'Clear' in netstandard2.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.UseAutoProperty.AbstractUseAutoPropertyAnalyzer`7._fieldNamesPool">
            <summary>
            Not static as this has different semantics around case sensitivity for C# and VB.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UseAutoProperty.AbstractUseAutoPropertyAnalyzer`7.GetAnalyzerCategory">
            <summary>
            A method body edit anywhere in a type will force us to reanalyze the whole type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UseAutoProperty.AbstractUseAutoPropertyAnalyzer`7.AnalysisResult">
            <param name="Property">The property we will make into an auto-property.</param>
            <param name="Field">The field we are removing.</param>
            <param name="PropertyDeclaration">The single declaration that <paramref name="Property"/> has.</param>
            <param name="FieldDeclaration">The single containing declaration that <paramref name="Field"/> has.</param>
            <param name="VariableDeclarator">The single containing declarator that <paramref name="Field"/> has.</param>
            <param name="Notification">The option value/severity at this particular analysis location.</param>
            <param name="IsTrivialGetAccessor">If the get-accessor is of a trivial form like <c>get => fieldName;</c>.  Such
            an accessor is a simple 'read through to the field' accessor.  As such, reads of the field can be replaced with
            calls to this accessor as it will have the same semantics.</param>
            <param name="IsTrivialSetAccessor">Same as <paramref name="IsTrivialSetAccessor"/>. Such an accessor is a simple
            'write through to the field' accessor.  As such, writes of the field can be replaced with calls to this accessor
            as it will have the same semantics.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UseAutoProperty.AbstractUseAutoPropertyAnalyzer`7.AnalysisResult.#ctor(Microsoft.CodeAnalysis.IPropertySymbol,Microsoft.CodeAnalysis.IFieldSymbol,`1,`3,`4,Microsoft.CodeAnalysis.CodeStyle.NotificationOption2,System.Boolean,System.Boolean)">
            <param name="Property">The property we will make into an auto-property.</param>
            <param name="Field">The field we are removing.</param>
            <param name="PropertyDeclaration">The single declaration that <paramref name="Property"/> has.</param>
            <param name="FieldDeclaration">The single containing declaration that <paramref name="Field"/> has.</param>
            <param name="VariableDeclarator">The single containing declarator that <paramref name="Field"/> has.</param>
            <param name="Notification">The option value/severity at this particular analysis location.</param>
            <param name="IsTrivialGetAccessor">If the get-accessor is of a trivial form like <c>get => fieldName;</c>.  Such
            an accessor is a simple 'read through to the field' accessor.  As such, reads of the field can be replaced with
            calls to this accessor as it will have the same semantics.</param>
            <param name="IsTrivialSetAccessor">Same as <paramref name="IsTrivialSetAccessor"/>. Such an accessor is a simple
            'write through to the field' accessor.  As such, writes of the field can be replaced with calls to this accessor
            as it will have the same semantics.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.UseAutoProperty.AbstractUseAutoPropertyAnalyzer`7.AnalysisResult.Property">
            <summary>The property we will make into an auto-property.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.UseAutoProperty.AbstractUseAutoPropertyAnalyzer`7.AnalysisResult.Field">
            <summary>The field we are removing.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.UseAutoProperty.AbstractUseAutoPropertyAnalyzer`7.AnalysisResult.PropertyDeclaration">
            <summary>The single declaration that <paramref name="Property"/> has.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.UseAutoProperty.AbstractUseAutoPropertyAnalyzer`7.AnalysisResult.FieldDeclaration">
            <summary>The single containing declaration that <paramref name="Field"/> has.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.UseAutoProperty.AbstractUseAutoPropertyAnalyzer`7.AnalysisResult.VariableDeclarator">
            <summary>The single containing declarator that <paramref name="Field"/> has.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.UseAutoProperty.AbstractUseAutoPropertyAnalyzer`7.AnalysisResult.Notification">
            <summary>The option value/severity at this particular analysis location.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.UseAutoProperty.AbstractUseAutoPropertyAnalyzer`7.AnalysisResult.IsTrivialGetAccessor">
            <summary>If the get-accessor is of a trivial form like <c>get => fieldName;</c>.  Such
            an accessor is a simple 'read through to the field' accessor.  As such, reads of the field can be replaced with
            calls to this accessor as it will have the same semantics.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.UseAutoProperty.AbstractUseAutoPropertyAnalyzer`7.AnalysisResult.IsTrivialSetAccessor">
            <summary>Same as <paramref name="IsTrivialSetAccessor"/>. Such an accessor is a simple
            'write through to the field' accessor.  As such, writes of the field can be replaced with calls to this accessor
            as it will have the same semantics.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UseAutoProperty.AccessedFields">
            <param name="TrivialField">The single field accessed, when the get/set-accessor is of a trivial form similar to
            <c>get => fieldName;</c> or <c>set => fieldName = value;</c>. If we see these forms, we'll want to convert them to
            <c>get;/set;</c>.</param>
            <param name="NonTrivialFields">Any fields we saw accessed in more complex expressions. These can be converted to use
            the <c>field</c> expression form if we think we can still convert this field/property pair to an auto-prop.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UseAutoProperty.AccessedFields.#ctor(Microsoft.CodeAnalysis.IFieldSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IFieldSymbol})">
            <param name="TrivialField">The single field accessed, when the get/set-accessor is of a trivial form similar to
            <c>get => fieldName;</c> or <c>set => fieldName = value;</c>. If we see these forms, we'll want to convert them to
            <c>get;/set;</c>.</param>
            <param name="NonTrivialFields">Any fields we saw accessed in more complex expressions. These can be converted to use
            the <c>field</c> expression form if we think we can still convert this field/property pair to an auto-prop.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.UseAutoProperty.AccessedFields.TrivialField">
            <summary>The single field accessed, when the get/set-accessor is of a trivial form similar to
            <c>get => fieldName;</c> or <c>set => fieldName = value;</c>. If we see these forms, we'll want to convert them to
            <c>get;/set;</c>.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.UseAutoProperty.AccessedFields.NonTrivialFields">
            <summary>Any fields we saw accessed in more complex expressions. These can be converted to use
            the <c>field</c> expression form if we think we can still convert this field/property pair to an auto-prop.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ValueTracking.ValueTracker.OperationCollector.Clone">
            <summary>
            Clone the current collector into a new one with
            the same parent but a separate progress collector.
            This allows collection of items given the same state
            as this collector while also keeping them "grouped" separately.
            </summary>
            <remarks>
            This is useful for cases such as tracking arguments, where each
            argument may be an expression or something else. We want to track each
            argument expression in the correct order, but a single argument may produce
            multiple items. By cloning we can track the items for each argument and then
            gather them all at the end to report in the correct order.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.CompileTimeSolutionProvider">
            <summary>
            Provides a compile-time view of the current workspace solution.
            Workaround for Razor projects which generate both design-time and compile-time source files.
            TODO: remove https://github.com/dotnet/roslyn/issues/51678
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.CompileTimeSolutionProvider._designTimeToCompileTimeSolution">
            <summary>
            Cached compile-time solution corresponding to an existing design-time solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.CompileTimeSolutionProvider.BuildGeneratedDocumentPaths(System.String,System.String,System.String)">
            <summary>
            Note that in .NET 6 Preview 7 the source generator changed to passing in the relative doc path without a leading \ to GetIdentifierFromPath
            which caused the source generated file name to no longer be prefixed by an _.  Additionally, the file extension was changed to .g.cs
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.ICompileTimeSolutionProvider">
            <summary>
            Provides a compile-time view of the current workspace solution.
            Workaround for Razor projects which generate both design-time and compile-time source files.
            TODO: remove https://github.com/dotnet/roslyn/issues/51678
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Wrapping.AbstractSyntaxWrapper">
            <summary>
            Common implementation of all <see cref="T:Microsoft.CodeAnalysis.Wrapping.ISyntaxWrapper"/>.  This type takes care of a lot of common logic for
            all of them, including:
            
            1. Keeping track of code action invocations, allowing code actions to then be prioritized on
               subsequent invocations.
               
            2. Checking nodes and tokens to make sure they are safe to be wrapped.
            
            Individual subclasses may be targeted at specific syntactic forms.  For example, wrapping
            lists, or wrapping logical expressions.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Wrapping.AbstractSyntaxWrapper.AbstractCodeActionComputer`1">
            <summary>
            Class responsible for actually computing the entire set of code actions to offer the
            user.  Contains lots of helper functionality used by all the different Wrapper
            implementations.
            
            Specifically subclasses of this type can simply provide a list of code-actions to
            perform.  This type will then take those code actions and will ensure there aren't
            multiple code actions that end up having the same effect on the document.  For example,
            a "wrap all" action may produce the same results as a "wrap long" action.  In that case
            this type will only keep around the first of those actions to prevent showing the user
            something that will be unclear.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.AbstractSyntaxWrapper.AbstractCodeActionComputer`1.s_toFormatAnnotation">
            <summary>
            Annotation used so that we can track the top-most node we want to format after
            performing all our edits.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.AbstractSyntaxWrapper.AbstractCodeActionComputer`1._seenDocumentRoots">
            <summary>
            The contents of the documents we've created code-actions for.  This is used so that
            we can prevent creating multiple code actions that produce the same results.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Wrapping.AbstractSyntaxWrapper.AbstractCodeActionComputer`1.TryCreateCodeActionAsync(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Wrapping.Edit},System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Try to create a CodeAction representing these edits.  Can return <see langword="null"/> in several 
            cases, including:
            
                1. No edits.
                2. Edits would change more than whitespace.
                3. A previous code action was created that already had the same effect.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Wrapping.AbstractWrappingCodeRefactoringProvider">
            <summary>
            Base type for the C# and VB wrapping refactorings.  The only responsibility of this type is
            to walk up the tree at the position the user is at, seeing if any node above the user can be
            wrapped by any provided <see cref="T:Microsoft.CodeAnalysis.Wrapping.ISyntaxWrapper"/>s.
            
            Once we get any wrapping actions, we stop looking further.  This keeps the refactorings
            scoped as closely as possible to where the user is, as well as preventing overloading of the
            lightbulb with too many actions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Wrapping.BinaryExpression.AbstractBinaryExpressionWrapper`1.GetNewLineBeforeOperatorTrivia(Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Get's the language specific trivia that should be inserted before an operator if the
            user wants to wrap the operator to the next line.  For C# this is a simple newline-trivia.
            For VB, this will be a line-continuation char (<c>_</c>), followed by a newline.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.BinaryExpression.AbstractBinaryExpressionWrapper`1.BinaryExpressionCodeActionComputer._newlineBeforeOperatorTrivia">
            <summary>
            trivia to place at the end of a node prior to a chunk that is wrapped.
            For C# this will just be a newline.  For VB this will include a line-
            continuation character.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.BinaryExpression.AbstractBinaryExpressionWrapper`1.BinaryExpressionCodeActionComputer._indentAndAlignTrivia">
            <summary>
            The indent trivia to insert if we are trying to align wrapped code with the 
            start of the original expression.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.BinaryExpression.AbstractBinaryExpressionWrapper`1.BinaryExpressionCodeActionComputer._smartIndentTrivia">
            <summary>
            The indent trivia to insert if we are trying to simply smart-indent all wrapped
            parts of the expression.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Wrapping.ChainedExpression.AbstractChainedExpressionWrapper`2">
             <summary>
             Finds and wraps 'chained' expressions.  For the purpose of this feature, a chained
             expression is built out of 'chunks' where each chunk is of the form
            
             <code>
                 . name (arglist) remainder
             </code>
             
             So, if there are two or more of these like:
             
             <code>
                 . name1 (arglist1) remainder1 . name2 (arglist2) remainder2
             </code>
             
             Then this will be wrapped such that the dots align like so:
             
             <code>
                 . name1 (arglist1) remainder1
                 . name2 (arglist2) remainder2
             </code>
             
             Note: for the sake of simplicity, (arglist) is used both for the argument list of
             an InvocationExpression and an ElementAccessExpression.
             
             'remainder' is all the postfix expression that can follow <c>. name (arglist)</c>.  i.e.
             member-access expressions, conditional-access expressions, etc.  Effectively, anything
             the language allows at this point as long as it doesn't start another 'chunk' itself.
             
             This approach gives an intuitive wrapping algorithm that matches the common way
             many wrap dotted invocations, while also effectively not limiting the wrapper to
             only simple forms like <c>.a(...).b(...).c(...)</c>.  
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Wrapping.ChainedExpression.AbstractChainedExpressionWrapper`2.GetNewLineBeforeOperatorTrivia(Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Gets the language specific trivia that should be inserted before an operator if the
            user wants to wrap the operator to the next line.  For C# this is a simple newline-trivia.
            For VB, this will be a line-continuation char (<c>_</c>), followed by a newline.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Wrapping.ChainedExpression.AbstractChainedExpressionWrapper`2.FindNextChunkStart(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.SyntaxNodeOrToken},System.Boolean,System.Int32)">
            <summary>
            Looks for the next sequence of <c>. Name (ArgList)</c>.  Note, except for the first
            chunk, this cannot be of the form <c>? . Name (ArgList)</c> as we do not want to 
            wrap before a dot in a <c>?.</c> form.  This doesn't matter for the first chunk as
            we won't be wrapping that one.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Wrapping.ChainedExpression.AbstractChainedExpressionWrapper`2.Decompose(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.SyntaxNodeOrToken})">
            <summary>
            Walks down <paramref name="node"/> decomposing it into the individual tokens and nodes we want to look for chunks in. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Wrapping.ChainedExpression.AbstractChainedExpressionWrapper`2.CallExpressionCodeActionComputer">
            <summary>
            Responsible for actually computing the set of potential wrapping options
            for chained expressions.  The three options we offer are basically
            1. wrap-each. Each chunk will be wrapped and aligned with the first chunk.
            2. wrap-long. The same as '1', except a chunk will only be wrapped
               if it would go past the preferred wrapping column.
            3. Unwrap.  All the chunks will be placed on a single line.
            
            Note: These three options are always computed and returned.  The caller
            is the one that ends up eliminating any if they would be redundant.  i.e.
            if wrap-long produces the same results as wrap-each, then the caller will
            filter it out.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.ChainedExpression.AbstractChainedExpressionWrapper`2.CallExpressionCodeActionComputer._chunks">
            <summary>
            The chunks to normalize and wrap.  The first chunk will be normalized,
            but not wrapped.  Successive chunks will be normalized and wrapped 
            appropriately depending on if this is wrap-each or wrap-long.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.ChainedExpression.AbstractChainedExpressionWrapper`2.CallExpressionCodeActionComputer._newlineBeforeOperatorTrivia">
            <summary>
            trivia to place at the end of a node prior to a chunk that is wrapped.
            For C# this will just be a newline.  For VB this will include a line-
            continuation character.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.ChainedExpression.AbstractChainedExpressionWrapper`2.CallExpressionCodeActionComputer._firstPeriodIndentationTrivia">
            <summary>
            The indent trivia to insert if we are trying to align wrapped chunks with the 
            first period of the original chunk.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.ChainedExpression.AbstractChainedExpressionWrapper`2.CallExpressionCodeActionComputer._smartIndentTrivia">
            <summary>
            The indent trivia to insert if we are trying to simply smart-indent all wrapped
            chunks.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Wrapping.Edit">
            <summary>
            Represents an edit between two tokens.  Specifically, provides the new trailing trivia for
            the <see cref="F:Microsoft.CodeAnalysis.Wrapping.Edit.Left"/> token and the new leading trivia for the <see
            cref="F:Microsoft.CodeAnalysis.Wrapping.Edit.Right"/> token.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Wrapping.Edit.DeleteBetween(Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Create the Edit representing the deletion of all trivia between left and right.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Wrapping.ICodeActionComputer.GetTopLevelCodeActionsAsync(System.Threading.CancellationToken)">
            <summary>
            Produces the actual top-level code wrapping actions for the original node provided.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Wrapping.ISyntaxWrapper">
            <summary>
            Interface for types that can wrap some sort of language construct.
            </summary>
            <remarks>
            The main refactoring
            keeps walking up nodes until it finds the first IWrapper that can handle that node.  That
            way the user is not inundated with lots of wrapping options for all the nodes their cursor
            is contained within.
            </remarks>
            <seealso cref="T:Microsoft.CodeAnalysis.Wrapping.AbstractWrappingCodeRefactoringProvider"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Wrapping.ISyntaxWrapper.TryCreateComputerAsync(Microsoft.CodeAnalysis.Document,System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Wrapping.SyntaxWrappingOptions,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Returns the <see cref="T:Microsoft.CodeAnalysis.Wrapping.ICodeActionComputer"/> that produces wrapping code actions for the  
            node passed in.  Returns <see langword="null"/> if this Wrapper cannot wrap this node.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Wrapping.SeparatedSyntaxList.AbstractSeparatedSyntaxListWrapper`2">
            <summary>
            Base type for all wrappers that involve wrapping a comma-separated list of items.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Wrapping.SeparatedSyntaxList.AbstractSeparatedSyntaxListWrapper`2.SeparatedSyntaxListCodeActionComputer">
            <summary>
            Class responsible for actually computing the entire set of code actions to offer the user.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.SeparatedSyntaxList.AbstractSeparatedSyntaxListWrapper`2.SeparatedSyntaxListCodeActionComputer._afterOpenTokenIndentationTrivia">
            <summary>
            The indentation string necessary to indent an item in a list such that the start of
            that item will exact start at the end of the open-token for the containing list. i.e.
            
                void Goobar(
                            ^
                            |
            
            This is the indentation we want when we're aligning wrapped items with the first item 
            in the list.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.SeparatedSyntaxList.AbstractSeparatedSyntaxListWrapper`2.SeparatedSyntaxListCodeActionComputer._singleIndentationTrivia">
            <summary>
            Indentation amount for any items that have been wrapped to a new line.  Valid if we're
            not aligning with the first item. i.e.
            
                void Goobar(
                    ^
                    |
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.SeparatedSyntaxList.AbstractSeparatedSyntaxListWrapper`2.SeparatedSyntaxListCodeActionComputer._braceIndentationTrivia">
            <summary>
            Indentation to use when placing brace.  e.g.:
            
                var v = new List {
                ^
                |
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.SeparatedSyntaxList.AbstractSeparatedSyntaxListWrapper`2.SeparatedSyntaxListCodeActionComputer._shouldMoveOpenBraceToNewLine">
            <summary>
            Whether or not we should move the open brace of this separated list to a new line.  Many separated lists
            will never move the brace (like a parameter list).  And some separated lists may move the brace
            depending on if a particular option is set (like the collection initializer brace in C#).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.SeparatedSyntaxList.AbstractSeparatedSyntaxListWrapper`2.SeparatedSyntaxListCodeActionComputer._shouldMoveCloseBraceToNewLine">
            <summary>
            Whether or not we should move the close brace of this separated list to a new line.  Some lists will
            never move the close brace (like a parameter list), while some will always move it (like a collection
            initializer in both C# or VB).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.SeparatedSyntaxList.WrappingStyle.WrapFirst_IndentRest">
            <summary>
            Wraps first item.  Subsequent items, if wrapped, will be aligned with that first item:
                 MethodName(
                     int a, int b, int c, int d, int e,
                     int f, int g, int h, int i, int j)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.SeparatedSyntaxList.WrappingStyle.UnwrapFirst_AlignRest">
            <summary>
            Unwraps first item.  Subsequent items, if wrapped, will be aligned with that first item:
                 MethodName(int a, int b, int c, int d, int e,
                            int f, int g, int h, int i, int j)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.SeparatedSyntaxList.WrappingStyle.UnwrapFirst_IndentRest">
            <summary>
            Unwraps first item.  Subsequent items, if wrapped, will be indented:
                 MethodName(int a, int b, int c, int d, int e,
                     int f, int g, int h, int i, int j)
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Wrapping.WrapItemsAction">
            <summary>
            Code action for actually wrapping items.  Provided as a special subclass because it will
            also update the wrapping most-recently-used list when the code action is actually
            invoked.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Wrapping.WrapItemsAction.#ctor(System.String,System.String,System.Func{System.IProgress{Microsoft.CodeAnalysis.CodeAnalysisProgress},System.Threading.CancellationToken,System.Threading.Tasks.Task{Microsoft.CodeAnalysis.Document}})">
            <summary>
            Code action for actually wrapping items.  Provided as a special subclass because it will
            also update the wrapping most-recently-used list when the code action is actually
            invoked.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Wrapping.WrappingGroup">
            <summary>
            A group of wrapping actions placed under a common title.  For example:
                Unwrap group:
                    unwrap option 1
                    unwrap option 2
                Wrap all group:
                    wrap all option 1
                    wrap all optoin 2
                    ...
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Wrapping.WrappingGroup.#ctor(System.Boolean,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Wrapping.WrapItemsAction})">
            <summary>
            A group of wrapping actions placed under a common title.  For example:
                Unwrap group:
                    unwrap option 1
                    unwrap option 2
                Wrap all group:
                    wrap all option 1
                    wrap all optoin 2
                    ...
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.WrappingGroup.IsInlinable">
            <summary>
            Whether or not the items in this group can be inlined in the topmost lightbulb.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Wrapping.WrappingGroup.WrappingActions">
            <summary>
            The actual wrapping code actions for this group to present to the user.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.TextUtilities">
            <summary>
            Holder for common Text Utility functions and values
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextUtilities.GetStartAndLengthOfLineBreakEndingAt(Microsoft.CodeAnalysis.Text.SourceText,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Return startLineBreak = index-1, lengthLineBreak = 2   if there is a \r\n at index-1
            Return startLineBreak = index,   lengthLineBreak = 1   if there is a 1-char newline at index
            Return startLineBreak = index+1, lengthLineBreak = 0   if there is no newline at index.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextUtilities.IsAnyLineBreakCharacter(System.Char)">
            <summary>
            Determine if the character in question is any line break character
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer">
            <summary>
            Code style analyzer that reports at least one 'unnecessary' code diagnostic.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer.#ctor(System.String,Microsoft.CodeAnalysis.CodeStyle.EnforceOnBuild,Microsoft.CodeAnalysis.Options.IOption2,Microsoft.CodeAnalysis.Options.PerLanguageOption2{System.Boolean},Microsoft.CodeAnalysis.LocalizableString,Microsoft.CodeAnalysis.LocalizableString,System.Boolean)">
            <summary>
            Constructor for an unnecessary code style analyzer with a single diagnostic descriptor and
            unique <see cref="T:Microsoft.CodeAnalysis.Options.IPerLanguageValuedOption"/> code style option.
            </summary>
            <param name="diagnosticId">Diagnostic ID reported by this analyzer</param>
            <param name="enforceOnBuild">Build enforcement recommendation for this analyzer</param>
            <param name="option">
            Code style option that can be used to configure the given <paramref name="diagnosticId"/>.
            <see langword="null"/>, if there is no such unique option.
            </param>
            <param name="fadingOption">
            Per-language fading option that can be used to configure if the diagnostic should be faded in the IDE or not.
            <see langword="null"/>, if there is no such unique fading option.
            </param>
            <param name="title">Title for the diagnostic descriptor</param>
            <param name="messageFormat">
            Message for the diagnostic descriptor.
            <see langword="null"/> if the message is identical to the title.
            </param>
            <param name="configurable">Flag indicating if the reported diagnostics are configurable by the end users</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer.#ctor(System.String,Microsoft.CodeAnalysis.CodeStyle.EnforceOnBuild,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.Options.IOption2},Microsoft.CodeAnalysis.Options.PerLanguageOption2{System.Boolean},Microsoft.CodeAnalysis.LocalizableString,Microsoft.CodeAnalysis.LocalizableString,System.Boolean)">
            <summary>
            Constructor for an unnecessary code style analyzer with a single diagnostic descriptor and
            two or more <see cref="T:Microsoft.CodeAnalysis.Options.IPerLanguageValuedOption"/> code style options.
            </summary>
            <param name="diagnosticId">Diagnostic ID reported by this analyzer</param>
            <param name="enforceOnBuild">Build enforcement recommendation for this analyzer</param>
            <param name="options">
            Set of two or more per-language options that can be used to configure the diagnostic severity of the given diagnosticId.
            </param>
            <param name="fadingOption">
            Per-language fading option that can be used to configure if the diagnostic should be faded in the IDE or not.
            <see langword="null"/>, if there is no such unique fading option.
            </param>
            <param name="title">Title for the diagnostic descriptor</param>
            <param name="messageFormat">
            Message for the diagnostic descriptor.
            Null if the message is identical to the title.
            </param>
            <param name="configurable">Flag indicating if the reported diagnostics are configurable by the end users</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer.#ctor(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DiagnosticDescriptor},Microsoft.CodeAnalysis.Options.PerLanguageOption2{System.Boolean})">
            <summary>
            Constructor for an unnecessary code style analyzer with multiple descriptors. All unnecessary descriptors will share the same <paramref name="fadingOption"/>
            </summary>
            <param name="descriptors">Descriptors supported by this analyzer</param>
            <param name="fadingOption">The fading option used to control descriptors that are unnecessary.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer.#ctor(System.Collections.Immutable.ImmutableArray{System.ValueTuple{Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Options.IOption2}},Microsoft.CodeAnalysis.Options.PerLanguageOption2{System.Boolean})">
            <summary>
            Constructor for a code style analyzer with a multiple diagnostic descriptors with a code style options that can be used to configure each descriptor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer.#ctor(System.Collections.Immutable.ImmutableArray{System.ValueTuple{Microsoft.CodeAnalysis.DiagnosticDescriptor,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.Options.IOption2}}},Microsoft.CodeAnalysis.Options.PerLanguageOption2{System.Boolean})">
            <summary>
            Constructor for a code style analyzer with multiple diagnostic descriptors with zero or more code style options that can be used to configure each descriptor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInCodeStyleDiagnosticAnalyzer.#ctor(System.String,Microsoft.CodeAnalysis.CodeStyle.EnforceOnBuild,Microsoft.CodeAnalysis.Options.IOption2,Microsoft.CodeAnalysis.LocalizableString,Microsoft.CodeAnalysis.LocalizableString,System.Boolean,System.Boolean)">
            <summary>
            Constructor for a code style analyzer with a single diagnostic descriptor and
            unique <see cref="T:Microsoft.CodeAnalysis.Options.IOption2"/> code style option.
            </summary>
            <param name="diagnosticId">Diagnostic ID reported by this analyzer</param>
            <param name="enforceOnBuild">Build enforcement recommendation for this analyzer</param>
            <param name="option">
            Code style editorconfig option that can be used to configure the given <paramref name="diagnosticId"/>.
            <see langword="null"/>, if there is no such option that can be set in an editorconfig.
            </param>
            <param name="title">Title for the diagnostic descriptor</param>
            <param name="messageFormat">
            Message for the diagnostic descriptor.
            <see langword="null"/> if the message is identical to the title.
            </param>
            <param name="isUnnecessary"><see langword="true"/> if the diagnostic is reported on unnecessary code; otherwise, <see langword="false"/>.</param>
            <param name="configurable">Flag indicating if the reported diagnostics are configurable by the end users</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInCodeStyleDiagnosticAnalyzer.#ctor(System.String,Microsoft.CodeAnalysis.CodeStyle.EnforceOnBuild,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.Options.IOption2},Microsoft.CodeAnalysis.LocalizableString,Microsoft.CodeAnalysis.LocalizableString,System.Boolean,System.Boolean)">
            <summary>
            Constructor for a code style analyzer with a single diagnostic descriptor and
            two or more <see cref="T:Microsoft.CodeAnalysis.Options.IOption2"/> code style options.
            </summary>
            <param name="diagnosticId">Diagnostic ID reported by this analyzer</param>
            <param name="enforceOnBuild">Build enforcement recommendation for this analyzer</param>
            <param name="options">
            Set of two or more code style editorconfig options that can be used to configure the diagnostic severity of the given diagnosticId.
            </param>
            <param name="title">Title for the diagnostic descriptor</param>
            <param name="messageFormat">
            Message for the diagnostic descriptor.
            Null if the message is identical to the title.
            </param>
            <param name="isUnnecessary"><see langword="true"/> if the diagnostic is reported on unnecessary code; otherwise, <see langword="false"/>.</param>
            <param name="configurable">Flag indicating if the reported diagnostics are configurable by the end users</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInCodeStyleDiagnosticAnalyzer.#ctor(System.Collections.Immutable.ImmutableArray{System.ValueTuple{Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Options.IOption2}})">
            <summary>
            Constructor for a code style analyzer with a multiple diagnostic descriptors with a code style editorconfig option that can be used to configure each descriptor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInCodeStyleDiagnosticAnalyzer.#ctor(System.Collections.Immutable.ImmutableArray{System.ValueTuple{Microsoft.CodeAnalysis.DiagnosticDescriptor,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.Options.IOption2}}})">
            <summary>
            Constructor for a code style analyzer with multiple diagnostic descriptors with zero or more code style editorconfig options that can be used to configure each descriptor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInCodeStyleDiagnosticAnalyzer.#ctor(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DiagnosticDescriptor})">
            <summary>
            Constructor for a code style analyzer with a multiple diagnostic descriptors such that all the descriptors have no unique code style option to configure the descriptors.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInCodeStyleDiagnosticAnalyzer.GeneratedCodeAnalysisFlags">
            <summary>
            Flags to configure the analysis of generated code.
            By default, code style analyzers should not analyze or report diagnostics on generated code, so the value is false.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeStyle.AbstractFormattingAnalyzer.IsHighPriority">
            <summary>
            Fixing formatting is high priority.  It's something the user wants to be able to fix quickly, is driven by
            them acting on an error reported in code, and can be computed fast as it only uses syntax not semantics.
            It's also the 8th most common fix that people use, and is picked almost all the times it is shown.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeStyle.EnforceOnBuild">
            <summary>
            Build enforcement recommendation for a code style analyzer.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.EnforceOnBuild.Never">
            <summary>
            Indicates that the code style diagnostic is an IDE-only diagnostic that cannot be enforced on build.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.EnforceOnBuild.WhenExplicitlyEnabled">
            <summary>
            Indicates that the code style diagnostic can be enforced on build when explicitly enabled in a configuration file,
            but is not part of the <see cref="F:Microsoft.CodeAnalysis.CodeStyle.EnforceOnBuild.Recommended"/> or <see cref="F:Microsoft.CodeAnalysis.CodeStyle.EnforceOnBuild.HighlyRecommended"/> group for build enforcement.
            <para>This is the suggested <b>P3</b> bucket of code style diagnostics to enforce on build.</para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.EnforceOnBuild.Recommended">
            <summary>
            Indicates that the code style diagnostic can be enforced on build and is part of the recommended group for build enforcement.
            <para>This is the suggested <b>P2</b> bucket of code style diagnostics to enforce on build.</para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.EnforceOnBuild.HighlyRecommended">
            <summary>
            Indicates that the code style diagnostic can be enforced on build and is part of the highly recommended group for build enforcement.
            <para>This is the suggested <b>P1</b> bucket of code style diagnostics to enforce on build.</para>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.AbstractFormattingCodeFixProvider.ComputeRequestPriority">
            <summary>
            Fixing formatting is high priority.  It's something the user wants to be able to fix quickly, is driven by
            them acting on an error reported in code, and can be computed fast as it only uses syntax not semantics.
            It's also the 8th most common fix that people use, and is picked almost all the times it is shown.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnnecessaryParentheses.AbstractRemoveUnnecessaryParenthesesDiagnosticAnalyzer`2.GetDiagnosticSquiggleLocation(`1,System.Threading.CancellationToken)">
            <summary>
            Gets the span of text to squiggle underline.
            If the expression is contained within a single line, the entire expression span is returned.
            Otherwise it will return the span from the expression start to the end of the same line.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ConvertTypeOfToNameOf.AbstractConvertTypeOfToNameOfCodeFixProvider`1.ConvertTypeOfToNameOf(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.Editing.SyntaxEditor,`0,System.Threading.CancellationToken)">
            <Summary>
             Method converts typeof(...).Name to nameof(...)
            </Summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderHelper.CommentPrefix">
            <summary>
            Gets the text prefix indicating a single-line comment.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderHelper.SingleLineCommentTriviaKind">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.LanguageService.ISyntaxKinds.SingleLineCommentTrivia"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderHelper.MultiLineCommentTriviaKind">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.LanguageService.ISyntaxKinds.MultiLineCommentTrivia"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderHelper.WhitespaceTriviaKind">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.LanguageService.ISyntaxKinds.WhitespaceTrivia"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderHelper.EndOfLineTriviaKind">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.LanguageService.ISyntaxKinds.EndOfLineTrivia"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderHelper.IndexOfFirstNonWhitespaceTrivia``1(``0)">
            <summary>
            Returns the index of the first non-whitespace trivia in the given trivia list.
            </summary>
            <param name="triviaList">The trivia list to process.</param>
            <typeparam name="T">The type of the trivia list.</typeparam>
            <returns>The index where the non-whitespace starts, or -1 if there is no non-whitespace trivia.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FileHeaders.FileHeader">
            <summary>
            Contains the parsed file header information for a syntax tree.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FileHeaders.FileHeader._fileHeaderStart">
            <summary>
            The location in the source where the file header was expected to start.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FileHeaders.FileHeader._commentPrefixLength">
            <summary>
            The length of the prefix indicating the start of a comment. For example:
            <list type="bullet">
              <item>
                <term>C#</term>
                <description>2, for the length of <c>//</c>.</description>
              </item>
              <item>
                <term>Visual Basic</term>
                <description>1, for the length of <c>'</c>.</description>
              </item>
            </list>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileHeaders.FileHeader.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.FileHeaders.FileHeader"/> struct.
            </summary>
            <param name="copyrightText">The copyright string, as parsed from the header.</param>
            <param name="fileHeaderStart">The offset within the file at which the header started.</param>
            <param name="fileHeaderEnd">The offset within the file at which the header ended.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileHeaders.FileHeader.#ctor(System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.FileHeaders.FileHeader"/> struct.
            </summary>
            <param name="fileHeaderStart">The offset within the file at which the header started, or was expected to start.</param>
            <param name="isMissing"><see langword="true"/> if the file header is missing; otherwise, <see langword="false"/>.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileHeaders.FileHeader.IsMissing">
            <summary>
            Gets a value indicating whether the file header is missing.
            </summary>
            <value>
            <see langword="true"/> if the file header is missing; otherwise, <see langword="false"/>.
            </value>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileHeaders.FileHeader.CopyrightText">
            <summary>
            Gets the copyright text, as parsed from the header.
            </summary>
            <value>
            The copyright text, as parsed from the header.
            </value>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileHeaders.FileHeader.MissingFileHeader(System.Int32)">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.FileHeaders.FileHeader"/> instance representing a missing file header starting at the specified
            position.
            </summary>
            <param name="fileHeaderStart">The location at which a file header was expected. This will typically be the
            start of the first line after any directive trivia (<see cref="P:Microsoft.CodeAnalysis.SyntaxTrivia.IsDirective"/>) to account for
            source suppressions.</param>
            <returns>
            A <see cref="T:Microsoft.CodeAnalysis.FileHeaders.FileHeader"/> instance representing a missing file header.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileHeaders.FileHeader.GetLocation(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Gets the location representing the start of the file header.
            </summary>
            <param name="syntaxTree">The syntax tree to use for generating the location.</param>
            <returns>The location representing the start of the file header.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Analyzers.MatchFolderAndNamespace.AbstractMatchFolderAndNamespaceDiagnosticAnalyzer`2.ContainsPartialTypeWithMultipleDeclarations(`1,Microsoft.CodeAnalysis.SemanticModel)">
            <summary>
            Returns true if the namespace declaration contains one or more partial types with multiple declarations.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.OrderModifiers.AbstractOrderModifiersHelpers._lastParsed">
            <remarks>
            Reference type so we can read/write atomically.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.QualifyMemberAccess.AbstractQualifyMemberAccessDiagnosticAnalyzer`3.CanMemberAccessBeQualified(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Reports on whether the specified member is suitable for qualification. Some member
            access expressions cannot be qualified; for instance if they begin with <c>base.</c>,
            <c>MyBase.</c>, or <c>MyClass.</c>.
            </summary>
            <returns>True if the member access can be qualified; otherwise, False.</returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RemoveUnusedMembers.AbstractRemoveUnusedMembersDiagnosticAnalyzer`4.ContainingTypeAndNameOnlyFormat">
            <summary>
            Produces names like TypeName.MemberName
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedMembers.AbstractRemoveUnusedMembersDiagnosticAnalyzer`4.GetAnalyzerCategory">
            <summary>
            We need to analyze the whole document even for edits within a method body, because we might add or remove
            references to members in executable code. For example, if we had an unused field with no references, then
            editing any single method body to reference this field should clear the unused field diagnostic. Hence, we need
            to re-analyze the declarations in the whole file for any edits within the document. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.RemoveUnusedMembers.AbstractRemoveUnusedMembersDiagnosticAnalyzer`4.GeneratedCodeAnalysisFlags">
            <summary>
            We want to analyze references in generated code, but not report unused members in generated code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedMembers.AbstractRemoveUnusedMembersDiagnosticAnalyzer`4.HandleNamedTypeSymbolStart(Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext,System.Action{Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ValueUsageInfo})">
            <summary>
            Override this method to register custom language specific actions to find symbol usages.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RemoveUnusedMembers.AbstractRemoveUnusedMembersDiagnosticAnalyzer`4.OriginalDefinitionSymbolEqualityComparer">
            <summary>
            We always want to do our processing, considering the original symbol corresponding to the user's declared
            symbols.  As such, we use an instance of this comparer with all the dictionaries and sets we create while
            processing so that reference to non-original definitions (like references to members from an instantiate generic
            type) still count as a use of the original user definition.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RemoveUnusedMembers.AbstractRemoveUnusedMembersDiagnosticAnalyzer`4.CompilationAnalyzer._symbolValueUsageStateMap_doNotAccessDirectly">
            <summary>
            State map for candidate member symbols, with the value indicating how each symbol is used in executable code.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RemoveUnusedMembers.AbstractRemoveUnusedMembersDiagnosticAnalyzer`4.CompilationAnalyzer._propertiesWithShadowGetAccessorUsages">
            <summary>
            List of properties that have a 'get' accessor usage, while the value itself is not used, e.g.:
            <code>
            class C
            {
                private int P { get; set; }
                public void M() { P++; }
            }
            </code>
            Here, 'get' accessor is used in an increment operation, but the result of the increment operation isn't used and 'P' itself is not used anywhere else, so it can be safely removed
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedMembers.AbstractRemoveUnusedMembersDiagnosticAnalyzer`4.CompilationAnalyzer.IsCandidateSymbol(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns true if the given symbol meets the following criteria to be
            a candidate for dead code analysis:
                1. It is marked as "private".
                2. It is not an implicitly declared symbol.
                3. It is either a method, field, property or an event.
                4. If method, then it is a constructor OR a method with <see cref="F:Microsoft.CodeAnalysis.MethodKind.Ordinary"/>,
                   such that is meets a few criteria (see implementation details below).
                5. If field, then it must not be a backing field for an auto property.
                   Backing fields have a non-null <see cref="P:Microsoft.CodeAnalysis.IFieldSymbol.AssociatedSymbol"/>.
                6. If property, then it must not be an explicit interface property implementation
                   or the 'IsCompleted' property which is needed to make a type awaitable.
                7. If event, then it must not be an explicit interface event implementation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedMembers.AbstractRemoveUnusedMembersCodeFixProvider`1.AdjustAndAddAppropriateDeclaratorsToRemove(System.Collections.Generic.HashSet{`0},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            This method adjusts the <paramref name="declarators"/> to remove based on whether or not all variable declarators
            within a field declaration should be removed,
            i.e. if all the fields declared within a field declaration are unused,
            we can remove the entire field declaration instead of individual variable declarators.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedMembers.AbstractRemoveUnusedMembersCodeFixProvider`1.AdjustAndAddAppropriateDeclaratorsToRemove(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            If all the <paramref name="childDeclarators"/> are contained in <paramref name="declarators"/>,
            the removes the <paramref name="childDeclarators"/> from <paramref name="declarators"/>, and
            adds the <paramref name="parentDeclaration"/> to the <paramref name="declarators"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer">
            <summary>
            Analyzer to report unused expression values and parameters:
            It flags the following cases:
                1. Expression statements that drop computed value, for example, "Computation();".
                   These should either be removed (redundant computation) or should be replaced
                   with explicit assignment to discard variable OR an unused local variable,
                   i.e. "_ = Computation();" or "var unused = Computation();"
                   This diagnostic configuration is controlled by language specific code style option "UnusedValueExpressionStatement".
                2. Value assignments to locals/parameters that are never used on any control flow path,
                   For example, value assigned to 'x' in first statement below is unused and will be flagged:
                        x = Computation();
                        if (...)
                            x = Computation2();
                        else
                            Computation3(out x);
                        ... = x;
                   Just as for case 1., these should either be removed (redundant computation) or
                   should be replaced with explicit assignment to discard variable OR an unused local variable,
                   i.e. "_ = Computation();" or "var unused = Computation();"
                   This diagnostic configuration is controlled by language specific code style option "UnusedValueAssignment".
                3. Redundant parameters that fall into one of the following two categories:
                    a. Have no references in the executable code block(s) for its containing method symbol.
                    b. Have one or more references but its initial value at start of code block is never used.
                       For example, if 'x' in the example for case 2. above was a parameter symbol with RefKind.None
                       and "x = Computation();" is the first statement in the method body, then its initial value
                       is never used. Such a parameter should be removed and 'x' should be converted into a local.
                   We provide additional information in the diagnostic message to clarify the above two categories
                   and also detect and mention about potential breaking change if the containing method is a public API.
                   Currently, we do not provide any code fix for removing unused parameters as it needs fixing the
                   call sites and any automated fix can lead to subtle overload resolution differences,
                   though this may change in future.
                   This diagnostic configuration is controlled by <see cref="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions2.UnusedParameters"/> option.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.ShouldBailOutFromRemovableAssignmentAnalysis(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Indicates if we should bail from removable assignment analysis for the given
            symbol write operation.
            Removable assignment analysis determines if the assigned value for the symbol write
            has no side effects and can be removed without changing the semantics.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.IsCallStatement(Microsoft.CodeAnalysis.Operations.IExpressionStatementOperation)">
            <summary>
            Indicates if the given expression statement operation has an explicit "Call" statement syntax indicating explicit discard.
            For example, VB "Call" statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.IsExpressionOfExpressionBody(Microsoft.CodeAnalysis.Operations.IExpressionStatementOperation)">
            <summary>
            Indicates if the given operation is an expression of an expression body.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.CreatePropertiesMap">
            <summary>
            Method to compute well-known diagnostic property maps for different combinations of diagnostic properties.
            The property map is added to each instance of the reported diagnostic and is used by the code fixer to
            compute the correct code fix.
            It currently maps to three different properties of the diagnostic:
                1. The underlying <see cref="T:Microsoft.CodeAnalysis.CodeStyle.UnusedValuePreference"/> for the reported diagnostic
                2. "isUnusedLocalAssignment": Flag indicating if the flagged local variable has no reads/uses.
                3. "isRemovableAssignment": Flag indicating if the assigned value is from an expression that has no side effects
                        and hence can be removed completely. For example, if the assigned value is a constant or a reference
                        to a local/parameter, then it has no side effects, but if it is method invocation, it may have side effects.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer._hasDelegateCreationOrAnonymousFunction">
            <summary>
            Indicates if the operation block has an <see cref="T:Microsoft.CodeAnalysis.Operations.IDelegateCreationOperation"/> or an <see cref="T:Microsoft.CodeAnalysis.Operations.IAnonymousFunctionOperation"/>.
            We use this value in <see cref="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer.ShouldAnalyze(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.ISymbol,System.Boolean@)"/> to determine whether to bail from analysis or not.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer._hasDelegateEscape">
            <summary>
            Indicates if the operation block has an operation that leads to a delegate escaping the current block,
            which would prevent us from performing accurate flow analysis of lambda/local function invocations
            within this operation block.
            Some examples:
                1. Delegate assigned to a field or property.
                2. Delegate passed as an argument to an invocation or object creation.
                3. Delegate added to an array or wrapped within a tuple.
                4. Delegate converted to a non-delegate type.
            We use this value in <see cref="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer.ShouldAnalyze(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.ISymbol,System.Boolean@)"/> to determine whether to bail from analysis or not.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer._hasInvalidOperation">
            <summary>
            Indicates if the operation block has an <see cref="T:Microsoft.CodeAnalysis.Operations.IInvalidOperation"/>.
            We use this value in <see cref="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer.ShouldAnalyze(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.ISymbol,System.Boolean@)"/> to determine whether to bail from analysis or not.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer._referencedParameters">
            <summary>
            Parameters which have at least one read/write reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer.IsHandledDelegateCreationOrAnonymousFunctionTreeShape(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            We handle only certain operation tree shapes in flow analysis
            when delegate creations are involved (lambdas/local functions).
            We track assignments of lambdas/local functions to parameters/locals,
            assignments of parameters/locals to other parameters/locals of delegate types,
            and then delegate invocations through parameter/locals.
            For the remaining unknown ones, we conservatively mark the operation as leading to
            delegate escape, and corresponding bail out from flow analysis in <see cref="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer.ShouldAnalyze(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.ISymbol,System.Boolean@)"/>.
            This function checks the operation tree shape in context of
            an <see cref="T:Microsoft.CodeAnalysis.Operations.IDelegateCreationOperation"/> or an <see cref="T:Microsoft.CodeAnalysis.Operations.IAnonymousFunctionOperation"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer.IsHandledLocalOrParameterReferenceTreeShape(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            We handle only certain operation tree shapes in flow analysis
            when delegate creations are involved (lambdas/local functions).
            We track assignments of lambdas/local functions to parameters/locals,
            assignments of parameters/locals to other parameters/locals of delegate types,
            and then delegate invocations through parameter/locals.
            For the remaining unknown ones, we conservatively mark the operation as leading to
            delegate escape, and corresponding bail out from flow analysis in <see cref="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer.ShouldAnalyze(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.ISymbol,System.Boolean@)"/>.
            This function checks the operation tree shape in context of
            an <see cref="T:Microsoft.CodeAnalysis.Operations.IParameterReferenceOperation"/> or an <see cref="T:Microsoft.CodeAnalysis.Operations.ILocalReferenceOperation"/>
            of delegate type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer.ShouldAnalyze(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.ISymbol,System.Boolean@)">
            <summary>
            Method invoked in <see cref="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer.BlockAnalyzer.AnalyzeOperationBlockEnd(Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext)"/>
            for each operation block to determine if we should analyze the operation block or bail out.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer.SymbolStartAnalyzer._unusedParameters">
            <summary>
            Map from unused parameters to a boolean value indicating if the parameter has a read reference or not.
            For example, a parameter whose initial value is overwritten before any reads
            is an unused parameter with read reference(s).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11">
            <summary>
            Code fixer for unused expression value diagnostics reported by <see cref="T:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer"/>.
            We provide following code fixes:
                1. If the unused value assigned to a local/parameter has no side-effects,
                   we recommend removing the assignment. We consider an expression value to have no side effects
                   if one of the following is true:
                    1. Value is a compile time constant.
                    2. Value is a local or parameter reference.
                    3. Value is a field reference with no or implicit this instance.
                2. Otherwise, if user preference is set to DiscardVariable, and project's
                   language version supports discard variable, we recommend assigning the value to discard.
                3. Otherwise, we recommend assigning the value to a new unused local variable which has no reads.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.TryUpdateNameForFlaggedNode(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Method to update the identifier token for the local/parameter declaration or reference
            that was flagged as an unused value write by the analyzer.
            Returns null if the provided node is not one of the handled node kinds.
            Otherwise, returns the new node with updated identifier.
            </summary>
            <param name="node">Flagged node containing the identifier token to be replaced.</param>
            <param name="newName">New identifier token</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.GetForEachStatementIdentifier(`6)">
            <summary>
            Gets the identifier token for the iteration variable of the given foreach statement node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.WrapWithBlockIfNecessary(System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Wraps the given statements within a block statement.
            Note this method is invoked when replacing a statement that is parented by a non-block statement syntax.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.InsertAtStartOfSwitchCaseBlockForDeclarationInCaseLabelOrClause(`7,Microsoft.CodeAnalysis.Editing.SyntaxEditor,`4)">
            <summary>
            Inserts the given declaration statement at the start of the given switch case block.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.GetReplacementNodeForCompoundAssignment(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.LanguageService.ISyntaxFactsService)">
            <summary>
            Gets the replacement node for a compound assignment expression whose
            assigned value is redundant.
            For example, "x += MethodCall()", where assignment to 'x' is redundant
            is replaced with "_ = MethodCall()" or "var unused = MethodCall()"
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.GetReplacementNodeForVarPattern(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the replacement node for a var pattern.
            We need just to change the identifier of the pattern, not the whole node
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.TryUpdateParentOfUpdatedNode(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts,Microsoft.CodeAnalysis.SemanticModel)">
            <summary>
            Rewrite the parent of a node which was rewritten by <see cref="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.TryUpdateNameForFlaggedNode(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxToken)"/>.
            </summary>
            <param name="parent">The original parent of the node rewritten by <see cref="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.TryUpdateNameForFlaggedNode(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxToken)"/>.</param>
            <param name="newNameNode">The rewritten node produced by <see cref="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.TryUpdateNameForFlaggedNode(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxToken)"/>.</param>
            <param name="editor">The syntax editor for the code fix.</param>
            <param name="syntaxFacts">The syntax facts for the current language.</param>
            <param name="semanticModel">Semantic model for the tree.</param>
            <returns>The replacement node to use in the rewritten syntax tree; otherwise, <see langword="null"/> to only
            rewrite the node originally rewritten by <see cref="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.TryUpdateNameForFlaggedNode(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxToken)"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.ComputeReplacementNode(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Computes correct replacement node, including cases with recursive changes (e.g. recursive pattern node rewrite in fix-all scenario)
            </summary>
            <param name="originalOldNode">The original node for replacement</param>
            <param name="changedOldNode">Node for replacement transformed by previous replacements</param>
            <param name="proposedReplacementNode">Proposed replacement node with changes relative to <paramref name="originalOldNode"/></param>
            <returns>The final replacement for the node</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.NeedsToMoveNewLocalDeclarationsNearReference(System.String)">
            <summary>
            Flag to indicate if the code fix can introduce local declaration statements
            that need to be moved closer to the first reference of the declared variable.
            This is currently only possible for the unused value assignment fix.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.ReplaceDiscardDeclarationsWithAssignmentsAsync(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptions,System.Threading.CancellationToken)">
            <summary>
            Returns an updated <paramref name="memberDeclaration"/> with all the
            local declarations named '_' converted to simple assignments to discard.
            For example, <code>int _ = Computation();</code> is converted to
            <code>_ = Computation();</code>.
            This is needed to prevent the code fix/FixAll from generating code with
            multiple local variables named '_', which is a compiler error.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.AdjustLocalDeclarationsAsync(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptions,System.Threading.CancellationToken)">
            <summary>
            Returns an updated <paramref name="memberDeclaration"/> with all the new
            local declaration statements annotated with <see cref="F:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.s_newLocalDeclarationStatementAnnotation"/>
            moved closer to first reference and all the existing
            local declaration statements annotated with <see cref="F:Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11.s_existingLocalDeclarationWithoutInitializerAnnotation"/>
            whose declared local is no longer used removed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UseCoalesceExpression.AbstractUseCoalesceExpressionForTernaryConditionalCheckDiagnosticAnalyzer`4">
            <summary>
            Looks for code of the form "x == null ? y : x" and offers to convert it to "x ?? y";
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UseCoalesceExpression.AbstractUseCoalesceExpressionForNullableTernaryConditionalCheckDiagnosticAnalyzer`6">
            <summary>
            Looks for code of the form "!x.HasValue ? y : x.Value" and offers to convert it to "x ?? y";
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UseCollectionExpression.CollectionMatch`1">
            <summary>
            Represents statements following an initializer that should be converted into collection-initializer/expression
            elements.
            </summary>
            <param name="Node">The statement that follows that contains the values to add to the new collection-initializer or
            collection-expression. Or the expression directly to add.</param>
            <param name="UseSpread">Whether or not a spread (<c>.. x</c>) element should be created for this statement. This
            is needed as the statement could be cases like <c>expr.Add(x)</c> vs. <c>expr.AddRange(x)</c>. This property
            indicates that the latter should become a spread, without the consumer having to reexamine the statement to see
            what form it is.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UseCollectionExpression.CollectionMatch`1.#ctor(`0,System.Boolean)">
            <summary>
            Represents statements following an initializer that should be converted into collection-initializer/expression
            elements.
            </summary>
            <param name="Node">The statement that follows that contains the values to add to the new collection-initializer or
            collection-expression. Or the expression directly to add.</param>
            <param name="UseSpread">Whether or not a spread (<c>.. x</c>) element should be created for this statement. This
            is needed as the statement could be cases like <c>expr.Add(x)</c> vs. <c>expr.AddRange(x)</c>. This property
            indicates that the latter should become a spread, without the consumer having to reexamine the statement to see
            what form it is.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.UseCollectionExpression.CollectionMatch`1.Node">
            <summary>The statement that follows that contains the values to add to the new collection-initializer or
            collection-expression. Or the expression directly to add.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.UseCollectionExpression.CollectionMatch`1.UseSpread">
            <summary>Whether or not a spread (<c>.. x</c>) element should be created for this statement. This
            is needed as the statement could be cases like <c>expr.Add(x)</c> vs. <c>expr.AddRange(x)</c>. This property
            indicates that the latter should become a spread, without the consumer having to reexamine the statement to see
            what form it is.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UseCollectionInitializer.UpdateExpressionState`2">
            <summary>
            Common immutable state and helpers used by "convert object creation to collection initializer/expression" and "use
            collection expression for builder pattern".
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.UseCollectionInitializer.UpdateExpressionState`2.StartExpression">
            <summary>
            The original object-creation or collection-builder-creation expression.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.UseCollectionInitializer.UpdateExpressionState`2.ContainingStatement">
            <summary>
            The statement containing <see cref="F:Microsoft.CodeAnalysis.UseCollectionInitializer.UpdateExpressionState`2.StartExpression"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.UseCollectionInitializer.UpdateExpressionState`2.ValuePattern">
            <summary>
            The name of the value being mutated.  It is whatever the new object-creation or collection-builder is assigned to.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.UseCollectionInitializer.UpdateExpressionState`2.InitializedSymbol">
            <summary>
            If a different symbol was initialized (for example, a field rather than a local) this will be that symbol.  This
            only applies to the object-creation case.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UseCollectionInitializer.UpdateExpressionState`2.ValuePatternMatches(`0)">
            <summary>
            <see langword="true"/> if this <paramref name="expression"/> is a reference to the object-creation value, or the
            collection-builder that was created.  For example, when seeing <c>x.Add(y)</c> this can be used to see if
            <c>x</c> refers to the value being analyzed, and as such <c>y</c> should be added as an element once this is
            converted to a collection-initializer or collection-expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UseCollectionInitializer.UpdateExpressionState`2.NodeContainsValuePatternOrReferencesInitializedSymbol(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            <see langword="true"/> if the passed in <paramref name="expression"/> contains some reference to the value being
            tracked, or symbol it was assigned to.  This can be used to see if there are other manipulations of that symbol,
            preventing the features from offering to convert these more complex scenarios to
            collection-initializers/expressions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UseCollectionInitializer.UpdateExpressionState`2.TryAnalyzeAddInvocation(`0,System.String,System.Boolean,System.Threading.CancellationToken,`0@)">
            <summary>
            Analyze an expression statement to see if it is a legal call of the form <c>val.Add(...)</c>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UseCollectionInitializer.UpdateExpressionState`2.TryAnalyzeMultiAddInvocation(`0,System.String,System.String,System.Threading.CancellationToken,`0@,System.Boolean@)">
            <summary>
            Analyze an expression statement to see if it is a legal call similar to <c>val.AddRange(...)</c> or
            <c>val.Concat(...)</c>.  This method properly handles cases where there are multiple args passed to a <c>params
            T[]</c> method, or a single arg which might be passed to the same <c>params</c> method, or which may itself be
            an entire collection being added.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UseCollectionInitializer.UpdateExpressionState`2.TryAnalyzeStatementForCollectionExpression(Microsoft.CodeAnalysis.UseCollectionInitializer.IUpdateExpressionSyntaxHelper{`0,`1},`1,System.Threading.CancellationToken)">
            <summary>
            Analyze an statement to see if it it could be converted into elements for a new collection-expression.  This
            includes calls to <c>.Add</c> and <c>.AddRange</c>, as well as <c>foreach</c> statements that update the
            collection, and <c>if</c> statements that conditionally add items to the collection-expression.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.UseCompoundAssignment.AbstractUseCompoundAssignmentDiagnosticAnalyzer`3._binaryToAssignmentMap">
            <summary>
            Maps from a binary expression kind (like AddExpression) to the corresponding assignment
            form (like AddAssignmentExpression).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UseConditionalExpression.UseConditionalExpressionHelpers.UnwrapSingleStatementBlock(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Will unwrap a block with a single statement in it to just that block.  Used so we can
            support both <c>if (expr) { statement }</c> and <c>if (expr) statement</c>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionCodeFixProvider`4.CreateConditionalExpressionAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Operations.IConditionalOperation,Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.IOperation,System.Boolean,Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptions,System.Threading.CancellationToken)">
            <summary>
            Helper to create a conditional expression out of two original IOperation values
            corresponding to the whenTrue and whenFalse parts. The helper will add the appropriate
            annotations and casts to ensure that the conditional expression preserves semantics, but
            is also properly simplified and formatted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionCodeFixProvider`4.MakeMultiLineAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptions,System.Threading.CancellationToken)">
            <summary>
            Checks if we should wrap the conditional expression over multiple lines.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionForAssignmentCodeFixProvider`6.FixOneAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Diagnostic,Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptions,System.Threading.CancellationToken)">
            <summary>
            Returns 'true' if a multi-line conditional was created, and thus should be
            formatted specially.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UseNullPropagation.AbstractUseNullPropagationDiagnosticAnalyzer`11">
            <summary>
            Looks for code snippets similar to <c>x == null ? null : x.Y()</c> and converts it to <c>x?.Y()</c>.  This form is also supported:
            <code>
            if (x != null)
                x.Y();
            </code>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UseNullPropagation.AbstractUseNullPropagationDiagnosticAnalyzer`11.#ctor">
            <summary>
            Looks for code snippets similar to <c>x == null ? null : x.Y()</c> and converts it to <c>x?.Y()</c>.  This form is also supported:
            <code>
            if (x != null)
                x.Y();
            </code>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UseThrowExpression.AbstractUseThrowExpressionDiagnosticAnalyzer">
             <summary>
             Looks for patterns of the form:
             <code>
             if (a == null) {
               throw SomeException();
             }
            
             x = a;
             </code>
            
             and offers to change it to
            
             <code>
             x = a ?? throw SomeException();
             </code>
            
             Note: this analyzer can be updated to run on VB once VB supports 'throw'
             expressions as well.
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValidateFormatString.AbstractValidateFormatStringDiagnosticAnalyzer`1.s_removeEscapedBracketsRegex">
            <summary>
            this regex is used to remove escaped brackets from
            the format string before looking for valid {} pairs
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValidateFormatString.AbstractValidateFormatStringDiagnosticAnalyzer`1.s_extractPlaceholdersRegex">
            <summary>
            this regex is used to extract the text between the
            brackets and save the contents in a MatchCollection
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ValidateFormatString.AbstractValidateFormatStringDiagnosticAnalyzer`1.RemoveEscapedBrackets(System.String)">
            <summary>
            removing escaped left brackets and replacing with space characters so they won't
            impede the extraction of placeholders, yet the locations of the placeholders are
            the same as in the original string.
            </summary>
            <param name="formatString"></param>
            <returns>string with left brackets removed and replaced by spaces</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddParameter.AbstractAddParameterCodeFixProvider`7.TryGetRelevantArgument(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            If the diagnostic is on a argument, the argument is considered to be the argument to fix.
            There are some exceptions to this rule. Returning null indicates that the fixer needs
            to find the relevant argument by itself.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddParameter.AddParameterService.HasCascadingDeclarations(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Checks if there are indications that there might be more than one declarations that need to be fixed.
            The check does not look-up if there are other declarations (this is done later in the CodeAction).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddParameter.AddParameterService.AddParameterAsync``1(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.RefKind,Microsoft.CodeAnalysis.CodeGeneration.ParameterName,System.Nullable{Microsoft.CodeAnalysis.CodeGeneration.Argument{``0}},System.Nullable{System.Int32},System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Adds a parameter to a method.
            </summary>
            <param name="newParameterIndex"><see langword="null"/> to add as the final parameter</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AddParameter.CodeFixData.Method">
            <summary>
            The overload to fix.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AddParameter.CodeFixData.CreateChangedSolutionNonCascading">
            <summary>
            A mandatory fix for the overload without cascading.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AddParameter.CodeFixData.CreateChangedSolutionCascading">
            <summary>
            An optional fix for the overload with cascading.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ConflictMarkerResolution.AbstractResolveConflictMarkerCodeFixProvider">
             <summary>
             This code fixer helps remove version conflict markers in code by offering the choice
             of which version to keep and which version to discard.
            
             Conflict markers come in two flavors, diff3 and diff formats.
            
             diff3 has a start marker, followed by a first middle markers and a second middle marker, and terminate with an end marker.
               The disabled text between the first and second middle markers is the baseline for the three-way diff.
               The fixer always discards this baseline text.
            
             diff has a start marker, followed by a middle marker, and terminates with an end marker.
               We treat the middle marker as both the first and second middle markers (degenerate case with no baseline).
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ConflictMarkerResolution.AbstractResolveConflictMarkerCodeFixProvider.ComputeRequestPriority">
            <summary>
            'Fix merge conflict markers' gets special privileges.  A core user scenario around them is that a user does
            a source control merge, gets conflicts, and then wants to open and edit them in the IDE very quickly.
            Forcing their fixes to be gated behind the set of normal fixes (which also involves semantic analysis) just
            slows the user down.  As we can compute this syntactically, and the user is almost certainly trying to fix
            them if they bring up the lightbulb on a <c>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</c> line, it should run ahead of
            normal fix providers else so the user can quickly fix the conflict and move onto the next conflict.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.AbstractGenerateDeconstructMethodService`4.State.GenerateDeconstructMethodStateAsync(`0,Microsoft.CodeAnalysis.SemanticDocument,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Make a State instance representing the Deconstruct method we want to generate.
            The method will be called "Deconstruct". It will be a member of `typeToGenerateIn`.
            Its arguments will be based on `targetVariables`.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ImplementType.ImplementTypeOptionsStorage.EditorConfigOptions">
            <summary>
            Options that we expect the user to set in editorconfig.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DeclarationInfo">
            <summary>
            Struct containing information about a source declaration.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DeclarationInfo.DeclaredNode">
            <summary>
            Topmost syntax node for this declaration.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DeclarationInfo.ExecutableCodeBlocks">
            <summary>
            Syntax nodes for executable code blocks (method body, initializers, etc.) associated with this declaration.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DeclarationInfo.DeclaredSymbol">
            <summary>
            Symbol declared by this declaration.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._0_directive">
            <summary>#{0} directive</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_project_reference_to_0">
            <summary>Add project reference to '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_reference_to_0">
            <summary>Add reference to '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Actions_can_not_be_empty">
            <summary>Actions can not be empty.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.generic_overload">
            <summary>generic overload</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.generic_overloads">
            <summary>generic overloads</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.overload">
            <summary>overload</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.overloads_">
            <summary>overloads</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.type">
            <summary>type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.property_accessor">
            <summary>property accessor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._0_Keyword">
            <summary>{0} Keyword</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Encapsulate_field_colon_0_and_use_property">
            <summary>Encapsulate field: '{0}' (and use property)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Encapsulate_field_colon_0_but_still_use_field">
            <summary>Encapsulate field: '{0}' (but still use field)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Encapsulate_fields_and_use_property">
            <summary>Encapsulate fields (and use property)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Encapsulate_fields_but_still_use_field">
            <summary>Encapsulate fields (but still use field)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Could_not_extract_interface_colon_The_selection_is_not_inside_a_class_interface_struct">
            <summary>Could not extract interface: The selection is not inside a class/interface/struct.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Could_not_extract_interface_colon_The_type_does_not_contain_any_member_that_can_be_extracted_to_an_interface">
            <summary>Could not extract interface: The type does not contain any member that can be extracted to an interface.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Parameters_type_or_return_type_cannot_be_an_anonymous_type_colon_bracket_0_bracket">
            <summary>Parameters' type or return type cannot be an anonymous type : [{0}]</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.The_selection_contains_no_active_statement">
            <summary>The selection contains no active statement.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.The_selection_contains_a_local_function_call_without_its_declaration">
            <summary>The selection contains a local function call without its declaration.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.The_selection_contains_an_error_or_unknown_type">
            <summary>The selection contains an error or unknown type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Type_parameter_0_is_hidden_by_another_type_parameter_1">
            <summary>Type parameter '{0}' is hidden by another type parameter '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.The_address_of_a_variable_is_used_inside_the_selected_code">
            <summary>The address of a variable is used inside the selected code.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Assigning_to_readonly_fields_must_be_done_in_a_constructor_colon_bracket_0_bracket">
            <summary>Assigning to readonly fields must be done in a constructor : [{0}].</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.generated_code_is_overlapping_with_hidden_portion_of_the_code">
            <summary>generated code is overlapping with hidden portion of the code</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_optional_parameters_to_0">
            <summary>Add optional parameters to '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_parameters_to_0">
            <summary>Add parameters to '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_delegating_constructor_0_1">
            <summary>Generate delegating constructor '{0}({1})'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_Equals_and_GetHashCode">
            <summary>Generate Equals and GetHashCode</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_Equals_object">
            <summary>Generate Equals(object)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_GetHashCode">
            <summary>Generate GetHashCode()</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_0_1_in_new_file">
            <summary>Generate {0} '{1}' in new file</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_nested_0_1">
            <summary>Generate nested {0} '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Introduce_field_for_0">
            <summary>Introduce field for '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Introduce_local_for_0">
            <summary>Introduce local for '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Introduce_constant_for_0">
            <summary>Introduce constant for '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Introduce_local_constant_for_0">
            <summary>Introduce local constant for '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Introduce_field_for_all_occurrences_of_0">
            <summary>Introduce field for all occurrences of '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Introduce_local_for_all_occurrences_of_0">
            <summary>Introduce local for all occurrences of '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Introduce_constant_for_all_occurrences_of_0">
            <summary>Introduce constant for all occurrences of '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Introduce_local_constant_for_all_occurrences_of_0">
            <summary>Introduce local constant for all occurrences of '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Introduce_query_variable_for_all_occurrences_of_0">
            <summary>Introduce query variable for all occurrences of '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Introduce_query_variable_for_0">
            <summary>Introduce query variable for '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Types_colon">
            <summary>Types:</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.is_">
            <summary>is</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Represents_an_object_whose_operations_will_be_resolved_at_runtime">
            <summary>Represents an object whose operations will be resolved at runtime.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.constant">
            <summary>constant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.field">
            <summary>field</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.local_constant">
            <summary>local constant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.local_variable">
            <summary>local variable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.label">
            <summary>label</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.range_variable">
            <summary>range variable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.parameter">
            <summary>parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.discard">
            <summary>discard</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.in_">
            <summary>in</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Summary_colon">
            <summary>Summary:</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Locals_and_parameters">
            <summary>Locals and parameters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Type_parameters_colon">
            <summary>Type parameters:</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Returns_colon">
            <summary>Returns:</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Remarks_colon">
            <summary>Remarks:</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.generating_source_for_symbols_of_this_type_is_not_supported">
            <summary>generating source for symbols of this type is not supported</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Assembly">
            <summary>Assembly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.location_unknown">
            <summary>location unknown</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Extract_interface">
            <summary>Extract interface...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_0_requires_restarting_the_application">
            <summary>Updating '{0}' requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Changing_0_to_1_requires_restarting_the_application_because_it_changes_the_shape_of_the_state_machine">
            <summary>Changing '{0}' to '{1}' requires restarting the application because it changes the shape of the state machine.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_a_complex_statement_containing_an_await_expression_requires_restarting_the_application">
            <summary>Updating a complex statement containing an await expression requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Changing_visibility_of_0_requires_restarting_the_application">
            <summary>Changing visibility of {0} requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Ceasing_to_capture_primary_constructor_parameter_0_of_1_requires_restarting_the_application">
            <summary>Ceasing to capture primary constructor parameter '{0}' of '{1}' requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Changing_attribute_0_requires_restarting_the_application">
            <summary>Changing attribute '{0}' requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Changing_name_or_signature_of_0_that_contains_an_active_statement_requires_restarting_the_application">
            <summary>Changing attribute '{0}' requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Changing_0_might_not_have_any_effect_until_the_application_is_restarted">
            <summary>Changing '{0}' might not have any effect until the application is restarted.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Capturing_primary_constructor_parameter_0_that_hasn_t_been_captured_before_requires_restarting_the_application">
            <summary>Capturing primary constructor parameter '{0}' that hasn't been capture before requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Changing_the_type_of_a_captured_variable_0_previously_of_type_1_requires_restarting_the_application">
            <summary>Changing the type of a captured variable '{0}' previously of type '{1}' requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Changing_the_parameters_of_0_requires_restarting_the_application">
            <summary>Changing the parameters of {0} requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Changing_the_return_type_of_0_requires_restarting_the_application">
            <summary>Changing the return type of {0} requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Changing_the_signature_of_0_requires_restarting_the_application">
            <summary>Changing the signature of {0} requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Changing_the_signature_of_0_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime">
            <summary>Changing the signature of {0} requires restarting the application because is not supported by the runtime.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Changing_the_declaration_scope_of_a_captured_variable_0_requires_restarting_the_application">
            <summary>Changing the declaration scope of a captured variable '{0}' requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_or_moving_0_of_1_requires_restarting_the_application">
            <summary>Adding or moving {0} of {1} requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_0_into_an_interface_requires_restarting_the_application">
            <summary>Adding {0} into an interface requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_0_into_an_interface_method_requires_restarting_the_application">
            <summary>Adding {0} into an interface method requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_or_moving_0_of_1_with_explicit_or_sequential_layout_requires_restarting_the_application">
            <summary>Adding or moving {0} of {1} with explicit or sequential layout requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_or_moving_0_of_a_COM_interface_requires_restarting_the_application">
            <summary>Adding or moving {0} of a COM interface requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Changing_project_setting_0_from_1_to_2_requires_restarting_the_application">
            <summary>Changing project setting '{0}' from '{1}' to '{2}' requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Changing_project_or_package_reference_caused_the_identity_of_referenced_assembly_to_change_from_0_to_1_which_requires_restarting_the_application">
            <summary>Changing project or package reference caused the identity of referenced assembly to change from '{0}' to '{1}', which requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Project_references_mutliple_assemblies_of_the_same_simple_name_0_1_Changing_a_reference_to_such_an_assembly_requires_restarting_the_application">
            <summary>Project references mutliple assemblies of the same simple name '{0}': {1}. Changing a reference to such an assembly requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.default">
            <summary>default&gt;</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_the_modifiers_of_0_requires_restarting_the_application">
            <summary>Updating the modifiers of {0} requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_the_Handles_clause_of_0_requires_restarting_the_application">
            <summary>Updating the Handles clause of {0} requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_0_with_the_Handles_clause_requires_restarting_the_application">
            <summary>Adding {0} with the Handles clause requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_the_Implements_clause_of_a_0_requires_restarting_the_application">
            <summary>Updating the Implements clause of a {0} requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_the_variance_of_0_requires_restarting_the_application">
            <summary>Updating the variance of {0} requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_the_type_of_0_requires_restarting_the_application">
            <summary>Updating the type of {0} requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_the_initializer_of_0_requires_restarting_the_application">
            <summary>Updating the initializer of {0} requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_the_size_of_a_0_requires_restarting_the_application">
            <summary>Updating the size of a {0} requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_the_underlying_type_of_0_requires_restarting_the_application">
            <summary>Updating the underlying type of {0} requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_the_base_class_and_or_base_interface_s_of_0_requires_restarting_the_application">
            <summary>Updating the base class and/or base interface(s) of {0} requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Changing_a_field_to_an_event_or_vice_versa_requires_restarting_the_application">
            <summary>Changing a field to an event or vice versa requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_the_kind_of_a_type_requires_restarting_the_application">
            <summary>Updating the kind of a type requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_the_kind_of_a_property_event_accessor_requires_restarting_the_application">
            <summary>Updating the kind of a property/event accessor requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_the_library_name_of_Declare_statement_requires_restarting_the_application">
            <summary>Updating the library name of Declare statement requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_the_alias_of_Declare_statement_requires_restarting_the_application">
            <summary>Updating the alias of Declare statement requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Renaming_0_requires_restarting_the_application">
            <summary>Renaming {0} requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_0_requires_restarting_the_application">
            <summary>Adding {0} requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_an_abstract_0_or_overriding_an_inherited_0_requires_restarting_the_application">
            <summary>Adding an abstract {0} or overriding an inherited {0} requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_a_MustOverride_0_or_overriding_an_inherited_0_requires_restarting_the_application">
            <summary>Adding a MustOverride {0} or overriding an inherited {0} requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_an_extern_0_requires_restarting_the_application">
            <summary>Adding an extern {0} requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_an_imported_method_requires_restarting_the_application">
            <summary>Adding an imported method requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_a_user_defined_0_requires_restarting_the_application">
            <summary>Adding a user defined {0} requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_0_around_an_active_statement_requires_restarting_the_application">
            <summary>Adding {0} around an active statement requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Moving_0_requires_restarting_the_application">
            <summary>Moving {0} requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Deleting_0_requires_restarting_the_application">
            <summary>Deleting {0} requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Deleting_0_around_an_active_statement_requires_restarting_the_application">
            <summary>Deleting {0} around an active statement requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_a_0_around_an_active_statement_requires_restarting_the_application">
            <summary>Updating a {0} around an active statement requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_async_or_iterator_modifier_around_an_active_statement_requires_restarting_the_application">
            <summary>Updating async or iterator modifier around an active statement requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Changing_0_from_asynchronous_to_synchronous_requires_restarting_the_application">
            <summary>Changing {0} from asynchronous to synchronous requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Modifying_a_generic_method_requires_restarting_the_application">
            <summary>Modifying a generic method requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Modifying_a_method_inside_the_context_of_a_generic_type_requires_restarting_the_application">
            <summary>Modifying a method inside the context of a generic type requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_a_constructor_to_a_type_with_a_field_or_property_initializer_that_contains_an_anonymous_function_requires_restarting_the_application">
            <summary>Adding a constructor to a type with a field or property initializer that contains an anonymous function requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Renaming_a_captured_variable_from_0_to_1_requires_restarting_the_application">
            <summary>Renaming a captured variable, from '{0}' to '{1}' requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Modifying_a_catch_finally_handler_with_an_active_statement_in_the_try_block_requires_restarting_the_application">
            <summary>Modifying a catch/finally handler with an active statement in the try block requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Modifying_a_try_catch_finally_statement_when_the_finally_block_is_active_requires_restarting_the_application">
            <summary>Modifying a try/catch/finally statement when the finally block is active requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Modifying_a_catch_handler_around_an_active_statement_requires_restarting_the_application">
            <summary>Modifying a catch handler around an active statement requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Modifying_0_which_contains_the_stackalloc_operator_requires_restarting_the_application">
            <summary>Modifying {0} which contains the stackalloc operator requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Modifying_0_which_contains_an_Aggregate_Group_By_or_Join_query_clauses_requires_restarting_the_application">
            <summary>Modifying {0} which contains an Aggregate, Group By, or Join query clauses requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Modifying_source_with_experimental_language_features_enabled_requires_restarting_the_application">
            <summary>Modifying source with experimental language features enabled requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_an_active_statement_requires_restarting_the_application">
            <summary>Updating an active statement requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Removing_0_that_contains_an_active_statement_requires_restarting_the_application">
            <summary>Removing {0} that contains an active statement requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_a_new_file_requires_restarting_the_application">
            <summary>Adding a new file requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Attribute_0_is_missing_Updating_an_async_method_or_an_iterator_requires_restarting_the_application">
            <summary>Attribute '{0}' is missing. Updating an async method or an iterator requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unexpected_interface_member_kind_colon_0">
            <summary>Unexpected interface member kind: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.The_symbol_does_not_have_an_icon">
            <summary>The symbol does not have an icon.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Extract_local_function">
            <summary>Extract local function</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Extract_method">
            <summary>Extract method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Asynchronous_method_cannot_have_ref_out_parameters_colon_bracket_0_bracket">
            <summary>Asynchronous method cannot have ref/out parameters : [{0}]</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.The_member_is_defined_in_metadata">
            <summary>The member is defined in metadata.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.You_can_only_change_the_signature_of_a_constructor_indexer_method_or_delegate">
            <summary>You can only change the signature of a constructor, indexer, method or delegate.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.This_symbol_has_related_definitions_or_references_in_metadata_Changing_its_signature_may_result_in_build_errors_Do_you_want_to_continue">
            <summary>This symbol has related definitions or references in metadata. Changing its signature may result in build errors.
            
            Do you want to continue?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Change_signature">
            <summary>Change signature...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_new_type">
            <summary>Generate new type...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.User_Diagnostic_Analyzer_Failure">
            <summary>User Diagnostic Analyzer Failure.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Analyzer_0_threw_an_exception_of_type_1_with_message_2">
            <summary>Analyzer '{0}' threw an exception of type '{1}' with message '{2}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Analyzer_0_threw_the_following_exception_colon_1">
            <summary>Analyzer '{0}' threw the following exception:
            '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Remove_qualification">
            <summary>Remove qualification</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unknown_error_occurred">
            <summary>Unknown error occurred</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.No_valid_location_to_insert_method_call">
            <summary>No valid location to insert method call.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Available">
            <summary>Available</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Not_Available">
            <summary>Not Available </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._0_1">
            <summary>{0} - {1}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.You_can_use_the_navigation_bar_to_switch_contexts">
            <summary>You can use the navigation bar to switch contexts.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.in_Source">
            <summary>in Source</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.in_Suppression_File">
            <summary>in Suppression File</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Remove_Suppression_0">
            <summary>Remove Suppression {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Remove_Suppression">
            <summary>Remove Suppression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Configure_0_severity">
            <summary>Configure {0} severity</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Configure_0_code_style">
            <summary>Configure {0} code style</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Configure_severity_for_all_0_analyzers">
            <summary>Configure severity for all '{0}' analyzers</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Configure_severity_for_all_analyzers">
            <summary>Configure severity for all analyzers</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Pending">
            <summary>&lt;Pending&gt;</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Awaited_task_returns_0">
            <summary>Awaited task returns {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Awaited_task_returns_no_value">
            <summary>Awaited task returns no value</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Note_colon_Tab_twice_to_insert_the_0_snippet">
            <summary>Note: Tab twice to insert the '{0}' snippet.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Suppress_0">
            <summary>Suppress {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Computing_fix_all_occurrences_code_fix">
            <summary>Computing fix all occurrences code fix...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Fix_all_occurrences">
            <summary>Fix all occurrences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Document">
            <summary>Document</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Project">
            <summary>Project</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Solution">
            <summary>Solution</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Containing_Member">
            <summary>Containing Member</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Containing_Type">
            <summary>Containing Type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Modifying_0_which_contains_a_static_variable_requires_restarting_the_application">
            <summary>Modifying {0} which contains a static variable requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Compiler2">
            <summary>Compiler</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.EditAndContinue">
            <summary>Edit and Continue</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Live">
            <summary>Live</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.namespace_">
            <summary>namespace</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.class_">
            <summary>class</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.interface_">
            <summary>interface</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.enum_">
            <summary>enum</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.enum_value">
            <summary>enum value</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.delegate_">
            <summary>delegate</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.const_field">
            <summary>const field</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.method">
            <summary>method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.operator_">
            <summary>operator</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.constructor">
            <summary>constructor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.static_constructor">
            <summary>static constructor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.auto_property">
            <summary>auto-property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.property_">
            <summary>property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.event_">
            <summary>event</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.event_accessor">
            <summary>event accessor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.type_constraint">
            <summary>type constraint</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.type_parameter">
            <summary>type parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.attribute">
            <summary>attribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Replace_0_and_1_with_property">
            <summary>Replace '{0}' and '{1}' with property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Replace_0_with_property">
            <summary>Replace '{0}' with property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Method_referenced_implicitly">
            <summary>Method referenced implicitly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_type_0">
            <summary>Generate type '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_0_1">
            <summary>Generate {0} '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Change_0_to_1">
            <summary>Change '{0}' to '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Non_invoked_method_cannot_be_replaced_with_property">
            <summary>Non-invoked method cannot be replaced with property.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Only_methods_with_a_single_argument_which_is_not_an_out_variable_declaration_can_be_replaced_with_a_property">
            <summary>Only methods with a single argument, which is not an out variable declaration, can be replaced with a property.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Roslyn_HostError">
            <summary>Roslyn.HostError</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.An_instance_of_analyzer_0_cannot_be_created_from_1_colon_2">
            <summary>An instance of analyzer {0} cannot be created from {1}: {2}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.The_assembly_0_does_not_contain_any_analyzers">
            <summary>The assembly {0} does not contain any analyzers.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unable_to_load_Analyzer_assembly_0_colon_1">
            <summary>Unable to load Analyzer assembly {0}: {1}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.from_0">
            <summary>from {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Find_and_install_latest_version">
            <summary>Find and install latest version</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Use_local_version_0">
            <summary>Use local version '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Use_locally_installed_0_version_1_This_version_used_in_colon_2">
            <summary>Use locally installed '{0}' version '{1}'
            This version used in: {2}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Find_and_install_latest_version_of_0">
            <summary>Find and install latest version of '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Install_with_package_manager">
            <summary>Install with package manager...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Install_0_1">
            <summary>Install '{0} {1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Install_version_0">
            <summary>Install version '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Classes">
            <summary>Classes</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Constants">
            <summary>Constants</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Delegates">
            <summary>Delegates</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Enums">
            <summary>Enums</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Events">
            <summary>Events</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Extension_methods">
            <summary>Extension methods</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Fields">
            <summary>Fields</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Interfaces">
            <summary>Interfaces</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Methods">
            <summary>Methods</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Modules">
            <summary>Modules</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Namespaces">
            <summary>Namespaces</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Properties">
            <summary>Properties</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Structures">
            <summary>Structures</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Variadic_SignatureHelpItem_must_have_at_least_one_parameter">
            <summary>Variadic SignatureHelpItem must have at least one parameter.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Replace_0_with_method">
            <summary>Replace '{0}' with method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Replace_0_with_methods">
            <summary>Replace '{0}' with methods</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Property_referenced_implicitly">
            <summary>Property referenced implicitly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Property_cannot_safely_be_replaced_with_a_method_call">
            <summary>Property cannot safely be replaced with a method call</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Convert_to_interpolated_string">
            <summary>Convert to interpolated string</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Move_type_to_0">
            <summary>Move type to {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Rename_file_to_0">
            <summary>Rename file to {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Rename_type_to_0">
            <summary>Rename type to {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Asynchronously_waits_for_the_task_to_finish">
            <summary>Asynchronously waits for the task to finish.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Await_the_preceding_expression">
            <summary>Await the preceding expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Await_the_preceding_expression_and_add_ConfigureAwait_0">
            <summary>Await the preceding expression and add ConfigureAwait({0}).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.paren_Unknown_paren">
            <summary>(Unknown)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Use_framework_type">
            <summary>Use framework type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Install_package_0">
            <summary>Install package '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.project_0">
            <summary>project {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Fix_typo_0">
            <summary>Fix typo '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Fully_qualify_0">
            <summary>Fully qualify '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Remove_reference_to_0">
            <summary>Remove reference to '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Keywords">
            <summary>Keywords</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Snippets">
            <summary>Snippets</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Remove_document_0">
            <summary>Remove document '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_document_0">
            <summary>Add document '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_argument_name_0">
            <summary>Add argument name '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_tuple_element_name_0">
            <summary>Add tuple element name '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Remove_unused_variable">
            <summary>Remove unused variable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Convert_to_binary">
            <summary>Convert to binary</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Convert_to_decimal">
            <summary>Convert to decimal</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Convert_to_hex">
            <summary>Convert to hex</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Separate_thousands">
            <summary>Separate thousands</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Separate_words">
            <summary>Separate words</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Separate_nibbles">
            <summary>Separate nibbles</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Remove_separators">
            <summary>Remove separators</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_constructor_from_members">
            <summary>Generate constructor from members...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Pick_members_to_be_used_as_constructor_parameters">
            <summary>Pick members to be used as constructor parameters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Pick_members_to_be_used_in_Equals_GetHashCode">
            <summary>Pick members to be used in Equals/GetHashCode</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_overrides">
            <summary>Generate overrides...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Pick_members_to_override">
            <summary>Pick members to override</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_null_check">
            <summary>Add null check</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Create_and_assign_field_0">
            <summary>Create and assign field '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Create_and_assign_property_0">
            <summary>Create and assign property '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Initialize_field_0">
            <summary>Initialize field '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Initialize_property_0">
            <summary>Initialize property '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_null_checks">
            <summary>Add _null checks</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_operators">
            <summary>Generate operators</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Implement_0">
            <summary>Implement {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Reported_diagnostic_0_has_a_source_location_in_file_1_which_is_not_part_of_the_compilation_being_analyzed">
            <summary>Reported diagnostic '{0}' has a source location in file '{1}', which is not part of the compilation being analyzed.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Reported_diagnostic_0_has_a_source_location_1_in_file_2_which_is_outside_of_the_given_file">
            <summary>Reported diagnostic '{0}' has a source location '{1}' in file '{2}', which is outside of the given file.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.in_0_project_1">
            <summary>in {0} (project {1})</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Move_declaration_near_reference">
            <summary>Move declaration near reference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Move_declaration_near_reference_may_change_semantics">
            <summary>Move declaration near reference (may change semantics)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Convert_to_full_property">
            <summary>Convert to full property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Warning_Method_overrides_symbol_from_metadata">
            <summary>Warning: Method overrides symbol from metadata</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Use_0">
            <summary>Use {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Switching_between_lambda_and_local_function_requires_restarting_the_application">
            <summary>Switching between a lambda and a local function requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_argument_name_0_including_trailing_arguments">
            <summary>Add argument name '{0}' (including trailing arguments)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.local_function">
            <summary>local function</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.indexer_">
            <summary>indexer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Warning_colon_Collection_was_modified_during_iteration">
            <summary>Warning: Collection was modified during iteration.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Warning_colon_Iteration_variable_crossed_function_boundary">
            <summary>Warning: Iteration variable crossed function boundary.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Convert_to_linq">
            <summary>Convert to LINQ</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Convert_to_class">
            <summary>Convert to class</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Convert_to_struct">
            <summary>Convert to struct</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.updating_usages_in_containing_member">
            <summary>updating usages in containing member</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.updating_usages_in_containing_project">
            <summary>updating usages in containing project</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.updating_usages_in_containing_type">
            <summary>updating usages in containing type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.updating_usages_in_dependent_projects">
            <summary>updating usages in dependent projects</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Formatting_document">
            <summary>Formatting document</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Convert_to_linq_call_form">
            <summary>Convert to LINQ (call form)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Adding_a_method_with_an_explicit_interface_specifier_requires_restarting_the_application">
            <summary>Adding a method with an explicit interface specifier requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Modifying_source_file_0_requires_restarting_the_application_due_to_internal_error_1">
            <summary>Modifying source file '{0}' requires restarting the application due to internal error: {1}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Modifying_source_file_0_requires_restarting_the_application_because_the_file_is_too_big">
            <summary>Modifying source file '{0}' requires restarting the application because the file is too big.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Modifying_body_of_0_requires_restarting_the_application_due_to_internal_error_1">
            <summary>Modifying the body of {0} requires restarting the application due to internal error: {1}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Modifying_body_of_0_requires_restarting_the_application_because_the_body_has_too_many_statements">
            <summary>Modifying the body of {0} requires restarting the application because the body has too many statements.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Change_namespace_to_0">
            <summary>Change namespace to '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Move_file_to_0">
            <summary>Move file to '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Move_file_to_project_root_folder">
            <summary>Move file to project root folder</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Move_to_namespace">
            <summary>Move to namespace...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Change_to_global_namespace">
            <summary>Change to global namespace</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Warning_colon_changing_namespace_may_produce_invalid_code_and_change_code_meaning">
            <summary>Warning: Changing namespace may produce invalid code and change code meaning.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Invert_conditional">
            <summary>Invert conditional</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Replace_0_with_1">
            <summary>Replace '{0}' with '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Align_wrapped_parameters">
            <summary>Align wrapped parameters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Indent_all_parameters">
            <summary>Indent all parameters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Indent_wrapped_parameters">
            <summary>Indent wrapped parameters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unwrap_all_parameters">
            <summary>Unwrap all parameters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unwrap_and_indent_all_parameters">
            <summary>Unwrap and indent all parameters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Wrap_every_parameter">
            <summary>Wrap every parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Wrap_long_parameter_list">
            <summary>Wrap long parameter list</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unwrap_parameter_list">
            <summary>Unwrap parameter list</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Align_wrapped_arguments">
            <summary>Align wrapped arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Indent_all_arguments">
            <summary>Indent all arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Indent_wrapped_arguments">
            <summary>Indent wrapped arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unwrap_all_arguments">
            <summary>Unwrap all arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unwrap_and_indent_all_arguments">
            <summary>Unwrap and indent all arguments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Wrap_every_argument">
            <summary>Wrap every argument</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Wrap_long_argument_list">
            <summary>Wrap long argument list</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unwrap_argument_list">
            <summary>Unwrap argument list</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Introduce_constant">
            <summary>Introduce constant</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Introduce_field">
            <summary>Introduce field</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Introduce_local">
            <summary>Introduce local</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Introduce_query_variable">
            <summary>Introduce query variable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Failed_to_analyze_data_flow_for_0">
            <summary>Failed to analyze data-flow for: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Split_into_nested_0_statements">
            <summary>Split into nested '{0}' statements</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Merge_with_outer_0_statement">
            <summary>Merge with outer '{0}' statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Split_into_consecutive_0_statements">
            <summary>Split into consecutive '{0}' statements</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Merge_with_previous_0_statement">
            <summary>Merge with previous '{0}' statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unwrap_expression">
            <summary>Unwrap expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Wrap_expression">
            <summary>Wrap expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Wrapping">
            <summary>Wrapping</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Merge_with_nested_0_statement">
            <summary>Merge with nested '{0}' statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Merge_with_next_0_statement">
            <summary>Merge with next '{0}' statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Pull_0_up_to">
            <summary>Pull '{0}' up to ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Pull_members_up_to_base_type">
            <summary>Pull members up to base type...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unwrap_call_chain">
            <summary>Unwrap call chain</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Wrap_call_chain">
            <summary>Wrap call chain</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Wrap_long_call_chain">
            <summary>Wrap long call chain</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Wrap_and_align_expression">
            <summary>Wrap and align expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Move_contents_to_namespace">
            <summary>Move contents to namespace...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_optional_parameter_to_constructor">
            <summary>Add optional parameter to constructor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_parameter_to_constructor">
            <summary>Add parameter to constructor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Target_type_matches">
            <summary>Target type matches</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.in_Source_attribute">
            <summary>in Source (attribute)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.MethodMustReturnStreamThatSupportsReadAndSeek">
            <summary>{0} must return a stream that supports read and seek operations.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.RudeEdit">
            <summary>Rude edit</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.CannotApplyChangesUnexpectedError">
            <summary>Cannot apply changes -- unexpected error: '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.ErrorReadingFile">
            <summary>Error while reading file '{0}': {1}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.EditAndContinueDisallowedByProject">
            <summary>Changes made in project '{0}' require restarting the application: {1}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.DocumentIsOutOfSyncWithDebuggee">
            <summary>The current content of source file '{0}' does not match the built source. Any changes made to this file while debugging won't be applied until its content matches the built source.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.UnableToReadSourceFileOrPdb">
            <summary>Unable to read source file '{0}' or the PDB built for the containing project. Any changes made to this file while debugging won't be applied until its content matches the built source.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.ChangesDisallowedWhileStoppedAtException">
            <summary>Changes are not allowed while stopped at exception</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Wrap_and_align_call_chain">
            <summary>Wrap and align call chain</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Wrap_and_align_long_call_chain">
            <summary>Wrap and align long call chain</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Warning_colon_semantics_may_change_when_converting_statement">
            <summary>Warning: Semantics may change when converting statement.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_null_checks_for_all_parameters">
            <summary>Add null checks for all parameters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Implement_0_implicitly">
            <summary>Implement '{0}' implicitly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Implement_all_interfaces_implicitly">
            <summary>Implement all interfaces implicitly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Implement_implicitly">
            <summary>Implement implicitly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Implement_0_explicitly">
            <summary>Implement '{0}' explicitly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.ChangeSignature_NewParameterIntroduceTODOVariable">
            <summary>TODO</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.ChangeSignature_NewParameterOmitValue">
            <summary>&lt;omit&gt;</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Value_colon">
            <summary>Value:</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Parameters_colon">
            <summary>Parameters:</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Implement_all_interfaces_explicitly">
            <summary>Implement all interfaces explicitly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Implement_explicitly">
            <summary>Implement explicitly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_DebuggerDisplay_attribute">
            <summary>Add 'DebuggerDisplay' attribute</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.AM_PM_abbreviated">
            <summary>AM/PM (abbreviated)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.AM_PM_abbreviated_description">
            <summary>The "t" custom format specifier represents the first character of the AM/PM designator. The appropriate localized designator is retrieved from the DateTimeFormatInfo.AMDesignator or DateTimeFormatInfo.PMDesignator property of the current or specific cultur ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.AM_PM_full">
            <summary>AM/PM (full)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.AM_PM_full_description">
            <summary>The "tt" custom format specifier (plus any number of additional "t" specifiers) represents the entire AM/PM designator. The appropriate localized designator is retrieved from the DateTimeFormatInfo.AMDesignator or DateTimeFormatInfo.PMDesignator property o ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.date_separator">
            <summary>date separator</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.date_separator_description">
            <summary>The "/" custom format specifier represents the date separator, which is used to differentiate years, months, and days. The appropriate localized date separator is retrieved from the DateTimeFormatInfo.DateSeparator property of the current or specified cult ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.day_of_the_month_1_2_digits">
            <summary>day of the month (1-2 digits)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.day_of_the_month_1_2_digits_description">
            <summary>The "d" custom format specifier represents the day of the month as a number from 1 through 31. A single-digit day is formatted without a leading zero.
            
            If the "d" format specifier is used without other custom format specifiers, it's interpreted as the "d"  ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.day_of_the_month_2_digits">
            <summary>day of the month (2 digits)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.day_of_the_month_2_digits_description">
            <summary>The "dd" custom format string represents the day of the month as a number from 01 through 31. A single-digit day is formatted with a leading zero.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.day_of_the_week_abbreviated">
            <summary>day of the week (abbreviated)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.day_of_the_week_abbreviated_description">
            <summary>The "ddd" custom format specifier represents the abbreviated name of the day of the week. The localized abbreviated name of the day of the week is retrieved from the DateTimeFormatInfo.AbbreviatedDayNames property of the current or specified culture.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.day_of_the_week_full">
            <summary>day of the week (full)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.day_of_the_week_full_description">
            <summary>The "dddd" custom format specifier (plus any number of additional "d" specifiers) represents the full name of the day of the week. The localized name of the day of the week is retrieved from the DateTimeFormatInfo.DayNames property of the current or specif ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.full_long_date_time">
            <summary>full long date/time</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.full_long_date_time_description">
            <summary>The "F" standard format specifier represents a custom date and time format string that is defined by the current DateTimeFormatInfo.FullDateTimePattern property. For example, the custom format string for the invariant culture is "dddd, dd MMMM yyyy HH:mm:s ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.full_short_date_time">
            <summary>full short date/time</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.full_short_date_time_description">
            <summary>The Full Date Short Time ("f") Format Specifier
            
            The "f" standard format specifier represents a combination of the long date ("D") and short time ("t") patterns, separated by a space.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.general_long_date_time">
            <summary>general long date/time</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.general_long_date_time_description">
            <summary>The "G" standard format specifier represents a combination of the short date ("d") and long time ("T") patterns, separated by a space.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.general_short_date_time">
            <summary>general short date/time</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.general_short_date_time_description">
            <summary>The "g" standard format specifier represents a combination of the short date ("d") and short time ("t") patterns, separated by a space.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.long_date">
            <summary>long date</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.long_date_description">
            <summary>The "D" standard format specifier represents a custom date and time format string that is defined by the current DateTimeFormatInfo.LongDatePattern property. For example, the custom format string for the invariant culture is "dddd, dd MMMM yyyy".</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.long_time">
            <summary>long time</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.long_time_description">
            <summary>The "T" standard format specifier represents a custom date and time format string that is defined by a specific culture's DateTimeFormatInfo.LongTimePattern property. For example, the custom format string for the invariant culture is "HH:mm:ss".</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.minute_1_2_digits">
            <summary>minute (1-2 digits)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.minute_1_2_digits_description">
            <summary>The "m" custom format specifier represents the minute as a number from 0 through 59. The minute represents whole minutes that have passed since the last hour. A single-digit minute is formatted without a leading zero.
            
            If the "m" format specifier is used w ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.minute_2_digits">
            <summary>minute (2 digits)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.minute_2_digits_description">
            <summary>The "mm" custom format specifier (plus any number of additional "m" specifiers) represents the minute as a number from 00 through 59. The minute represents whole minutes that have passed since the last hour. A single-digit minute is formatted with a leadin ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.month_1_2_digits">
            <summary>month (1-2 digits)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.month_1_2_digits_description">
            <summary>The "M" custom format specifier represents the month as a number from 1 through 12 (or from 1 through 13 for calendars that have 13 months). A single-digit month is formatted without a leading zero.
            
            If the "M" format specifier is used without other custom ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.month_2_digits">
            <summary>month (2 digits)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.month_2_digits_description">
            <summary>The "MM" custom format specifier represents the month as a number from 01 through 12 (or from 1 through 13 for calendars that have 13 months). A single-digit month is formatted with a leading zero.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.month_abbreviated">
            <summary>month (abbreviated)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.month_abbreviated_description">
            <summary>The "MMM" custom format specifier represents the abbreviated name of the month. The localized abbreviated name of the month is retrieved from the DateTimeFormatInfo.AbbreviatedMonthNames property of the current or specified culture.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.month_day">
            <summary>month day</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.month_day_description">
            <summary>The "M" or "m" standard format specifier represents a custom date and time format string that is defined by the current DateTimeFormatInfo.MonthDayPattern property. For example, the custom format string for the invariant culture is "MMMM dd".</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.month_full">
            <summary>month (full)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.month_full_description">
            <summary>The "MMMM" custom format specifier represents the full name of the month. The localized name of the month is retrieved from the DateTimeFormatInfo.MonthNames property of the current or specified culture.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.period_era">
            <summary>period/era</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.period_era_description">
            <summary>The "g" or "gg" custom format specifiers (plus any number of additional "g" specifiers) represents the period or era, such as A.D. The formatting operation ignores this specifier if the date to be formatted doesn't have an associated period or era string.
             ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.rfc1123_date_time">
            <summary>rfc1123 date/time</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.rfc1123_date_time_description">
            <summary>The "R" or "r" standard format specifier represents a custom date and time format string that is defined by the DateTimeFormatInfo.RFC1123Pattern property. The pattern reflects a defined standard, and the property is read-only. Therefore, it is always the  ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.round_trip_date_time">
            <summary>round-trip date/time</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.round_trip_date_time_description">
            <summary>The "O" or "o" standard format specifier represents a custom date and time format string using a pattern that preserves time zone information and emits a result string that complies with ISO 8601. For DateTime values, this format specifier is designed to p ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.second_1_2_digits">
            <summary>second (1-2 digits)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.second_1_2_digits_description">
            <summary>The "s" custom format specifier represents the seconds as a number from 0 through 59. The result represents whole seconds that have passed since the last minute. A single-digit second is formatted without a leading zero.
            
            If the "s" format specifier is use ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.second_2_digits">
            <summary>second (2 digits)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.second_2_digits_description">
            <summary>The "ss" custom format specifier (plus any number of additional "s" specifiers) represents the seconds as a number from 00 through 59. The result represents whole seconds that have passed since the last minute. A single-digit second is formatted with a lea ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.short_date">
            <summary>short date</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.short_date_description">
            <summary>The "d" standard format specifier represents a custom date and time format string that is defined by a specific culture's DateTimeFormatInfo.ShortDatePattern property. For example, the custom format string that is returned by the ShortDatePattern property  ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.short_time">
            <summary>short time</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.short_time_description">
            <summary>The "t" standard format specifier represents a custom date and time format string that is defined by the current DateTimeFormatInfo.ShortTimePattern property. For example, the custom format string for the invariant culture is "HH:mm".</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.sortable_date_time">
            <summary>sortable date/time</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.sortable_date_time_description">
            <summary>The "s" standard format specifier represents a custom date and time format string that is defined by the DateTimeFormatInfo.SortableDateTimePattern property. The pattern reflects a defined standard (ISO 8601), and the property is read-only. Therefore, it i ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.time_separator">
            <summary>time separator</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.time_separator_description">
            <summary>The ":" custom format specifier represents the time separator, which is used to differentiate hours, minutes, and seconds. The appropriate localized time separator is retrieved from the DateTimeFormatInfo.TimeSeparator property of the current or specified  ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.time_zone">
            <summary>time zone</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.time_zone_description">
            <summary>The "K" custom format specifier represents the time zone information of a date and time value. When this format specifier is used with DateTime values, the result string is defined by the value of the DateTime.Kind property:
            
                For the local time zone (a ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.universal_full_date_time">
            <summary>universal full date/time</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.universal_full_date_time_description">
            <summary>The "U" standard format specifier represents a custom date and time format string that is defined by a specified culture's DateTimeFormatInfo.FullDateTimePattern property. The pattern is the same as the "F" pattern. However, the DateTime value is automatic ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.universal_sortable_date_time">
            <summary>universal sortable date/time</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.universal_sortable_date_time_description">
            <summary>The "u" standard format specifier represents a custom date and time format string that is defined by the DateTimeFormatInfo.UniversalSortableDateTimePattern property. The pattern reflects a defined standard, and the property is read-only. Therefore, it is  ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.utc_hour_and_minute_offset">
            <summary>utc hour and minute offset</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.utc_hour_and_minute_offset_description">
            <summary>With DateTime values, the "zzz" custom format specifier represents the signed offset of the local operating system's time zone from UTC, measured in hours and minutes. It doesn't reflect the value of an instance's DateTime.Kind property. For this reason, t ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.utc_hour_offset_1_2_digits">
            <summary>utc hour offset (1-2 digits)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.utc_hour_offset_1_2_digits_description">
            <summary>With DateTime values, the "z" custom format specifier represents the signed offset of the local operating system's time zone from Coordinated Universal Time (UTC), measured in hours. It doesn't reflect the value of an instance's DateTime.Kind property. For ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.utc_hour_offset_2_digits">
            <summary>utc hour offset (2 digits)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.utc_hour_offset_2_digits_description">
            <summary>With DateTime values, the "zz" custom format specifier represents the signed offset of the local operating system's time zone from UTC, measured in hours. It doesn't reflect the value of an instance's DateTime.Kind property. For this reason, the "zz" forma ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.year_1_2_digits">
            <summary>year (1-2 digits)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.year_1_2_digits_description">
            <summary>The "y" custom format specifier represents the year as a one-digit or two-digit number. If the year has more than two digits, only the two low-order digits appear in the result. If the first digit of a two-digit year begins with a zero (for example, 2008), ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.year_2_digits">
            <summary>year (2 digits)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.year_2_digits_description">
            <summary>The "yy" custom format specifier represents the year as a two-digit number. If the year has more than two digits, only the two low-order digits appear in the result. If the two-digit year has fewer than two significant digits, the number is padded with lea ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.year_3_4_digits">
            <summary>year (3-4 digits)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.year_3_4_digits_description">
            <summary>The "yyy" custom format specifier represents the year with a minimum of three digits. If the year has more than three significant digits, they are included in the result string. If the year has fewer than three digits, the number is padded with leading zer ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.year_4_digits">
            <summary>year (4 digits)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.year_4_digits_description">
            <summary>The "yyyy" custom format specifier represents the year with a minimum of four digits. If the year has more than four significant digits, they are included in the result string. If the year has fewer than four digits, the number is padded with leading zeros ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.year_5_digits">
            <summary>year (5 digits)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.year_5_digits_description">
            <summary>The "yyyyy" custom format specifier (plus any number of additional "y" specifiers) represents the year with a minimum of five digits. If the year has more than five significant digits, they are included in the result string. If the year has fewer than five ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.year_month">
            <summary>year month</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.year_month_description">
            <summary>The "Y" or "y" standard format specifier represents a custom date and time format string that is defined by the DateTimeFormatInfo.YearMonthPattern property of a specified culture. For example, the custom format string for the invariant culture is "yyyy MM ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._10000000ths_of_a_second">
            <summary>10,000,000ths of a second</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._10000000ths_of_a_second_description">
            <summary>The "fffffff" custom format specifier represents the seven most significant digits of the seconds fraction; that is, it represents the ten millionths of a second in a date and time value.
            
            Although it's possible to display the ten millionths of a second co ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._10000000ths_of_a_second_non_zero">
            <summary>10,000,000ths of a second (non-zero)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._10000000ths_of_a_second_non_zero_description">
            <summary>The "FFFFFFF" custom format specifier represents the seven most significant digits of the seconds fraction; that is, it represents the ten millionths of a second in a date and time value. However, trailing zeros or seven zero digits aren't displayed.
            
            Alth ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._1000000ths_of_a_second">
            <summary>1,000,000ths of a second</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._1000000ths_of_a_second_description">
            <summary>The "ffffff" custom format specifier represents the six most significant digits of the seconds fraction; that is, it represents the millionths of a second in a date and time value.
            
            Although it's possible to display the millionths of a second component of  ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._1000000ths_of_a_second_non_zero">
            <summary>1,000,000ths of a second (non-zero)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._1000000ths_of_a_second_non_zero_description">
            <summary>The "FFFFFF" custom format specifier represents the six most significant digits of the seconds fraction; that is, it represents the millionths of a second in a date and time value. However, trailing zeros or six zero digits aren't displayed.
            
            Although it's ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._100000ths_of_a_second">
            <summary>100,000ths of a second</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._100000ths_of_a_second_description">
            <summary>The "fffff" custom format specifier represents the five most significant digits of the seconds fraction; that is, it represents the hundred thousandths of a second in a date and time value.
            
            Although it's possible to display the hundred thousandths of a se ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._100000ths_of_a_second_non_zero">
            <summary>100,000ths of a second (non-zero)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._100000ths_of_a_second_non_zero_description">
            <summary>The "FFFFF" custom format specifier represents the five most significant digits of the seconds fraction; that is, it represents the hundred thousandths of a second in a date and time value. However, trailing zeros or five zero digits aren't displayed.
            
            Alt ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._10000ths_of_a_second">
            <summary>10,000ths of a second</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._10000ths_of_a_second_description">
            <summary>The "ffff" custom format specifier represents the four most significant digits of the seconds fraction; that is, it represents the ten thousandths of a second in a date and time value.
            
            Although it's possible to display the ten thousandths of a second comp ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._10000ths_of_a_second_non_zero">
            <summary>10,000ths of a second (non-zero)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._10000ths_of_a_second_non_zero_description">
            <summary>The "FFFF" custom format specifier represents the four most significant digits of the seconds fraction; that is, it represents the ten thousandths of a second in a date and time value. However, trailing zeros or four zero digits aren't displayed.
            
            Although ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._1000ths_of_a_second">
            <summary>1,000ths of a second</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._1000ths_of_a_second_description">
            <summary>The "fff" custom format specifier represents the three most significant digits of the seconds fraction; that is, it represents the milliseconds in a date and time value.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._1000ths_of_a_second_non_zero">
            <summary>1,000ths of a second (non-zero)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._1000ths_of_a_second_non_zero_description">
            <summary>The "FFF" custom format specifier represents the three most significant digits of the seconds fraction; that is, it represents the milliseconds in a date and time value. However, trailing zeros or three zero digits aren't displayed.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._100ths_of_a_second">
            <summary>100ths of a second</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._100ths_of_a_second_description">
            <summary>The "ff" custom format specifier represents the two most significant digits of the seconds fraction; that is, it represents the hundredths of a second in a date and time value.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._100ths_of_a_second_non_zero">
            <summary>100ths of a second (non-zero)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._100ths_of_a_second_non_zero_description">
            <summary>The "FF" custom format specifier represents the two most significant digits of the seconds fraction; that is, it represents the hundredths of a second in a date and time value. However, trailing zeros or two zero digits aren't displayed.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._10ths_of_a_second">
            <summary>10ths of a second</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._10ths_of_a_second_description">
            <summary>The "f" custom format specifier represents the most significant digit of the seconds fraction; that is, it represents the tenths of a second in a date and time value.
            
            If the "f" format specifier is used without other format specifiers, it's interpreted as ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._10ths_of_a_second_non_zero">
            <summary>10ths of a second (non-zero)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._10ths_of_a_second_non_zero_description">
            <summary>The "F" custom format specifier represents the most significant digit of the seconds fraction; that is, it represents the tenths of a second in a date and time value. Nothing is displayed if the digit is zero.
            
            If the "F" format specifier is used without o ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._12_hour_clock_1_2_digits">
            <summary>12 hour clock (1-2 digits)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._12_hour_clock_1_2_digits_description">
            <summary>The "h" custom format specifier represents the hour as a number from 1 through 12; that is, the hour is represented by a 12-hour clock that counts the whole hours since midnight or noon. A particular hour after midnight is indistinguishable from the same h ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._12_hour_clock_2_digits">
            <summary>12 hour clock (2 digits)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._12_hour_clock_2_digits_description">
            <summary>The "hh" custom format specifier (plus any number of additional "h" specifiers) represents the hour as a number from 01 through 12; that is, the hour is represented by a 12-hour clock that counts the whole hours since midnight or noon. A particular hour af ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._24_hour_clock_1_2_digits">
            <summary>24 hour clock (1-2 digits)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._24_hour_clock_1_2_digits_description">
            <summary>The "H" custom format specifier represents the hour as a number from 0 through 23; that is, the hour is represented by a zero-based 24-hour clock that counts the hours since midnight. A single-digit hour is formatted without a leading zero.
            
            If the "H" for ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._24_hour_clock_2_digits">
            <summary>24 hour clock (2 digits)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._24_hour_clock_2_digits_description">
            <summary>The "HH" custom format specifier (plus any number of additional "H" specifiers) represents the hour as a number from 00 through 23; that is, the hour is represented by a zero-based 24-hour clock that counts the hours since midnight. A single-digit hour is  ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_for_0">
            <summary>Generate for '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Generate_comparison_operators">
            <summary>Generate comparison operators</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Create_and_assign_remaining_as_fields">
            <summary>Create and assign remaining as fields</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Create_and_assign_remaining_as_properties">
            <summary>Create and assign remaining as properties</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Example">
            <summary>Example:</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Examples">
            <summary>Examples:</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Alternation_conditions_cannot_be_comments">
            <summary>Alternation conditions cannot be comments</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Alternation_conditions_do_not_capture_and_cannot_be_named">
            <summary>Alternation conditions do not capture and cannot be named</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.A_subtraction_must_be_the_last_element_in_a_character_class">
            <summary>A subtraction must be the last element in a character class</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Cannot_include_class_0_in_character_range">
            <summary>Cannot include class \{0} in character range</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Quantifier_and_capture_group_numbers_must_be_less_than_or_equal_to_Int32_MaxValue">
            <summary>Quantifier and capture group numbers must be less than or equal to Int32.MaxValue</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Capture_number_cannot_be_zero">
            <summary>Capture number cannot be zero</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Illegal_backslash_at_end_of_pattern">
            <summary>Illegal \ at end of pattern</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Illegal_x_y_with_x_less_than_y">
            <summary>Illegal {x,y} with x &gt; y</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Incomplete_character_escape">
            <summary>Incomplete \p{X} character escape</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Insufficient_or_invalid_hexadecimal_digits">
            <summary>Insufficient or invalid hexadecimal digits</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Invalid_group_name_Group_names_must_begin_with_a_word_character">
            <summary>Invalid group name: Group names must begin with a word character</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Conditional_alternation_is_missing_a_closing_parenthesis_after_the_group_number_0">
            <summary>Conditional alternation is missing a closing parenthesis after the group number {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Conditional_alternation_refers_to_an_undefined_group_number_0">
            <summary>Conditional alternation refers to an undefined group number {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Malformed_character_escape">
            <summary>Malformed \p{X} character escape</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Malformed_named_back_reference">
            <summary>Malformed \k&lt;...&gt; named back reference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Missing_control_character">
            <summary>Missing control character</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Nested_quantifier_0">
            <summary>Nested quantifier '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Not_enough_close_parens">
            <summary>Not enough )'s</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Quantifier_0_following_nothing">
            <summary>Quantifier '{0}' following nothing</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Reference_to_undefined_group_name_0">
            <summary>Reference to undefined group name '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Reference_to_undefined_group_number_0">
            <summary>Reference to undefined group number {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Too_many_bars_in_conditional_grouping">
            <summary>Too many | in (?()|)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Too_many_close_parens">
            <summary>Too many )'s</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unknown_property">
            <summary>Unknown property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unknown_property_0">
            <summary>Unknown property '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unrecognized_control_character">
            <summary>Unrecognized control character</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unrecognized_escape_sequence_0">
            <summary>Unrecognized escape sequence \{0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unrecognized_grouping_construct">
            <summary>Unrecognized grouping construct</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unterminated_character_class_set">
            <summary>Unterminated [] set</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unterminated_regex_comment">
            <summary>Unterminated (?#...) comment</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.x_y_range_in_reverse_order">
            <summary>[x-y] range in reverse order</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_issue_0">
            <summary>Regex issue: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_number_decimal_digit">
            <summary>number, decimal digit</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_number_letter">
            <summary>number, letter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_number_other">
            <summary>number, other</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_other_control">
            <summary>other, control</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_other_format">
            <summary>other, format</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_other_not_assigned">
            <summary>other, not assigned</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_other_private_use">
            <summary>other, private use</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_other_surrogate">
            <summary>other, surrogate</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_punctuation_close">
            <summary>punctuation, close</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_punctuation_connector">
            <summary>punctuation, connector</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_punctuation_dash">
            <summary>punctuation, dash</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_punctuation_final_quote">
            <summary>punctuation, final quote</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_punctuation_initial_quote">
            <summary>punctuation, initial quote</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_punctuation_open">
            <summary>punctuation, open</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_punctuation_other">
            <summary>punctuation, other</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_separator_line">
            <summary>separator, line</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_separator_paragraph">
            <summary>separator, paragraph</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_separator_space">
            <summary>separator, space</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_symbol_currency">
            <summary>symbol, currency</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_symbol_math">
            <summary>symbol, math</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_symbol_modifier">
            <summary>symbol, modifier</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_symbol_other">
            <summary>symbol, other</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_letter_lowercase">
            <summary>letter, lowercase</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_letter_modifier">
            <summary>letter, modifier</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_letter_other">
            <summary>letter, other</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_letter_titlecase">
            <summary>letter, titlecase</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_mark_enclosing">
            <summary>mark, enclosing</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_mark_nonspacing">
            <summary>mark, nonspacing</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_mark_spacing_combining">
            <summary>mark, spacing combining</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_contiguous_matches_long">
            <summary>The \G anchor specifies that a match must occur at the point where the previous match ended. When you use this anchor with the Regex.Matches or Match.NextMatch method, it ensures that all matches are contiguous.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_contiguous_matches_short">
            <summary>contiguous matches</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_end_of_string_only_long">
            <summary>The \z anchor specifies that a match must occur at the end of the input string. Like the $ language element, \z ignores the RegexOptions.Multiline option. Unlike the \Z language element, \z does not match a \n character at the end of a string. Therefore, i ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_end_of_string_only_short">
            <summary>end of string only</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_end_of_string_or_before_ending_newline_long">
            <summary>The \Z anchor specifies that a match must occur at the end of the input string, or before \n at the end of the input string. It is identical to the $ anchor, except that \Z ignores the RegexOptions.Multiline option. Therefore, in a multiline string, it can ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_end_of_string_or_before_ending_newline_short">
            <summary>end of string or before ending newline</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_non_word_boundary_long">
            <summary>The \B anchor specifies that the match must not occur on a word boundary. It is the opposite of the \b anchor.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_non_word_boundary_short">
            <summary>non-word boundary</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_start_of_string_only_long">
            <summary>The \A anchor specifies that a match must occur at the beginning of the input string. It is identical to the ^ anchor, except that \A ignores the RegexOptions.Multiline option. Therefore, it can only match the start of the first line in a multiline input s ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_start_of_string_only_short">
            <summary>start of string only</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_word_boundary_long">
            <summary>The \b anchor specifies that the match must occur on a boundary between a word character (the \w language element) and a non-word character (the \W language element). Word characters consist of alphanumeric characters and underscores; a non-word character  ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_word_boundary_short">
            <summary>word boundary</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_start_of_string_or_line_long">
            <summary>The ^ anchor specifies that the following pattern must begin at the first character position of the string. If you use ^ with the RegexOptions.Multiline option, the match must occur at the beginning of each line.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_start_of_string_or_line_short">
            <summary>start of string or line</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_end_of_string_or_line_long">
            <summary>The $ anchor specifies that the preceding pattern must occur at the end of the input string, or before \n at the end of the input string. If you use $ with the RegexOptions.Multiline option, the match can also occur at the end of a line.
            
            The $ anchor matc ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_end_of_string_or_line_short">
            <summary>end of string or line</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_any_character_group_long">
            <summary>The period character (.) matches any character except \n (the newline character, \u000A).  If a regular expression pattern is modified by the RegexOptions.Singleline option, or if the portion of the pattern that contains the . character class is modified b ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_any_character_group_short">
            <summary>any character</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_backspace_character_long">
            <summary>Matches a backspace character, \u0008</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_backspace_character_short">
            <summary>backspace character</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_bell_character_long">
            <summary>Matches a bell (alarm) character, \u0007</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_bell_character_short">
            <summary>bell character</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_carriage_return_character_long">
            <summary>Matches a carriage-return character, \u000D.  Note that \r is not equivalent to the newline character, \n.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_carriage_return_character_short">
            <summary>carriage-return character</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_control_character_long">
            <summary>Matches an ASCII control character, where X is the letter of the control character. For example, \cC is CTRL-C.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_control_character_short">
            <summary>control character</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_decimal_digit_character_long">
            <summary>\d matches any decimal digit. It is equivalent to the \p{Nd} regular expression pattern, which includes the standard decimal digits 0-9 as well as the decimal digits of a number of other character sets.
            
            If ECMAScript-compliant behavior is specified, \d is ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_decimal_digit_character_short">
            <summary>decimal-digit character</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_escape_character_long">
            <summary>Matches an escape character, \u001B</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_escape_character_short">
            <summary>escape character</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_form_feed_character_long">
            <summary>Matches a form-feed character, \u000C</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_form_feed_character_short">
            <summary>form-feed character</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_hexadecimal_escape_long">
            <summary>Matches an ASCII character, where ## is a two-digit hexadecimal character code.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_hexadecimal_escape_short">
            <summary>hexadecimal escape</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_letter_uppercase">
            <summary>letter, uppercase</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_matched_subexpression_long">
            <summary>This grouping construct captures a matched 'subexpression', where 'subexpression' is any valid regular expression pattern. Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regu ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_matched_subexpression_short">
            <summary>matched subexpression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_negative_character_group_long">
            <summary>A negative character group specifies a list of characters that must not appear in an input string for a match to occur. The list of characters are specified individually.
            
            Two or more character ranges can be concatenated. For example, to specify the range  ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_negative_character_group_short">
            <summary>negative character group</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_negative_character_range_long">
            <summary>A negative character range specifies a list of characters that must not appear in an input string for a match to occur. 'firstCharacter' is the character that begins the range, and 'lastCharacter' is the character that ends the range.
            
            Two or more characte ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_negative_unicode_category_long">
            <summary>The regular expression construct \P{ name } matches any character that does not belong to a Unicode general category or named block, where name is the category abbreviation or named block name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_negative_unicode_category_short">
            <summary>negative unicode category</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_new_line_character_long">
            <summary>Matches a new-line character, \u000A</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_new_line_character_short">
            <summary>new-line character</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_non_digit_character_long">
            <summary>\D matches any non-digit character. It is equivalent to the \P{Nd} regular expression pattern.
            
            If ECMAScript-compliant behavior is specified, \D is equivalent to [^0-9]</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_non_digit_character_short">
            <summary>non-digit character</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_non_white_space_character_long">
            <summary>\S matches any non-white-space character. It is equivalent to the [^\f\n\r\t\v\x85\p{Z}] regular expression pattern, or the opposite of the regular expression pattern that is equivalent to \s, which matches white-space characters.
            
            If ECMAScript-compliant  ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_non_white_space_character_short">
            <summary>non-white-space character</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_non_word_character_long">
            <summary>\W matches any non-word character. It matches any character except for those in the following Unicode categories:
            
                Ll	Letter, Lowercase
                Lu	Letter, Uppercase
                Lt	Letter, Titlecase
                Lo	Letter, Other
                Lm	Letter, Modifier
                Mn	Mark, Nonspaci ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_non_word_character_short">
            <summary>non-word character</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_positive_character_group_long">
            <summary>A positive character group specifies a list of characters, any one of which may appear in an input string for a match to occur.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_positive_character_group_short">
            <summary>positive character group</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_positive_character_range_long">
            <summary>A positive character range specifies a range of characters, any one of which may appear in an input string for a match to occur.  'firstCharacter' is the character that begins the range and 'lastCharacter' is the character that ends the range.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_positive_character_range_short">
            <summary>positive character range</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_subexpression">
            <summary>subexpression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_tab_character_long">
            <summary>Matches a tab character, \u0009</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_tab_character_short">
            <summary>tab character</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_unicode_category_long">
            <summary>The regular expression construct \p{ name } matches any character that belongs to a Unicode general category or named block, where name is the category abbreviation or named block name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_unicode_category_short">
            <summary>unicode category</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_unicode_escape_long">
            <summary>Matches a UTF-16 code unit whose value is #### hexadecimal.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_unicode_escape_short">
            <summary>unicode escape</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_vertical_tab_character_long">
            <summary>Matches a vertical-tab character, \u000B</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_vertical_tab_character_short">
            <summary>vertical-tab character</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_white_space_character_long">
            <summary>\s matches any white-space character. It is equivalent to the following escape sequences and Unicode categories:
            
                \f	The form feed character, \u000C
                \n	The newline character, \u000A
                \r	The carriage return character, \u000D
                \t	The tab charac ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_white_space_character_short">
            <summary>white-space character</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_word_character_long">
            <summary>\w matches any word character. A word character is a member of any of the following Unicode categories:
            
                Ll	Letter, Lowercase
                Lu	Letter, Uppercase
                Lt	Letter, Titlecase
                Lo	Letter, Other
                Lm	Letter, Modifier
                Mn	Mark, Nonspacing
                Nd	 ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_word_character_short">
            <summary>word character</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_alternation_long">
            <summary>You can use the vertical bar (|) character to match any one of a series of patterns, where the | character separates each pattern.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_alternation_short">
            <summary>alternation</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_balancing_group_long">
            <summary>A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group.
            
            'name1' is the current group (optional), 'name2' is a previously d ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_balancing_group_short">
            <summary>balancing group</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_comment">
            <summary>comment</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_conditional_expression_match_long">
            <summary>This language element attempts to match one of two patterns depending on whether it can match an initial pattern.
            
            'expression' is the initial pattern to match, 'yes' is the pattern to match if expression is matched, and 'no' is the optional pattern to mat ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_conditional_expression_match_short">
            <summary>conditional expression match</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_conditional_group_match_long">
            <summary>This language element attempts to match one of two patterns depending on whether it has matched a specified capturing group.
            
            'name' is the name (or number) of a capturing group, 'yes' is the expression to match if 'name' (or 'number') has a match, and 'no ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_conditional_group_match_short">
            <summary>conditional group match</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_end_of_line_comment_long">
            <summary>A number sign (#) marks an x-mode comment, which starts at the unescaped # character at the end of the regular expression pattern and continues until the end of the line. To use this construct, you must either enable the x option (through inline options) o ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_end_of_line_comment_short">
            <summary>end-of-line comment</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_expression">
            <summary>expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_group_options_long">
            <summary>This grouping construct applies or disables the specified options within a subexpression. The options to enable are specified after the question mark, and the options to disable after the minus sign. The allowed options are:
            
                i	Use case-insensitive mat ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_group_options_short">
            <summary>group options</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_inline_comment_long">
            <summary>The (?# comment) construct lets you include an inline comment in a regular expression. The regular expression engine does not use any part of the comment in pattern matching, although the comment is included in the string that is returned by the Regex.ToSt ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_inline_comment_short">
            <summary>inline comment</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_name">
            <summary>name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_name1">
            <summary>name1</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_name2">
            <summary>name2</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_named_backreference_long">
            <summary>A named or numbered backreference.
            
            'name' is the name of a capturing group defined in the regular expression pattern.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_named_backreference_short">
            <summary>named backreference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_named_matched_subexpression_long">
            <summary>Captures a matched subexpression and lets you access it by name or by number.
            
            'name' is a valid group name, and 'subexpression' is any valid regular expression pattern. 'name' must not contain any punctuation characters and cannot begin with a number.
            
            If ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_named_matched_subexpression_short">
            <summary>named matched subexpression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_name_or_number">
            <summary>name-or-number</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_no">
            <summary>no</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_atomic_group_long">
            <summary>Atomic groups (known in some other regular expression engines as a nonbacktracking subexpression, an atomic subexpression, or a once-only subexpression) disable backtracking. The regular expression engine will match as many characters in the input string a ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_atomic_group_short">
            <summary>atomic group</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_noncapturing_group_long">
            <summary>This construct does not capture the substring that is matched by a subexpression:
            
            The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.
            
            If a regular expres ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_noncapturing_group_short">
            <summary>noncapturing group</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_numbered_backreference_long">
            <summary>A numbered backreference, where 'number' is the ordinal position of the capturing group in the regular expression. For example, \4 matches the contents of the fourth capturing group.
            
            There is an ambiguity between octal escape codes (such as \16) and \numb ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_numbered_backreference_short">
            <summary>numbered backreference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_yes">
            <summary>yes</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_zero_width_negative_lookahead_assertion_long">
            <summary>A zero-width negative lookahead assertion, where for the match to be successful, the input string must not match the regular expression pattern in subexpression. The matched string is not included in the match result.
            
            A zero-width negative lookahead asser ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_zero_width_negative_lookahead_assertion_short">
            <summary>zero-width negative lookahead assertion</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_zero_width_negative_lookbehind_assertion_long">
            <summary>A zero-width negative lookbehind assertion, where for a match to be successful, 'subexpression' must not occur at the input string to the left of the current position. Any substring that does not match 'subexpression' is not included in the match result.
            
             ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_zero_width_negative_lookbehind_assertion_short">
            <summary>zero-width negative lookbehind assertion</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_zero_width_positive_lookahead_assertion_long">
            <summary>A zero-width positive lookahead assertion, where for a match to be successful, the input string must match the regular expression pattern in 'subexpression'. The matched substring is not included in the match result. A zero-width positive lookahead asserti ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_zero_width_positive_lookahead_assertion_short">
            <summary>zero-width positive lookahead assertion</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_zero_width_positive_lookbehind_assertion_long">
            <summary>A zero-width positive lookbehind assertion, where for a match to be successful, 'subexpression' must occur at the input string to the left of the current position. 'subexpression' is not included in the match result. A zero-width positive lookbehind assert ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_zero_width_positive_lookbehind_assertion_short">
            <summary>zero-width positive lookbehind assertion</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_all_control_characters_long">
            <summary>All control characters. This includes the Cc, Cf, Cs, Co, and Cn categories.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_all_control_characters_short">
            <summary>all control characters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_all_diacritic_marks_long">
            <summary>All diacritic marks. This includes the Mn, Mc, and Me categories.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_all_diacritic_marks_short">
            <summary>all diacritic marks</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_all_letter_characters_long">
            <summary>All letter characters. This includes the Lu, Ll, Lt, Lm, and Lo characters.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_all_letter_characters_short">
            <summary>all letter characters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_all_numbers_long">
            <summary>All numbers. This includes the Nd, Nl, and No categories.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_all_numbers_short">
            <summary>all numbers</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_all_punctuation_characters_long">
            <summary>All punctuation characters. This includes the Pc, Pd, Ps, Pe, Pi, Pf, and Po categories.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_all_punctuation_characters_short">
            <summary>all punctuation characters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_all_separator_characters_long">
            <summary>All separator characters. This includes the Zs, Zl, and Zp categories.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_all_separator_characters_short">
            <summary>all separator characters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_all_symbols_long">
            <summary>All symbols. This includes the Sm, Sc, Sk, and So categories.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_all_symbols_short">
            <summary>all symbols</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_base_group">
            <summary>base-group</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_character_class_subtraction_long">
            <summary>Character class subtraction yields a set of characters that is the result of excluding the characters in one character class from another character class.
            
            'base_group' is a positive or negative character group or range. The 'excluded_group' component is a ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_character_class_subtraction_short">
            <summary>character class subtraction</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_character_group">
            <summary>character-group</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_excluded_group">
            <summary>excluded-group</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_match_at_least_n_times_lazy_long">
            <summary>The {n,}? quantifier matches the preceding element at least n times, where n is any integer, but as few times as possible. It is the lazy counterpart of the greedy quantifier {n,}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_match_at_least_n_times_lazy_short">
            <summary>match at least 'n' times (lazy)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_match_at_least_n_times_long">
            <summary>The {n,} quantifier matches the preceding element at least n times, where n is any integer. {n,} is a greedy quantifier whose lazy equivalent is {n,}?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_match_at_least_n_times_short">
            <summary>match at least 'n' times</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_match_between_m_and_n_times_lazy_long">
            <summary>The {n,m}? quantifier matches the preceding element between n and m times, where n and m are integers, but as few times as possible. It is the lazy counterpart of the greedy quantifier {n,m}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_match_between_m_and_n_times_lazy_short">
            <summary>match at least 'n' times (lazy)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_match_between_m_and_n_times_long">
            <summary>The {n,m} quantifier matches the preceding element at least n times, but no more than m times, where n and m are integers. {n,m} is a greedy quantifier whose lazy equivalent is {n,m}?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_match_between_m_and_n_times_short">
            <summary>match between 'm' and 'n' times</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_match_exactly_n_times_lazy_long">
            <summary>The {n}? quantifier matches the preceding element exactly n times, where n is any integer. It is the lazy counterpart of the greedy quantifier {n}+</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_match_exactly_n_times_lazy_short">
            <summary>match exactly 'n' times (lazy)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_match_exactly_n_times_long">
            <summary>The {n} quantifier matches the preceding element exactly n times, where n is any integer. {n} is a greedy quantifier whose lazy equivalent is {n}?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_match_exactly_n_times_short">
            <summary>match exactly 'n' times</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_match_one_or_more_times_lazy_long">
            <summary>The +? quantifier matches the preceding element one or more times, but as few times as possible. It is the lazy counterpart of the greedy quantifier +</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_match_one_or_more_times_lazy_short">
            <summary>match one or more times (lazy)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_match_one_or_more_times_long">
            <summary>The + quantifier matches the preceding element one or more times. It is equivalent to the {1,} quantifier. + is a greedy quantifier whose lazy equivalent is +?.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_match_one_or_more_times_short">
            <summary>match one or more times</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_match_zero_or_more_times_lazy_long">
            <summary>The *? quantifier matches the preceding element zero or more times, but as few times as possible. It is the lazy counterpart of the greedy quantifier *</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_match_zero_or_more_times_lazy_short">
            <summary>match zero or more times (lazy)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_match_zero_or_more_times_long">
            <summary>The * quantifier matches the preceding element zero or more times. It is equivalent to the {0,} quantifier. * is a greedy quantifier whose lazy equivalent is *?.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_match_zero_or_more_times_short">
            <summary>match zero or more times</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_match_zero_or_one_time_lazy_long">
            <summary>The ?? quantifier matches the preceding element zero or one time, but as few times as possible. It is the lazy counterpart of the greedy quantifier ?</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_match_zero_or_one_time_lazy_short">
            <summary>match zero or one time (lazy)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_match_zero_or_one_time_long">
            <summary>The ? quantifier matches the preceding element zero or one time. It is equivalent to the {0,1} quantifier. ? is a greedy quantifier whose lazy equivalent is ??.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_match_zero_or_one_time_short">
            <summary>match zero or one time</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_unicode_general_category_0">
            <summary>Unicode General Category: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_inline_options_long">
            <summary>Enables or disables specific pattern matching options for the remainder of a regular expression. The options to enable are specified after the question mark, and the options to disable after the minus sign. The allowed options are:
            
                i	Use case-insensit ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Regex_inline_options_short">
            <summary>inline options</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._0_cannot_be_null_or_empty">
            <summary>'{0}' cannot be null or empty.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._0_cannot_be_null_or_whitespace">
            <summary>'{0}' cannot be null or whitespace.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._0_is_not_null_here">
            <summary>'{0}' is not null here.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._0_may_be_null_here">
            <summary>'{0}' may be null here.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._0_is_not_nullable_aware">
            <summary>'{0}' is not nullable aware.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.ChangeSignature_NewParameterInferValue">
            <summary>&lt;infer&gt;</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.from_metadata">
            <summary>from metadata</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.symbol_cannot_be_a_namespace">
            <summary>'symbol' cannot be a namespace.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Document_must_be_contained_in_the_workspace_that_created_this_service">
            <summary>Document must be contained in the workspace that created this service</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Property_reference_cannot_be_updated">
            <summary>Property reference cannot be updated</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Inline_0">
            <summary>Inline '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Extract_base_class">
            <summary>Extract base class...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Inline_and_keep_0">
            <summary>Inline and keep '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Operators">
            <summary>Operators</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.The_assembly_0_containing_type_1_references_NET_Framework">
            <summary>The assembly '{0}' containing type '{1}' references .NET Framework, which is not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.The_assembly_0_references_compiler_version_1_newer_than_2">
            <summary>Analyzer assembly '{0}' cannot be used because it references version '{1}' of the compiler, which is newer than the currently running version '{2}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Apply_file_header_preferences">
            <summary>Apply file header preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Apply_object_collection_initialization_preferences">
            <summary>Apply object/collection initialization preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Remove_unnecessary_casts">
            <summary>Remove unnecessary casts</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Remove_unused_variables">
            <summary>Remove unused variables</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Sort_accessibility_modifiers">
            <summary>Sort accessibility modifiers</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Error_creating_instance_of_CodeFixProvider">
            <summary>Error creating instance of CodeFixProvider</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Error_creating_instance_of_CodeFixProvider_0">
            <summary>Error creating instance of CodeFixProvider '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Removal_of_document_not_supported">
            <summary>Removal of document not supported</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.in_0_1_2">
            <summary>in {0} ({1} - {2})</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._0_dash_1">
            <summary>{0} - {1}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.all_anonymous_types_in_container">
            <summary>all anonymous types in container</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Convert_to_tuple">
            <summary>Convert to tuple</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.just_this_anonymous_type">
            <summary>just this anonymous type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.member_kind_and_name">
            <summary>{0} '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.symbol_kind_and_name_of_member_kind_and_name">
            <summary>{0} '{1}' of {2} '{3}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.code">
            <summary>code</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Convert_to_record">
            <summary>Convert to record</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Introduce_parameter_for_0">
            <summary>Introduce parameter for '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Introduce_parameter_for_all_occurrences_of_0">
            <summary>Introduce parameter for all occurrences of '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.into_new_overload">
            <summary>into new overload</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.into_extracted_method_to_invoke_at_call_sites">
            <summary>into extracted method to invoke at call sites</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.and_update_call_sites_directly">
            <summary>and update call sites directly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Convert_to_record_struct">
            <summary>Convert to record struct</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Applying_source_changes_while_the_application_is_running_is_not_supported_by_the_runtime">
            <summary>Applying source changes while the application is running is not supported by the runtime.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_reloadable_type_marked_by_0_attribute_or_its_member_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime">
            <summary>Updating a reloadable type (marked by {0}) or its member requires restarting the application because is not supported by the runtime.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Making_a_method_an_iterator_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime">
            <summary>Making a method an iterator requires restarting the application because is not supported by the runtime.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Making_a_method_asynchronous_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime">
            <summary>Making a method asynchronous requires restarting the application because is not supported by the runtime.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_the_attributes_of_0_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime">
            <summary>Updating the attributes of {0} requires restarting the application because it is not supported by the runtime.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.An_update_that_causes_the_return_type_of_implicit_main_to_change_requires_restarting_the_application">
            <summary>An update that causes the return type of the implicit Main method to change requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Changing_parameter_types_of_0_requires_restarting_the_application">
            <summary>Changing parameter types of {0} requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Changing_type_parameters_of_0_requires_restarting_the_application">
            <summary>Changing type parameters of {0} requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Changing_constraints_of_0_requires_restarting_the_application">
            <summary>Changing constraints of {0} requires restarting the application.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.No_common_root_node_for_extraction">
            <summary>No common root node for extraction.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.No_valid_selection_to_perform_extraction">
            <summary>No valid selection to perform extraction.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Selection_does_not_contain_a_valid_token">
            <summary>Selection does not contain a valid token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Selection_not_contained_inside_a_type">
            <summary>Selection not contained inside a type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Invalid_selection">
            <summary>Invalid selection.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Renaming_0_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime">
            <summary>Renaming {0} requires restarting the application because it is not supported by the runtime.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Move_static_members_to_another_type">
            <summary>Move static members to another type...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Changing_pseudo_custom_attribute_0_of_1_requires_restarting_th_application">
            <summary>Changing pseudo-custom attribute '{0}' of {1} requires restarting the application</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Changing_the_containing_namespace_of_0_from_1_to_2_requires_restarting_th_application">
            <summary>Changing the containing namespace of '{0}' from '{1}' to '{2}' requires restarting the application</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.ChangesRequiredSynthesizedType">
            <summary>One or more changes result in a new type being created by the compiler, which requires restarting the application because it is not supported by the runtime</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Changing_source_file_0_in_a_stale_project_has_no_effect_until_the_project_is_rebuit">
            <summary>Changing source file '{0}' in a stale project has no effect until the project is rebuit.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Miscellaneous_Files">
            <summary>Miscellaneous Files</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Silent">
            <summary>Silent</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.console_writeline">
            <summary>Console.WriteLine</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.embedded">
            <summary>embedded</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.external">
            <summary>external</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Could_not_find_PDB_on_disk_or_embedded">
            <summary>Could not find portable PDB on disk or embedded.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Error_reading_PDB_0">
            <summary>Error reading PDB: '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Found_embedded_PDB_file">
            <summary>Found embedded PDB file.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Found_PDB_file_at_0">
            <summary>Found PDB file at '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Found_PDB_on_symbol_server">
            <summary>Found PDB on symbol server.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Found_PDB_on_symbol_server_but_could_not_read_file">
            <summary>Found PDB on symbol server but could not read file.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Navigating_to_symbol_0_from_1">
            <summary>Navigating to symbol '{0}' from '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.No_source_document_info_found_in_PDB">
            <summary>No source document info found in PDB.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Source_code_language_information_was_not_found_in_PDB">
            <summary>Source code language information was not found in PDB.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Source_is_a_reference_assembly">
            <summary>Source is a reference assembly, not enough information to find PDB.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._0_found_in_embedded_PDB">
            <summary>'{0}' found in embedded PDB.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._0_found_in_embedded_PDB_but_checksum_failed">
            <summary>'{0}' found in embedded PDB but checksum was wrong, or couldn't read temp file.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._0_found_in_embedded_PDB_but_could_not_write_file_1">
            <summary>'{0}' found in embedded PDB but could not write to temp file: '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._0_found_in_embedded_PDB_cached_source_file">
            <summary>'{0}' found in embedded PDB and found cached source file.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._0_found_via_SourceLink">
            <summary>'{0}' found via SourceLink.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._0_found_via_SourceLink_but_couldnt_read_file">
            <summary>'{0}' found via SourceLink but couldn't read temp file.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._0_found_in_original_location">
            <summary>'{0}' found in original location.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._0_found_in_original_location_but_checksum_failed">
            <summary>'{0}' found in original location but checksum was wrong, or couldn't read temp file.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Could_not_find_PDB_on_disk_or_embedded_or_server">
            <summary>Could not find PDB on disk, or embedded, or on a symbol server.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Timeout_SourceLink">
            <summary>Timed out trying to download source code from SourceLink. Subsequent requests may succeed.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Timeout_symbol_server">
            <summary>Timed out trying to download PDB from symbol server. Subsequent requests may succeed.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Symbol_found_in_assembly_path_0">
            <summary>Symbol found in assembly path '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Invalid_number">
            <summary>Invalid number</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unterminated_comment">
            <summary>Unterminated comment</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unterminated_string">
            <summary>Unterminated string</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._0_expected">
            <summary>'{0}' expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._0_unexpected">
            <summary>'{0}' unexpected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Invalid_escape_sequence">
            <summary>Invalid escape sequence</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Error_parsing_comment">
            <summary>Error parsing comment</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Syntax_error">
            <summary>Syntax error</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Invalid_property_name">
            <summary>Invalid property name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Missing_property_value">
            <summary>Missing property value</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Nested_properties_not_allowed">
            <summary>Nested properties not allowed</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Name_expected">
            <summary>Name expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Invalid_constructor_name">
            <summary>Invalid constructor name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Comments_not_allowed">
            <summary>Comments not allowed</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Constructors_not_allowed">
            <summary>Constructors not allowed</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Illegal_string_character">
            <summary>Illegal string character</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Illegal_whitespace_character">
            <summary>Illegal whitespace character</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Only_properties_allowed_in_an_object">
            <summary>Only properties allowed in an object</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Properties_not_allowed_in_an_array">
            <summary>Properties not allowed in an array</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Property_name_must_be_a_string">
            <summary>Property name must be a string</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Property_name_must_be_followed_by_a_colon">
            <summary>Property name must be followed by a ':'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Strings_must_start_with_double_quote_not_single_quote">
            <summary>Strings must start with " not '</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Trailing_comma_not_allowed">
            <summary>Trailing comma not allowed</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Value_required">
            <summary>Value required</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._0_literal_not_allowed">
            <summary>'{0}' literal not allowed</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.JSON_issue_0">
            <summary>JSON issue: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Probable_JSON_string_detected">
            <summary>Probable JSON string detected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Enable_all_JSON_editor_features">
            <summary>Enable all JSON editor features</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Invalid_regex_pattern">
            <summary>Invalid regex pattern</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Invalid_JSON_pattern">
            <summary>Invalid JSON pattern</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unwrap_initializer">
            <summary>Unwrap initializer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Wrap_initializer">
            <summary>Wrap initializer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Wrap_long_initializer">
            <summary>Wrap long initializer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unwrap_collection">
            <summary>Unwrap collection</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Wrap_collection">
            <summary>Wrap collection</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Wrap_long_collection">
            <summary>Wrap long collection</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Indent_all_elements">
            <summary>Indent all elements</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unwrap_all_elements">
            <summary>Unwrap all elements</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Cannot_navigate_to_the_symbol_under_the_caret">
            <summary>Cannot navigate to the symbol under the caret.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._0_bases">
            <summary>'{0}' bases</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._0_implementations">
            <summary>'{0}' implementations</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._0_references">
            <summary>'{0}' references</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.The_symbol_has_no_base">
            <summary>The symbol has no base.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.The_symbol_has_no_implementations">
            <summary>The symbol has no implementations.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Apply_auto_property_preferences">
            <summary>Apply auto property preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Apply_blank_line_preferences_experimental">
            <summary>Apply blank line preferences (experimental)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Apply_coalesce_expression_preferences">
            <summary>Apply coalesce expression preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Apply_compound_assignment_preferences">
            <summary>Apply compound assignment preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Apply_inferred_anonymous_type_member_names_preferences">
            <summary>Apply inferred anonymous type member names preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Apply_language_framework_type_preferences">
            <summary>Apply language/framework type preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Apply_namespace_matches_folder_preferences">
            <summary>Apply namespace matches folder preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Apply_null_checking_preferences">
            <summary>Apply null checking preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Apply_null_propagation_preferences">
            <summary>Apply null propagation preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Apply_object_initializer_preferences">
            <summary>Apply object initializer preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Apply_simplify_boolean_expression_preferences">
            <summary>Apply simplify boolean expression preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Apply_string_interpolation_preferences">
            <summary>Apply string interpolation preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Apply_tuple_name_preferences">
            <summary>Apply tuple name preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Remove_unused_suppressions">
            <summary>Remove unused suppressions</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Apply_parentheses_preferences">
            <summary>Apply parentheses preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Apply_statement_after_block_preferences_experimental">
            <summary>Apply statement after block preferences (experimental)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Apply_unused_value_preferences">
            <summary>Apply unused value preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Remove_unused_parameters">
            <summary>Remove unused parameters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Apply_conditional_expression_preferences">
            <summary>Apply conditional expression preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Apply_using_directive_placement_preferences">
            <summary>Apply using directive placement preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Remove_unnecessary_imports_or_usings">
            <summary>Remove unnecessary imports or usings</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Sort_Imports_or_usings">
            <summary>Sort Imports or usings</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.if_statement">
            <summary>if statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Directives_from_0">
            <summary>Directives from '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Decompiled">
            <summary>decompiled</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Could_not_find_implementation_of_symbol_0">
            <summary>Could not find implementation of symbol '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Replace_conditional_expression_with_statements">
            <summary>Replace conditional expression with statements</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Fixing_0">
            <summary>Fixing '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Pull_selected_members_up">
            <summary>Pull selected members up</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Required">
            <summary>required</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.foreach_loop">
            <summary>foreach loop</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Deleting_0_requires_restarting_the_application_because_is_not_supported_by_the_runtime">
            <summary>Deleting {0} requires restarting the application because is not supported by the runtime.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_0_within_generic_type_or_method_requires_restarting_the_application_because_is_not_supported_by_the_runtime">
            <summary>Updating {0} within generic type or method requires restarting the application because is not supported by the runtime.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Updating_async_or_iterator_requires_restarting_the_application_because_is_not_supported_by_the_runtime">
            <summary>Updating async or iterator requires restarting the application because is not supported by the runtime.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Extract_base_record">
            <summary>Extract base record...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Enum_members">
            <summary>Enum members</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.struct_">
            <summary>struct</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.class_with_explicit_or_sequential_layout">
            <summary>class with explicit or sequential layout</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Inline_temporary_variable">
            <summary>Inline temporary variable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.while_loop">
            <summary>while loop</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.else_statement">
            <summary>else statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Code_snippet_for_0">
            <summary>Code snippet for '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Please_resolve_errors_in_your_code_before_renaming_this_element">
            <summary>Please resolve errors in your code before renaming this element.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Renaming_anonymous_type_members_is_not_yet_supported">
            <summary>Renaming anonymous type members is not yet supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.You_cannot_rename_elements_from_previous_submissions">
            <summary>You cannot rename elements from previous submissions.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.You_cannot_rename_elements_that_are_defined_in_metadata">
            <summary>You cannot rename elements that are defined in metadata.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.You_cannot_rename_operators">
            <summary>You cannot rename operators.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.You_cannot_rename_this_element">
            <summary>You cannot rename this element.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.You_must_rename_an_identifier">
            <summary>You must rename an identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.get_only_property">
            <summary>get-only property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.This_0_has_1_references">
            <summary>This {0} has {1} reference(s).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._0_reference_unquoted">
            <summary>{0} reference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.CSharp_VisualBasic_References">
            <summary>C# and Visual Basic References</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._0_references_unquoted">
            <summary>{0} references</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Find_All_References_not_invoked_on_applicable_symbol">
            <summary>'Find All References' not invoked on applicable symbol</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Deconstruct_locals_for_0">
            <summary>Deconstruct locals for '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Run_All_Tests">
            <summary>Run All Tests</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Run_Test">
            <summary>Run Test</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Debug_All_Tests">
            <summary>Debug All Tests</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Debug_Test">
            <summary>Debug Test</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Chosen_version_0">
            <summary>Chosen version: '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Could_not_find_by_name_0">
            <summary>Could not find by name: '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Decompilation_log">
            <summary>Decompilation log</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Found_0_assemblies_for_1">
            <summary>Found '{0}' assemblies for '{1}':</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Found_exact_match_0">
            <summary>Found exact match: '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Found_higher_version_match_0">
            <summary>Found higher version match: '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Found_single_assembly_0">
            <summary>Found single assembly: '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Load_from_0">
            <summary>Load from: '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Module_not_found">
            <summary>Module not found!</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Resolve_0">
            <summary>Resolve: '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Resolve_module_0_of_1">
            <summary>Resolve module: '{0}' of '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.WARN_Version_mismatch_Expected_0_Got_1">
            <summary>WARN: Version mismatch. Expected: '{0}', Got: '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._0_items_in_cache">
            <summary>'{0}' items in cache</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Convert_number">
            <summary>Convert number</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Fix_All_0">
            <summary>Fix All: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Dismiss">
            <summary>Dismiss</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Symbols">
            <summary>Symbols</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.SemanticSearch">
            <summary>Semantic Search</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Query">
            <summary>Query</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Semantic_search_only_supported_on_net_core">
            <summary>Semantic search is only supported when code analysis runs in a separate process on the latest .NET (see Tools &gt; Options &gt; Text Editor &gt; C# &gt; Advanced).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Semantic_search_query_terminated_with_exception">
            <summary>Semantic search query terminated with exception</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Semantic_search_query_failed_to_compile">
            <summary>Semantic search query failed to compile</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.The_query_does_not_specify_0_top_level_function">
            <summary>The query does not specify '{0}' top-level function</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Method_0_must_be_static_and_non_generic">
            <summary>Method '{0}' must be static and non-generic</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.The_query_specifies_multiple_top_level_functions_1">
            <summary>The query specifies multiple top-level functions '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Top_level_function_0_must_have_a_single_parameter">
            <summary>Top-level function '{0}' must have a single parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Parameter_type_0_is_not_among_supported_types_1">
            <summary>Parameter type '{0}' is not among supported types: {1}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Return_type_0_is_not_among_supported_types_1">
            <summary>Return type '{0}' is not among supported types: {1}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unable_to_load_type_0_1">
            <summary>Unable to load type '{0}': '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.NET_Code_Actions">
            <summary>.NET Code Actions</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Symbol_search">
            <summary>Symbol search</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Conflict_s_detected">
            <summary>Conflict(s) detected.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Simplify_name_0">
            <summary>Simplify name '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Simplify_member_access_0">
            <summary>Simplify member access '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Not_all_code_paths_return">
            <summary>Not all code paths return</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.namespace_name">
            <summary>&lt;namespace name&gt;</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.class_name">
            <summary>&lt;class name&gt;</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.interface_name">
            <summary>&lt;interface name&gt;</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unable_to_create_0">
            <summary>Unable to create '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Cannot_determine_valid_range_of_statements_to_extract">
            <summary>Cannot determine valid range of statements to extract</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.No_valid_statement_range_to_extract">
            <summary>No valid statement range to extract</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Convert_to_field_property">
            <summary>Convert to 'field' property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Extension_0_is_already_registered">
            <summary>Extension '{0}' is already registered.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Extension_0_was_not_registered">
            <summary>Extension '{0}' was not registered.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Unable_to_get_the_directory_name_for_0">
            <summary>Unable to get the directory name for {0}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.No_extension_registered_as_0">
            <summary>No extension registered as '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.No_extensions_registered_at_0">
            <summary>No extensions registered at '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.No_handler_found_for_message_0">
            <summary>No handler found for message {0}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Multiple_handlers_found_for_message_0">
            <summary>Multiple handlers found for message {0}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_0_check">
            <summary>Add '{0}' check</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_negative_value_check">
            <summary>Add negative value check</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources.Add_negative_value_or_zero_check">
            <summary>Add negative value or zero check</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._0_cannot_be_negative">
            <summary>'{0}' cannot be negative</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FeaturesResources._0_cannot_be_negative_or_zero">
            <summary>'{0}' cannot be negative or zero</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Remove_Unnecessary_Cast">
            <summary>Remove Unnecessary Cast</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Remove_unused_member">
            <summary>Remove unused member</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Private_member_0_is_unused">
            <summary>Private member '{0}' is unused</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Remove_unused_private_members">
            <summary>Remove unused private members</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Remove_unread_private_members">
            <summary>Remove unread private members</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Private_member_0_can_be_removed_as_the_value_assigned_to_it_is_never_read">
            <summary>Private member '{0}' can be removed as the value assigned to it is never read</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Private_method_0_can_be_removed_as_it_is_never_invoked">
            <summary>Private method '{0}' can be removed as it is never invoked.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Private_property_0_can_be_converted_to_a_method_as_its_get_accessor_is_never_invoked">
            <summary>Private property '{0}' can be converted to a method as its get accessor is never invoked.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.A_source_file_is_missing_a_required_header">
            <summary>A source file is missing a required header.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.The_file_header_is_missing_or_not_located_at_the_top_of_the_file">
            <summary>The file header is missing or not located at the top of the file</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.A_source_file_contains_a_header_that_does_not_match_the_required_text">
            <summary>A source file contains a header that does not match the required text</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.The_file_header_does_not_match_the_required_text">
            <summary>The file header does not match the required text</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Use_throw_expression">
            <summary>Use 'throw' expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Add_this_or_Me_qualification">
            <summary>Add 'this' or 'Me' qualification</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Member_access_should_be_qualified">
            <summary>Member access should be qualified.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Null_check_can_be_simplified">
            <summary>Null check can be simplified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Simplify_collection_initialization">
            <summary>Simplify collection initialization</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Collection_initialization_can_be_simplified">
            <summary>Collection initialization can be simplified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Simplify_object_initialization">
            <summary>Simplify object initialization</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Object_initialization_can_be_simplified">
            <summary>Object initialization can be simplified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Add_readonly_modifier">
            <summary>Add readonly modifier</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Make_field_readonly">
            <summary>Make field readonly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Naming_rule_violation_0">
            <summary>Naming rule violation: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Naming_Styles">
            <summary>Naming Styles</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Add_missing_cases">
            <summary>Add missing cases</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Populate_switch">
            <summary>Populate switch</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Modifiers_are_not_ordered">
            <summary>Modifiers are not ordered</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Order_modifiers">
            <summary>Order modifiers</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Expression_value_is_never_used">
            <summary>Expression value is never used</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Unnecessary_assignment_of_a_value_to_0">
            <summary>Unnecessary assignment of a value to '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Unnecessary_assignment_of_a_value">
            <summary>Unnecessary assignment of a value</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Avoid_unnecessary_value_assignments_in_your_code_as_these_likely_indicate_redundant_value_computations_If_the_value_computation_is_not_redundant_and_you_intend_to_retain_the_assignmentcomma_then_change_the_assignment_target_to_a_local_variable_whose_name_starts_with_an_underscore_and_is_optionally_followed_by_an_integercomma_such_as___comma__1_comma__2_comma_etc">
            <summary>Avoid unnecessary value assignments in your code, as these likely indicate redundant value computations. If the value computation is not redundant and you intend to retain the assignment, then change the assignment target to a local variable whose name sta ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Remove_unused_parameter">
            <summary>Remove unused parameter</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Remove_unused_parameter_0">
            <summary>Remove unused parameter '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Avoid_unused_parameters_in_your_code_If_the_parameter_cannot_be_removed_then_change_its_name_so_it_starts_with_an_underscore_and_is_optionally_followed_by_an_integer_such_as__comma__1_comma__2_etc_These_are_treated_as_special_discard_symbol_names">
            <summary>Avoid unused parameters in your code. If the parameter cannot be removed, then change its name so it starts with an underscore and is optionally followed by an integer, such as '_', '_1', '_2', etc. These are treated as special discard symbol names.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Remove_unused_parameter_0_if_it_is_not_part_of_a_shipped_public_API">
            <summary>Remove unused parameter '{0}' if it is not part of a shipped public API</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Parameter_0_can_be_removed_if_it_is_not_part_of_a_shipped_public_API_its_initial_value_is_never_used">
            <summary>Parameter '{0}' can be removed if it is not part of a shipped public API; its initial value is never used</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Parameter_0_can_be_removed_its_initial_value_is_never_used">
            <summary>Parameter '{0}' can be removed; its initial value is never used</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Add_accessibility_modifiers">
            <summary>Add accessibility modifiers</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Accessibility_modifiers_required">
            <summary>Accessibility modifiers required</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Convert_to_conditional_expression">
            <summary>Convert to conditional expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Use_coalesce_expression">
            <summary>Use coalesce expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Changes_to_expression_trees_may_result_in_behavior_changes_at_runtime">
            <summary>Changes to expression trees may result in behavior changes at runtime</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Parentheses_can_be_removed">
            <summary>Parentheses can be removed</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Remove_unnecessary_parentheses">
            <summary>Remove unnecessary parentheses</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Add_parentheses_for_clarity">
            <summary>Add parentheses for clarity</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Parentheses_should_be_added_for_clarity">
            <summary>Parentheses should be added for clarity</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Prefer_explicitly_provided_tuple_element_name">
            <summary>Prefer explicitly provided tuple element name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Use_explicitly_provided_tuple_name">
            <summary>Use explicitly provided tuple name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Use_System_HashCode">
            <summary>Use 'System.HashCode'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.GetHashCode_implementation_can_be_simplified">
            <summary>'GetHashCode' implementation can be simplified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Use_compound_assignment">
            <summary>Use compound assignment</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Use_null_propagation">
            <summary>Use null propagation</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Use_inferred_member_name">
            <summary>Use inferred member name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Member_name_can_be_simplified">
            <summary>Member name can be simplified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Interpolation_can_be_simplified">
            <summary>Interpolation can be simplified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Simplify_interpolation">
            <summary>Simplify interpolation</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Use_auto_property">
            <summary>Use auto property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Format_string_contains_invalid_placeholder">
            <summary>Format string contains invalid placeholder</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Invalid_format_string">
            <summary>Invalid format string</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Simplify_conditional_expression">
            <summary>Simplify conditional expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Conditional_expression_can_be_simplified">
            <summary>Conditional expression can be simplified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Invalid_global_SuppressMessageAttribute">
            <summary>Invalid global 'SuppressMessageAttribute'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Invalid_scope_for_SuppressMessageAttribute">
            <summary>Invalid scope for 'SuppressMessageAttribute'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Invalid_or_missing_target_for_SuppressMessageAttribute">
            <summary>Invalid or missing target for 'SuppressMessageAttribute'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Avoid_legacy_format_target_in_SuppressMessageAttribute">
            <summary>Avoid legacy format target in 'SuppressMessageAttribute'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Avoid_legacy_format_target_0_in_SuppressMessageAttribute">
            <summary>Avoid legacy format target '{0}' in 'SuppressMessageAttribute'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Remove_unnecessary_suppression">
            <summary>Remove unnecessary suppression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Remove_redundant_equality">
            <summary>Remove redundant equality</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Use_decrement_operator">
            <summary>Use '--' operator</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Use_increment_operator">
            <summary>Use '++' operator</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Avoid_multiple_blank_lines">
            <summary>Avoid multiple blank lines</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Blank_line_required_between_block_and_subsequent_statement">
            <summary>Blank line required between block and subsequent statement</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Change_namespace_to_match_folder_structure">
            <summary>Change namespace to match folder structure</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Namespace_0_does_not_match_folder_structure_expected_1">
            <summary>Namespace "{0}" does not match folder structure, expected "{1}"</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Namespace_does_not_match_folder_structure">
            <summary>Namespace does not match folder structure</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Simplify_LINQ_expression">
            <summary>Simplify LINQ expression</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Set_MSBuild_Property_GenerateDocumentationFile_to_true">
            <summary>Set MSBuild property 'GenerateDocumentationFile' to 'true'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Set_MSBuild_Property_GenerateDocumentationFile_to_true_in_project_file_to_enable_IDE0005_Remove_unnecessary_usings_imports_on_build">
            <summary>Set MSBuild property 'GenerateDocumentationFile' to 'true' in project file to enable IDE0005 (Remove unnecessary usings/imports) on build</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Add_the_following_PropertyGroup_to_your_MSBuild_project_file_to_enable_IDE0005_Remove_unnecessary_usings_imports_on_build">
            <summary>Add the following PropertyGroup to your MSBuild project file to enable IDE0005 (Remove unnecessary usings/imports) on build:
              &lt;PropertyGroup&gt;
                &lt;!--
                  Make sure any documentation comments which are included in code get checked for syntax during the  ...</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Fix_formatting">
            <summary>Fix formatting</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources._0_statement_implicitly_converts_1_to_2_Add_an_explicit_cast_to_make_intent_clearer_as_it_may_fail_at_runtime">
            <summary>'{0}' statement implicitly converts '{1}' to '{2}'. Add an explicit cast to make intent clearer, as it may fail at runtime</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Add_explicit_cast">
            <summary>Add explicit cast</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Name_can_be_simplified">
            <summary>Name can be simplified</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Simplify_Names">
            <summary>Simplify Names</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Simplify_Member_Access">
            <summary>Simplify Member Access</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Remove_accessibility_modifiers">
            <summary>Remove accessibility modifiers</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Simplify_check">
            <summary>Simplify check</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Base_classes_contain_inaccessible_unimplemented_members">
            <summary>Base classes contain inaccessible unimplemented members</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Implement_abstract_class">
            <summary>Implement abstract class</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Implement_through_0">
            <summary>Implement through '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AnalyzersResources.Accessibility_modifiers_unnecessary">
            <summary>Accessibility modifiers unnecessary</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Add_file_header">
            <summary>Add file header</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Fix_name_violation_colon_0">
            <summary>Fix name violation: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Add_both">
            <summary>Add both</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Add_default_case">
            <summary>Add default case</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Use_discarded_local">
            <summary>Use discarded local</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Use_discard_underscore">
            <summary>Use discard '_'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Remove_redundant_assignment">
            <summary>Remove redundant assignment</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Update_suppression_format">
            <summary>Update suppression format</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Suppress_or_configure_issues">
            <summary>Suppress or configure issues</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Fix_all_occurrences_in">
            <summary>Fix all occurrences in</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Remove_extra_blank_lines">
            <summary>Remove extra blank lines</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Add_blank_line_after_block">
            <summary>Add blank line after block</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Make_class_abstract">
            <summary>Make class 'abstract'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Make_member_static">
            <summary>Make static</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Alias_ambiguous_type_0">
            <summary>Alias ambiguous type '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Convert_type_to_0">
            <summary>Convert type to '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Make_type_partial">
            <summary>Make type partial</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Add_member_name">
            <summary>Add member name</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Add_parameter_to_0">
            <summary>Add parameter to '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Add_parameter_to_0_and_overrides_implementations">
            <summary>Add parameter to '{0}' (and overrides/implementations)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Add_to_0">
            <summary>Add to '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Related_method_signatures_found_in_metadata_will_not_be_updated">
            <summary>Related method signatures found in metadata will not be updated.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Remove_async_modifier">
            <summary>Remove 'async' modifier</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Take_0">
            <summary>Take '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Take_both">
            <summary>Take both</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Take_bottom">
            <summary>Take bottom</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Take_top">
            <summary>Take top</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Add_missing_param_nodes">
            <summary>Add missing param nodes</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Remove_tag">
            <summary>Remove tag</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Make_method_synchronous">
            <summary>Make method synchronous</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources._0_may_change_semantics">
            <summary>{0} (may change semantics)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Generate_constructor_in_0">
            <summary>Generate constructor in '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Generate_constructor_in_0_with_fields">
            <summary>Generate constructor in '{0}' (with fields)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Generate_constructor_in_0_with_properties">
            <summary>Generate constructor in '{0}' (with properties)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Generate_constructor_0_1">
            <summary>Generate constructor '{0}({1})'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Generate_all">
            <summary>Generate all</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Generate_field_assigning_constructor_0_1">
            <summary>Generate field assigning constructor '{0}({1})'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Implement_interface_abstractly">
            <summary>Implement interface abstractly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Implement_interface_through_0">
            <summary>Implement interface through '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Implement_interface_with_Dispose_pattern">
            <summary>Implement interface with Dispose pattern</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Implement_interface_explicitly_with_Dispose_pattern">
            <summary>Implement interface explicitly with Dispose pattern</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Implement_remaining_members_explicitly">
            <summary>Implement remaining members explicitly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Implement_interface">
            <summary>Implement interface</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Implement_all_members_explicitly">
            <summary>Implement all members explicitly</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.TODO_colon_dispose_managed_state_managed_objects">
            <summary>TODO: dispose managed state (managed objects)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.TODO_colon_free_unmanaged_resources_unmanaged_objects_and_override_finalizer">
            <summary>TODO: free unmanaged resources (unmanaged objects) and override finalizer</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.TODO_colon_set_large_fields_to_null">
            <summary>TODO: set large fields to null</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Do_not_change_this_code_Put_cleanup_code_in_0_method">
            <summary>Do not change this code. Put cleanup code in '{0}' method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.TODO_colon_override_finalizer_only_if_0_has_code_to_free_unmanaged_resources">
            <summary>TODO: override finalizer only if '{0}' has code to free unmanaged resources</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Generate_constant_0">
            <summary>Generate constant '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Generate_read_only_field_0">
            <summary>Generate read-only field '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Generate_read_only_property_0">
            <summary>Generate read-only property '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Generate_field_0">
            <summary>Generate field '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Generate_local_0">
            <summary>Generate local '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Generate_parameter_0">
            <summary>Generate parameter '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Generate_parameter_0_and_overrides_implementations">
            <summary>Generate parameter '{0}' (and overrides/implementations)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Generate_variable_0">
            <summary>Generate variable '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Generate_enum_member_0">
            <summary>Generate enum member '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Generate_abstract_method_0">
            <summary>Generate abstract method '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Generate_abstract_property_0">
            <summary>Generate abstract property '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Generate_method_0">
            <summary>Generate method '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Generate_property_0">
            <summary>Generate property '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Generate_narrowing_conversion_in_0">
            <summary>Generate narrowing conversion in '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Generate_widening_conversion_in_0">
            <summary>Generate widening conversion in '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Generate_implicit_conversion_operator_in_0">
            <summary>Generate implicit conversion operator in '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesResources.Generate_explicit_conversion_operator_in_0">
            <summary>Generate explicit conversion operator in '{0}'</summary>
        </member>
        <member name="T:Microsoft.SourceLink.Tools.SourceLinkMap">
            <summary>
            Source Link URL map. Maps file paths matching Source Link patterns to URLs.
            </summary>
        </member>
        <member name="M:Microsoft.SourceLink.Tools.SourceLinkMap.Parse(System.String)">
            <summary>
            Parses Source Link JSON string.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="json"/> is null.</exception>
            <exception cref="T:System.IO.InvalidDataException">The JSON does not follow Source Link specification.</exception>
            <exception cref="T:System.Text.Json.JsonException"><paramref name="json"/> is not valid JSON string.</exception>
        </member>
        <member name="M:Microsoft.SourceLink.Tools.SourceLinkMap.TryGetUri(System.String,System.String@)">
            <summary>
            Maps specified <paramref name="path"/> to the corresponding URL.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null.</exception>
        </member>
        <member name="T:Microsoft.Cci.CompilationOptionNames">
            <summary>
            Names for compilation options that get embedded as debug information
            in the PDB as key-value pairs.
            </summary>
            <remarks>
            REMOVAL OR CHANGES TO EXISTING VALUES IS CONSIDERED A BREAKING CHANGE FOR PDB FORMAT
            </remarks>
        </member>
    </members>
</doc>
